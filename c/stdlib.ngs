# === Trivial init() helper ===

doc Trivial initialization helper for init(o, ...)
doc Sets object fields from the supplied parameters
doc %EX - # sets t.a and t.b
doc %EX - F init(t:MyType, a, b) init(args())
F init(h:Hash) {
	args = Arr(h)
	dst = args.shift()[1]
	args.each(F(field_name_value) (.=)(dst, field_name_value[0], field_name_value[1]))
	dst
}

# === Exceptions ===

{
	doc Represents failed asserttion, thrown by assert()
	type AssertFail
	AssertFail.inherit(Exception)
}

doc IndexNotFound exception constructor
doc %RET - IndexNotFound type instance with the given message, container and key attributes
F init(e:IndexNotFound, message:Str, container, key) init(args())

doc Throws AssertFail with givens message if condition is false
doc %RET - Unspecified, do not count on this value
F assert(condition:Bool, msg:Str) not(condition) throws AssertFail(msg)

doc Throws AssertFail if condition is false
doc %RET - Unspecified, do not count on this value
F assert(condition:Bool) assert(condition, "Assertion failed")

F assert(condition, *args) {
	guard condition is not Bool
	super(Bool(condition), *args)
}

# === Return =====================================

doc Implements calling of Return type instances
doc like the finish(i) call in the example below
doc %EX - F first(r:Range, predicate:Fun) {
doc %EX - 	finish = Return()
doc %EX - 	r.each(F(i) {
doc %EX - 		predicate(i) throws finish(i)
doc %EX - 	})
doc %EX - 	null
doc %EX - }
F call(r:Return, v=null) {
	r.val = v
	r
}

# === Misc functional ============================


doc %RET - The given argument
F identity(x)  x

TEST identity(10) == 10


# TODO: Add more info about the newly created function - useful for debugging
#       See https://docs.python.org/2/library/functools.html#partial-objects
doc Returns partially-applied function
doc f - The base function
doc Xunderscore_unsupportedXbind_args - The arguments to partiall apply (bind the function to)
F partial(f:Fun, *bind_args)
	F(*args) f(*bind_args, *args)

TEST p = partial((-), 10); p(7) == 3


doc Same as partial() but the bound arguments are last ones
F partial_tail(f:Fun, *bind_args)
	F(*args) f(*args, *bind_args)

TEST p = partial_tail((-), 10); p(7) == -3

doc Sets the given attribute to the given value
doc %RET - The modified obj
doc %EX - s.len() != 1 throws InvalidArgument("ord() argument must be of length 1 exactly").set('given', s)
doc %EX - # Would else be written as
doc %EX - if s.len() != 1 {
doc %EX - 	e = InvalidArgument("ord() argument must be of length 1 exactly")
doc %EX - 	e.given = s
doc %EX - 	throw e
doc %EX - }
F set(obj, attr:Str, val) {
	(.=)(obj, attr, val)
	obj
}

doc Convert anything to a predicate
doc anything - The value to compare to
doc %RET - A function that compares the only argument to the given value
F Pred(anything) F eq_pred(x) x == anything

doc Convert a function to predicate
doc %RET - The given function, without any transformation
F Pred(f:Fun) f

doc Convert a type to a predicate
doc t - A type
doc %RET - A function that checks whether the only argument is of type t
F Pred(t:Type) F is_pred(x) x is t

doc Map something to an Arr (array) of values using mapper
doc something - Instance of any type that has each(something, callback) implemented
doc %RET - Arr
doc %EX - [1,2,3].map((*), 4)  # [4,8,12]
F map(something, mapper:Fun)
	collector
		something.each(F(elt) collect(mapper(elt)))

doc Filter something to an Arr (array) of values using predicate
doc something - Instance of any type that has each(something, callback) implemented.
doc predicate - Decision function to be called with each item as first argument.
doc predicate - When predicate(item) returns true, the item will appear in the resulting array.
doc %EX - (1...10).filter(F(num) num % 2 == 0)  # Gives [2,4,6,8,10]
doc %EX - (1...10).filter(X<5)  # Gives [1,2,3,4], predicate called as predicate(item, 5)
doc %RET - Arr
F filter(something, predicate) {
	p = Pred(predicate)
	collector
		something.each(F(elt) {
			if p(elt)
				collect(elt)
		})
}

{
	type TheOneFail
	TheOneFail.inherit(InvalidArgument)
}

doc Find the only element that satisfies the predicate.
doc Throws TheOneFail exception if there are no elements that satisfy the predicate or if there is more than one element that satisfies the predicate.
doc %RET - The only element that satisfies the predicate.
F the_one(something, predicate) {
	p = Pred(predicate)
	ret = EmptyBox()
	something.each(F(elt) {
		if p(elt) {
			ret throws TheOneFail("the_one() had more than one match")
			ret = FullBox(elt)
		}
	})
	not(ret) throws TheOneFail("the_one() had no matches")
	ret.val
}

TEST [1,2,11,3,4].the_one(X>10) == 11
TEST try [1,2,11,12,4].the_one(X>10) catch(e:TheOneFail) true
TEST try [1,2,3,4].the_one(X>10) catch(e:TheOneFail) true

doc Find the only element that satisfies the predicate and execute given code with the value
doc body - The code to execute when exactly one element that satisfies the predicate was found. Executed with the found value. It's value will be returned as result of the_one().
doc found_more - The code to execute when more than one element satisfies the predicate. It's value will be returned as result of the_one(). Defaults to function returning null.
doc found_none - The code to execute when none of the elements satisfy the predicate. It's value will be returned as result of the_one(). Defaults to function returning null.
doc %RET - Result of running on of the following: body, found_more, found_none
doc %EX - F name(dn:MethodDocNode) {
doc %EX - 	dn.children.the_one(MethodNameDocNode).text[0]
doc %EX - }
F the_one(something, predicate, body:Fun, found_more:Fun={null}, found_none:Fun={null}) {
	p = Pred(predicate)
	ret = EmptyBox()
	r = Return()
	something.each(F(elt) {
		if p(elt) {
			if ret {
				throw r(found_more())
			}
			ret = FullBox(elt)
		}
	})
	if ret {
		body(ret.val)
	} else {
		found_none()
	}
}

TEST ok = false; [1,2,11,3,4].the_one(X>10, F(the_value) { if(the_value == 11) ok = true });
TEST ok = false; [1,2,11,3,4].the_one(X>20, { does_not_matter }, found_none = { ok = true }); ok
TEST ok = false; [1,2,11,3,4].the_one(Int, { does_not_matter }, found_more = { ok = true }); ok

doc Filter nulls out.
doc DEPRECATED, USE something.without(null) INSTEAD.
doc something - Instance of any type that has each(something, callback) implemented
doc %RET - Arr (array) of original items without nulls
F filter(something) {
	error("USING DEPRECATED filter(something)")
	filter(something, X is not Null)
}

TEST [1,2,null,3].filter() == [1,2,3]

doc Filter something to an Arr (array) of values using predicate
doc predicate - Decision function to be called with each item as first argument.
doc predicate - When predicate(item) returns true, the item will not appear in the resulting array
doc something - Instance of any type that has each(something, callback) implemented
doc %EX - (1...10).reject(F(num) num % 2 == 0)  # Gives [1,3,5,7,9]
doc %EX - (1...10).reject((<), 5)  # Gives [5,6,7,8,9,10], predicate called as predicate(item, 5)
doc %RET - Arr
F reject(something, predicate) {
	p = Pred(predicate)
	something.filter({ p(A).not() })
}


doc EXPERIMENTAL! Do not use!
F take_while(something, predicate)
	collector {
		p = Pred(predicate)
		r = Return()
		something.each(F(elt) {
			if p(elt)
				collect(elt)
			else
				throw r()
		})
	}

TEST [1,2,3,1,2].take_while(X<3) == [1,2]

# Would look much better with an iterator of "something"
doc EXPERIMENTAL! Do not use!
F drop_while(something, predicate)
	collector {
		p = Pred(predicate)
		found = false
		something.each(F(elt) {
			if found { collect(elt); return null; }
			if not(p(elt)) {
				collect(elt)
				found = true
			}
		})
	}

TEST [1,2,3,1,2].drop_while(X<3) == [3,1,2]

doc Combine items to a single value using the supplied binary function
doc First f is applied to start and the first element of something
doc then on each step f is applied to previous result and next element
doc of something.
doc start - First argument of f, for the first call of f
doc something - Instance of any type that has each(something, callback) implemented
doc f - The combining function
doc %EX - F sum(something) something.reduce(0, (+))
F reduce(something, start, f:Fun) {
	ret = start
	something.each(F(elt) ret = f(ret, elt))
	ret
}

TEST [1,2,3].reduce(0, (+)) == 6

doc Filter operator.
doc Same as calling x.filter(predicate)
doc %EX - [1,2,3,4] ? F(x) x > 2  # [3,4]
F ?(x, predicate:Fun) x.filter(predicate)

doc Map operator.
doc Same as calling x.map(mapper)
doc %EX - [1,2,3,4] / F(x) x * 10
F /(x, mapper:Fun) x.map(mapper)

doc Each operator.
doc Same as calling x.each(cb)
doc %EX - [1,2,3,4] % echo
F %(x, cb:Fun) x.each(cb)

doc Call operator.
doc Same as calling f(x)
doc %EX - [1,2,3,4] \ echo
F \(x, f:Fun) f(x)


# === Hook =======================================

{
	doc Hook is a simple pub-sub
	type Hook

	doc CONSIDERED FOR REMOVAL
	type HookDecorator
}

doc Hook constructor.
doc combiner - A function for processing results from all handlers. The outputs are passed as a Hash. Keys are handlers names and values are what handlers return when they run.
doc %RET - Hook
F init(hook:Hook, combiner=values) {
	init(args())
	hook.handlers = {}
	hook.idx = 0
}

doc Get hook handler
F '[]'(hook:Hook, name:Str) hook.handlers[name]

doc Set hook handler
F '[]='(hook:Hook, name:Str, handler:Closure) hook.handlers[name] = handler

doc Add unnamed handler.
doc The hook is automatically named "pushed-N" where N is sequential integer.
doc %RET - New hook name
F push(hook:Hook, handler:Closure) {
	name = "pushed-${hook.idx}"
	hook.idx += 1
	hook[name] = handler
	name
}

# TODO: consider optional? try/catch isolation
doc Runs all handlers passing all args.
doc args - Arguments to pass to handlers
doc %RET - Output of the combiner function applied to all handlers' results
F call(hook:Hook, *args) {
	result = hook.handlers.mapv(F(handler) handler(*args))
	(hook.combiner)(result)
}


# === HookDecorator ==============================

doc TODO
F init(hd:HookDecorator, hook:Hook) init(args())

doc TODO
F init(hd:HookDecorator, hook:Hook, name:Str) init(args())

F @(hook:Hook, handler:Closure) hook.push(handler)

F @(hd:HookDecorator, handler:Closure) {
	if 'name' in hd
		hd.hook[hd.name] = handler
	else
		hd.hook.push(handler)
}

doc TODO
F hook(h:Hook, *args) HookDecorator(h, *args)

TEST h = Hook(); a=1; h["my1"] = F() a+=1; @h { a*=2 }; @hook(h, "my2") { a*=3 }; h(); a==12 and h.handlers.keys() == ["my1", "pushed-0", "my2"]
TEST h = Hook(); F @(hook, ovr) ovr.replace({"B"}); @h F f() "A"; f() == "B"


# === Real =======================================

# TODO: something more efficient
doc Convert a string to real (floating) number, inefficiently
doc %RET - Real
doc %EX - Real("1.1")  # 1.1
F Real(s:Str) {
	parts = s.split('.')
	parts.len() == 1 returns Real(Int(parts[0]))
	parts.len() != 2 throws InvalidArgument("Invalid argument ${s}")
	l = parts[1].len()
	frac = Real(Int(parts[1]))
	for(i;l) frac = frac / 10.0
	Real(Int(parts[0])) + frac
}

TEST Real('1.1') == 1.1

# === NativeMethod ===============================

doc String representation of native method.
doc %RET - "<Native method NAME>"
doc %EX - (%)[0].Str().echo()  # Outputs: <Native method %>
F Str(c:NativeMethod) {
	"<Native method ${c.attrs().name}>"
}

# === Closure ====================================

# TODO: show arguments:
#   "<Closure ${c.attrs().name tor "<anonymous>"}(HERE) at ${location}>"
doc String representation of a closure
doc %RET - Str
doc %EX - Real.constructors[-1].Str().echo()  # Outputs: <Closure Real at /usr/share/ngs/stdlib.ngs:350>
F Str(c:Closure) {
	info = c.ip().resolve_instruction_pointer()
	location = "${info.file}:${info.first_line}" tor "<unknown location>"
	"<Closure ${c.attrs().name tor "<anonymous>"} at ${location}>"
}

# === Type =======================================

doc Type constructor
doc %EX - type MyType1
doc %EX - type MyType2(MyType1)
F Type(t:Str, doc, parent:Type) Type(t, doc, [parent])

doc Type constructor
doc %EX - type MyType1
doc %EX - type MyType2
doc %EX - type MyType3([MyType1, MyType2])
F Type(t:Str, doc, parents:Arr) {
	ret = Type(t, doc)
	parents % ret.inherit(X)
	ret
}

TEST type T1; type T2(T1); T2() is T1

doc Match a type. Same as "something is t".
doc %EX -   1 ~ Int  # true
doc %EX - "a" ~ Int  # false
F ~(something, t:Type) something is t


STDLIB_EXPOSE = {}

# TODO: better exceptions (use correct type, not string, provide offending type and attribute)
doc Exposes the given attribute so when ImplNotFound exception occurs and
doc when the original call had instance of the given type as an argument
doc the call is retried with the instance replaced by the given argument
doc Currently only used in Stats type. Safe to ignore for beginners.
doc
doc typ - ImplNotFound with instance of this type will cause retry with the given attribute
doc attr - The exposed attribute that will be used on call retry
doc %RET - typ
doc %EX - {
doc %EX - 	type Stats
doc %EX - 	Stats.expose(h)
doc %EX - }
doc %EX -
doc %EX - F init(s:Stats) {
doc %EX - 	s.h = {}
doc %EX - }
doc %EX -
doc %EX - F Stats(a:Arr) {
doc %EX - 	s = Stats()
doc %EX - 	a.each(partial(push, s))
doc %EX - 	s
doc %EX - }
doc %EX -
doc %EX - F push(s:Stats, k) {
doc %EX - 	s.h[k] = s.h.get(k, 0) + 1
doc %EX - 	s
doc %EX - }
doc %EX -
doc %EX - # Usage:
doc %EX - numbering = Stats()
doc %EX - numbering.push(hostname_base)
doc %EX - ... numbering[hostname_base]} ...
F expose(typ:NormalType, attr:Str) {
	STDLIB_EXPOSE[typ] = STDLIB_EXPOSE.get(typ, []).push(attr)
	if STDLIB_EXPOSE[typ].len() > 1 {
		throw NotImplemented("expose() does not support exposing more than one attribute at this time").set('type', typ).set('attr', attr)
	}
	typ
}

# * if there is no appropriate mymethod(...,my_type_instance,...) and the type of my_type_instance
#   has expose()d attribute, retry the call with mymethod(...,my_type_instance.exposed_attribute,...)
# * This is called by the VM when a method was called but none of the implementations matched
#   the parameters (or failed "guard" statements).
# TODO: make it faster
# TODO: support trying all attributes listed in STDLIB_EXPOSE, not just first
# TODO: check and solve usage by inheriting types
# TODO: support keword arguments?
doc Called on ImplNotFound.
doc Implements expose() behaviour.
doc callable - The method being called.
doc args - Call arguments.
doc %RET - Result of calling the callable with modified argument.
F impl_not_found_handler(callable:Fun, *args) {
	l = args.len()
	exposed_attr_name = null
	for(i;l) {
		arg = args[i]
		if typeof(arg) in STDLIB_EXPOSE {
			exposed_attr_name = STDLIB_EXPOSE[typeof(arg)][0]
			change_idx = i
			break
		}
	}
	guard exposed_attr_name
	new_args = copy(args)
	new_args[change_idx] = (.)(new_args[change_idx], exposed_attr_name)
	callable(*new_args)
}

doc String representation of a type
doc %RET - "<Type NAME>"
doc %EX - Real.Str().echo()  # Outputs: <Type Real>
F Str(t:Type) "<Type ${t.name}>"

# === NormalType =================================

doc String representation of normal type instance i
doc Normal type is a user defined type. In addition some types defined by NGS are also normal types.
doc %EX - {
doc %EX -   type T
doc %EX -   # nti - Normal type instance
doc %EX -   nti = T()
doc %EX -   nti.a = 1
doc %EX -   nti.b = 2
doc %EX -   echo(Str(nti)) # <T a=1 b=2>
doc %EX - }
doc %RET - "<TYPE_NAME attr1=val1 attr2=val2 ...>"
F Str(i:NormalTypeInstance) {
	h = Hash(i)
	truncated = len(h) > 10
	if truncated {
		h .= limit(10)
	}
	# TODO limit key and value lengths
	h .= Strs()

	"<${i.typeof().name} ${h.join(' ')}${if truncated ' ...' else ''}>"
}

doc Set an attribute in an instance if it's not already set
doc %EX - mysomething.dflt(k, []).push(elt)
doc %RET - Attribute value, the already-existed or new.
F dflt(i:NormalTypeInstance, k, v) {
	if k not in i {
		(.=)(i, k, v)
	}
	(.)(i, k)
}

doc Equaity test for normal type instances: must be of same type and have same attributes and their values
doc %RET - Bool
doc %EX - type T
doc %EX - t1 = T()
doc %EX - t1.a = 1
doc %EX - t2 = T()
doc %EX - t2.a = 1
doc %EX - echo(t1 == t2)  # Outputs: true
F ==(a:NormalTypeInstance, b:NormalTypeInstance) {
	typeof(a) != typeof(b) returns false
	Hash(a) == Hash(b)
}


# === Exceptions =================================

{
	# TODO: Investigate why type CException(Error) does not work at this point
	doc Base type for exceptions arising from errors returned by calling C functions
	type CException
	CException.inherit(Error)

	doc CException constructor. In addition to storing message attribute, adds errno and errno_name attributes.
	F init(e:CException, message:Str) {
		errno = get_c_errno()
		super(e, message)
		e.errno = errno
		e.errno_name = c_strerror(e.errno)
	}

	doc Exception representing a failure to kill() a process
	type KillFail
	KillFail.inherit(CException)
}

# === auto-load ==================================

doc Called when reading undefined global.
doc Implements autoloading.
doc Searches in $NGS_DIR/autoload/NAME.ngs
doc WARNING: May have security implications when looking up a name from untrusted source.
doc %EX - test("My web server runs") do { .... }  # $NGS_DIR/autoload/test.ngs is automatically loaded.
F global_not_found_handler(name:Str) {
	require("${NGS_DIR}/autoload/${name}.ngs")
}

# === Range ======================================

doc Range constructor
F init(r:Range, start, end, step=1) init(args())

doc ExclusiveRange constructor
F ..(start, end)  ExclusiveRange(start, end)

doc InclusiveRange constructor
F ...(start, end) InclusiveRange(start, end)

doc Iterates over the elements of r, passing each in turn to cb.
doc cb - Function to be called with values from r
doc args - Additional arguments for calling cb
doc %RET - r
doc %EX - s=0
doc %EX - (1...10).each(F(i) { global s; s+=i })
doc %EX - echo(s)  # Outputs: 55
F each(r:Range, cb:Fun) {
	# TODO: support Real step
	econd {
		(r.end is Null) or (r.step == 0) {
			cmp = F(a,b) true
		}
		r.step > 0 {
			cmp = if r is ExclusiveRange (<) (<=)
		}
		r.step < 0 {
			cmp = if r is ExclusiveRange (>) (>=)
		}
	}
	for(i=r.start; cmp(i, r.end); i=i+r.step)
		cb(i)
	r
}

TEST (1..3).map(X*2) == [2, 4]
TEST (1...3).map(X*2) == [2, 4, 6]

doc Find first element in r that satisfies the predicate.
doc args - Additional arguments for calling the predicate.
doc The predicate is called with each one of the elements plus the args: predicate(i)
doc %RET - Either the element or null if element was not found.
doc %EX - (10..20).first(F(x) x % 3 == 0)  # 12 - first item divisible by 3
F first(r:Range, predicate:Fun) {
	finish = Return()
	r.each(F(i) {
		predicate(i) throws finish(i)
	})
	null
}

TEST (10..20).first(F(x) x % 3 == 0) == 12

doc TODO
F Str(r:ExclusiveRange) "<ExclusiveRange ${r.start}..${r.end} step ${r.step}>"

doc TODO
F Str(r:InclusiveRange) "<InclusiveRange ${r.start}...${r.end} step ${r.step}>"

# === Syntactic sugar ============================

doc Boolean negation for non-boolean values. Converts to boolean first.
doc %RET - Bool
F not(x) { guard (x is Bool) == false; x.Bool().not() }

doc Inequality operator
doc %EX - 1 !=2  # true, same as not(1==2)
F !=(a,b) not(a==b)

doc Non-sameness operator
doc %EX - h1 = {"a": 1}
doc %EX - h2 = {"a": 1}
doc %EX - h1 !== h2  # true, same as not(h1===h2)
doc %EX - h1 == h2   # true
F !==(a,b) not(a===b)

TEST 1 != 2
TEST (1 != 1) == false

TEST 1 !== 2
TEST (1 !== 1) == false


doc "not in" operator. Exactly same as "not(a in b)"
doc %EX - 10 not in [1,2]  # true
doc %EX - 1  not in [1,2]  # false
F 'not in'(a,b) not(a in b)

TEST (1 not in [1,2,3]) == false
TEST 10 not in [1,2,3]

doc "is not" operator. Exactly same as "not(a is b)".
doc %EX - 1    is not Null  # true
doc %EX - null is not Null  # false
F 'is not'(a,b) not(a is b)

TEST 1 is not Null
TEST (null is not Null) == false


doc Exactly same as "element in container". It's just more convenient in specific cases.
doc %EX - [1,2,3].has(2)  # true
doc %EX - [[1,2,3], [1,20,30], [100,200,300]].filter(X.has(1))  # [ [1,2,3], [1,20,30] ]
doc %RET - Bool
F has(container, element) element in container

TEST [1,2,3].has(1)
TEST [1,2,3].has(10).not()


doc Defines collector { ... collect(...) ... } behaviour for arrays
doc a - Initial array
doc body - The body after collector keyword and possible initial value, wrapped in a function
doc body - "collector THIS_CODE" or "collector/my_init THIS_CODE"
doc %RET - Constructed array
doc %EX - items = collector {
doc %EX -   collect(10)
doc %EX -   for(i;2) collect(i)
doc %EX -   collect(20)
doc %EX - }
doc %EX - echo(items)  # Outputs: [10,0,1,20]
doc %EX -
doc %EX - # Or start with few items:
doc %EX - items = collector/[100,200] {
doc %EX -   collect(10)
doc %EX -   for(i;2) collect(i)
doc %EX -   collect(20)
doc %EX - }
doc %EX - echo(items)  # Outputs: [100,200,10,0,1,20]
F collector(a:Arr, body:Fun) {
	body(F(elt) a.push(elt))
	a
}

doc Defines collector { ... collect(...) ... } behaviour for hashes
doc h - Initial hash
doc body - The body after collector keyword and initial value, wrapped in a function
doc body - "collector/{'my': 'hash'} THIS_CODE"
doc %RET - Constructed array
doc %EX - arr = [{"Name": "n1", "Value": "v1"},{"Name": "n2", "Value": "v2"}]
doc %EX - my_hash = collector/{}
doc %EX - 	arr.each(F(elt) collect(elt.Name, elt.Value))
doc %EX - echo(my_hash)  # Outputs: {n1=v1, n2=v2}
F collector(h:Hash, body:Fun) {
	body(F(k, v) h[k] = v)
	h
}

doc Defines collector { ... collect(...) ... } behaviour for integers (summarizes collected items).
doc n - Initial number
doc body - The body after collector keyword and initial value, wrapped in a function
doc body - "collector/100 THIS_CODE"
doc %RET - Constructed array
doc %EX - collector/0 { (1...10).each(collect) }  # 55
F collector(n:Int, body:Fun) {
	body(F(incr) n=n+incr)
	n
}

doc Comparison to null
doc %RET - false
F ==(a:Null, b) false

doc Comparison to null
doc %RET - false
F ==(a, b:Null) false

doc Comparison to null
doc %RET - true
F ==(a:Null, b:Null) true

doc Run cleanup after successful execution of body or exception in body
doc body - Main code to execute
doc cleanup - Cleanup code to execute
doc TODO: make sure cleanup() is not run twice in case of exception in cleanup() itself
doc %EX - finally(
doc %EX -   { while entry = c_readdir(d) { ... } },
doc %EX -   { ... c_closedir(d) ...}
doc %EX - )
doc %RET - Whatever body call returns
F finally(body:Fun, cleanup:Fun) {
	try {
		ret = body()
		cleanup()
		ret
	} catch(e) {
		cleanup()
		throw e
	}
}

TEST a=0; {1/1}.finally({a=10}) == 1 and a == 10
TEST a=0; (try finally() with {1/0} with {a=10} catch(e:DivisionByZero) "OK") == "OK" and a == 10

# --- Hash ---

doc Get hash key.
doc %EX - h = {"a": 1}
doc %EX - h.a  # 1, Same as h["a"]
F .(h:Hash, attr:Str) h[attr]

doc Set hash key.
doc %EX - h = {"a": 1}
doc %EX - h.a = 2  # 2, Same as h["a"] = 2
doc %RET - v
F .=(h:Hash, attr:Str, v) h[attr] = v

doc Get hash key or null if it does not exist
doc %EX - h = {"a": 1}
doc %EX - h.get("a")  # 1
doc %EX - h.get("b")  # null
F get(h:Hash, k) get(h, k, null)

doc Convert hash values to integers where possible
doc %RET - New Hash
doc %EX - %{k 7 kk "a"}["k"] is Str      # true
doc %EX - %{k 7 kk "a"}.n()              # {'k': 7, 'kk': 'a'}
doc %EX - %{k 7 kk "a"}.n()["k"] is Int  # true
F n(h:Hash) h.mapv({Int(A) tor A})

TEST %{k 7 kk "a"}.n() == {'k': 7, 'kk': 'a'}

# --- Arr ---
doc Return array made of given attribute of each element of given array
doc %EX - [{"x": 1}, {"x": 2}].x  # [1, 2]
doc %RET - Arr
F .(a:Arr, attr:Str) a.map((.)(X, attr))

TEST [{"x": 1}, {"x": 2}].x == [1, 2]

doc Concatenate strings
doc %EX - "ab" + "cd"  # "abcd"
doc %RET - New Str
F +(s1:Str, s2:Str) "${s1}${s2}"

TEST "ab" + "cd" == "abcd"

# === Array ======================================


doc Checks whether element x is in array arr
doc x - Needle
doc arr - Haystack
doc %EX -  1 in [1,2,3]  # true
doc %EX - 10 in [1,2,3]  # false
doc %RET - Bool
F in(x, arr:Arr) {
	l = arr.len()
	for(i;l) arr[i] == x returns true
	false
}

# Tested by has() tests

doc Arrays equality test
doc True if arrays are of the same length and all elements are equal (==)
doc %RET - Bool
F ==(a:Arr, b:Arr) {
	l = a.len()
	l != b.len() returns false
	for(i;l) a[i] != b[i] returns false
	true
}

TEST [1, 2] == [1, 2]
TEST [1, 3] != [1, 2]
TEST [1] != [1, 2]


doc Check whether there is any element in arr that satisfies the given predicate.
doc TODO: Make it work on anything with each() method
doc arr - Haystack
doc predicate - Test function
doc args - Additional arguments for calling the predicate.
doc %EX - [1,2,10].any(F(elt) elt > 5)   # true
doc %EX - [1,2,10].any(F(elt) elt > 15)  # false
doc %RET - Bool
F any(arr:Arr, predicate) {
	p = Pred(predicate)
	l = arr.len()
	for(i;l)
		p(arr[i]) returns true
	false
}

TEST [1,2,10].any(F(elt) elt > 5)
TEST [1,2,3].any(F(elt) elt > 5).not()

doc Check whether all elements in arr satisfy the given predicate
doc TODO: Make it work on anything with each() method
doc arr - Array to check
doc predicate - Test function
doc args - Additional arguments for calling the predicate.
doc %RET - Bool
doc %EX - [1,2,3].all(X<10)   # true
doc %EX - [1,2,10].all(X>5)   # false
F all(arr:Arr, predicate) {
	p = Pred(predicate)
	l = arr.len()
	for(i;l)
		not(p(arr[i])) returns false
	true
}

TEST [1,2,3].all(X<10)
TEST [1,2,10].all(X>5).not()

doc Check that there is no element in arr that satisfies the given predicate. Exactly same as  not(any(arr, predicate)) .
doc TODO: Make it work on anything with each() method
doc %RET - Bool
doc %EX - [0,1,2].none(X>2)  # true
doc %EX - [0,1,2].none(X<2)  # false
F none(arr:Arr, predicate:Fun) not(any(arr, predicate))

TEST [0,1,2].none(X>2)
TEST [0,1,2].none(X<2).not()

TEST [1,2,3].map(X*4) == [4,8,12]

doc Iterates over the elements of arr, passing each in turn to cb along with args: cb(ITEM)
doc cb - Function to be called with values from arr
doc args - Additional arguments for calling cb
doc %RET - arr
doc %EX - s=0
doc %EX - [1,2,3].each(F(i) { global s; s+=i })
doc %EX - echo(s)  # Outputs: 6
F each(arr:Arr, cb:Fun) {
	l = arr.len()
	for(i;l) cb(arr[i])
	arr
}

# Tested by flatten() tests

# TODO: map_idx_val, each_idx_val for other types
doc Iterates over the elements of arr, passing each in turn to cb along with index and args: cb(INDEX, ITEM)
doc %RET - arr
doc %EX - [10,20,30].each_idx_val(F(idx, val) echo("Element #$idx equals to $val"))
F each_idx_val(arr:Arr, cb:Fun) {
	l = arr.len()
	for(i;l) cb(i, arr[i])
	arr
}

doc Map an Arr to an Arr (array) of values using mapper
doc mapper is called as mapper(INDEX, ITEM)
doc %RET - New Arr
doc %EX - echo("Array items: " + [10,20,30].map_idx_val(F(idx, val) "[$idx]=$val").join(", "))
doc %EX - # Outputs: Array items: [0]=10, [1]=20, [2]=30
F map_idx_val(arr:Arr, mapper:Fun) {
	l = arr.len()
	collector
		for(i;l) collect(mapper(i, arr[i]))
}

TEST r=[]; ["a", "b"].each_idx_val(F(idx, val) r.push([idx, val])); r == [[0, "a"], [1, "b"]]


# TODO: make it work with anything that has each() method
doc Process each N elements of an Array at a time.
doc Throws InvalidArgument if number of items in arr is not divisible by n.
doc cb is called as cb(eltI, ..., eltJ) where I is multiple of n and J is I+n-1
doc arr - Items to iterate in chunks of n
doc n - Number of items in chunk
doc cb - Function to be called with values from arr
doc args - Additional arguments for calling cb
doc %RET - arr
doc %EX - [1,2,3,4].each(2, F(a, b) echo("$a - $b"))  # Outputs: "1 - 2" and on the next line "3 - 4"
F each(arr:Arr, n:Int, cb:Fun) {
	arr.len() % n != 0 throws InvalidArgument("Can not iterate elements in groups of $n of array of size ${arr.len()}")
	chunks = arr.len() / n
	for(chunk_number; chunks) {
		cb(*arr[chunk_number*n..chunk_number*n+n])
	}
	arr
}

# Tested by map(arr:Arr, n:Int, cb:Fun)


doc Map each N elements of an Array at a time.
doc mapper is called as cb(eltI, ..., eltJ) where I is multiple of n and J is I+n-1
doc Throws InvalidArgument if number of items in arr is not divisible by n.
doc mapper is called as mapper(eltI, ..., eltJ) where I is multiple of n and J is I+n-1
doc arr - Items to iterate in chunks of n
doc n - Number of items in chunk
doc mapper - Function to be called with values from arr
doc args - Additional arguments for calling mapper
doc %RET - Arr
doc %EX - [1,2,3,4].map(2, F(a,b) "$a=$b").join("&")  # Outputs: 1=2&3=4
F map(arr:Arr, n:Int, mapper:Fun) collector arr.each(n, F(*a) collect(mapper(*a)))

# Tested by ~(s:Str, r:RegExp)

doc Filter out all occurencies of specific value
doc arr - items to filter
doc without_elt - The value to filter out
doc %RET - Arr
doc %EX - [1,2,3,2].without(2)  # [1,3]
F without(arr:Arr, without_elt) arr.filter(X != without_elt)

TEST [1,2,3,2].without(2) == [1,3]

doc Filter out all values in a that are also in b
doc %RET - Arr
doc %EX - [1,2,3] - [5,6,1]  # [2,3]
F -(a:Arr, b:Arr) {
	h = if b.len() > 10 {
		b.Hash({true})
	} else {
		b
	}
	a.filter(X not in h)
}

TEST [1,2,3] - [5,6,1] == [2,3]
TEST [1,2,3] - [5,6,1,1,1,1,1,1,1,1,1,1,1,2] == [3]

doc Count number of items that satisfy the predicate.
doc TODO: Make it work on anything with each() method.
doc arr - Items to look at
doc predicate - Test function
doc args - Additional arguments for the predicate
doc %RET - Int
doc %EX - [1,2,3,11,12].count(X>10)  # 2
F count(arr:Arr, predicate) {
	p = Pred(predicate)
	collector/0
		arr.each(F(elt) {
			if p(elt)
				collect(1)
		})
}

TEST [1,2,3,11,12].count(X>10) == 2

doc Count all true values.
doc arr - Items to look at
doc %RET - Int
doc %EX - [0,1,2,null,false].count()  # 2 (Only 1 and 2 count as true values)
F count(arr:Arr) count(arr, identity)

TEST [0,1,2,null,false].count() == 2

doc Flatten one level.
doc arr - Array of arrays
doc %RET - Arr
doc %EX - [[1], [2,3]].flatten()  # [1,2,3]
F flatten(arr:Arr) {
	guard arr.all(Arr)
	collector
		arr.each(F(subarr) {
			subarr % collect
		})
}

TEST [[1], [2,3]].flatten() == [1,2,3]

doc Return unique values.
doc Warning: uses Hash so comparison is not using == but a built-in hash keys comparison.
doc %RET - Arr
doc %EX - [1,2,2,3,4,4].uniq()  # [1,2,3,4]
F uniq(arr:Arr) arr.Hash({true}).keys()

TEST [1,2,2,3,4,4].uniq() == [1,2,3,4]

doc DEPRECATED. Find first true value
F first(arr:Arr) first(arr, identity)

TEST [null, false, 10, 20].first() == 10

doc Find index of first value that satisfies the predicate.
doc TODO: Make it work on anything with each() method.
doc arr - Items to look at
doc predicate - Test function
doc args - Additional arguments for the predicate
doc %RET - Int or null
doc %EX - [1,2,11,3,4].index(X>10)  # 2
F index(arr:Arr, predicate) {
	p = Pred(predicate)
	l = arr.len()
	for(i;l)
		p(arr[i]) returns i
	null
}

doc Find all indexes of values that satisfy the predicate
doc TODO: Make it work on anything with each() method
doc arr - Items to look at
doc predicate - Test function
doc args - Additional arguments for the predicate
doc %RET - Arr of Int
doc %EX - [1,5,1,10].indexes(X>2)  # [1,3]
F indexes(arr:Arr, predicate) {
	p = Pred(predicate)
	l = arr.len()
	l.filter({ p(arr[A]) })
}

TEST [1,5,1,10].indexes(X>2) == [1,3]

doc Find first value that satisfies the predicate.
doc TODO: Make it work on anything with each() method
doc arr - Items to look at
doc predicate - Test function
doc args - Additional arguments for the predicate
doc %RET - Int or null
doc %EX - [1,2,11,3,4].first(X>10)  # 11
F first(arr:Arr, predicate:Fun) {
	i = arr.index(predicate)
	i is Null returns null
	arr[i]
}

TEST [5,10,15].first(X>7) == 10
TEST [5,10,15].first(X>20) == null

doc Make new array which is a reversed given array
doc %RET - Arr
doc %EX - [1,2,3].reverse()  # [3,2,1]
F reverse(arr:Arr) {
	l = arr.len()
	l.map({ arr[l-A-1] })
}

TEST [1,2,3].reverse() == [3,2,1]

doc Calculate sum of the elements
doc %EX - [1,2,3].sum()  # 6
F sum(something) something.reduce(0, (+))

doc Prepend one element to the given array
doc %RET - Modified arr
doc %EX - x=[1,2]
doc %EX - x.unshift(3)
doc %EX - echo(x)  # Outputs: [3,1,2]
F unshift(arr:Arr, elt) {
	arr[0..0] = [elt]
	arr
}

TEST x=[1,2]; x.unshift(3); x == [3, 1, 2]

doc EXPERIMENTAL! Do not use!
doc a - Array of arrays to join
doc sep - Separator elements
doc %EX - [[1,2], [3,4]].join([10,20])  # [1,2,10,20,3,4]
F join(a:Arr, sep:Arr) {
	guard a.all(Arr)
	collector
		a.each_idx_val(F(idx, subarr) {
			subarr % collect
			if idx < a.len() - 1 {
				sep % collect
			}
		})
}

# --- Conversions ---

doc Make Arr from Hash. Each key/value pair becomes two-items array:
doc %RET - Arr of form [[k1, v1], [k2, v2], ...]
doc %EX - Arr({'x': 7, 'y': 8})  # [['x', 7], ['y', 8]]
F Arr(h:Hash)
	h.map(F(*pair) pair)

TEST Arr({'x': 7, 'y': 8}) == [['x', 7], ['y', 8]]

doc Make Arr from Arr. A no-op.
doc %RET - arr
F Arr(arr:Arr) arr

doc Make new array which aggregates elements from each of the args arrays
doc n-th element of the new array is an array that contains n-th element of each of the given arrays
doc If some of the arrays in args are shorter than others, they will be logically padded with null
doc %EX - zip([1,2,3], [4,5,6])  # [[1,4], [2,5], [3,6]]
doc %EX - zip([1,2,3], [4,5])    # [[1,4], [2,5], [3,null]]
doc %RET - Arr of form [[arg[0][0], arg[1][0], ... arg[i][0]], [arg[0][1], arg[1][1], ... arg[i][1]], ...]
F zip(*args) {
	arrays = args.map(Arr)
	max_len = arrays / len \ max
	max_len.map({ arrays.map(X.get(A, null)) })
}

TEST zip([1,2,3], [4,5,6]) == [[1,4], [2,5], [3,6]]
TEST zip([1,2,3], [4,5,6], [7,8,9,10]) == [[1,4,7], [2,5,8], [3,6,9], [null, null, 10]]

doc Convert range to an array
doc %EX - Arr(1..3)   # [1,2]
doc %EX - Arr(1...3)  # [1,2,3]
F Arr(r:Range) r / identity

TEST Arr(1..3) == [1,2]
TEST Arr(1...3) == [1,2,3]


# --- Access elements ---

doc Get array element by index from the end
doc idx - Negative index
doc %EX - [10,20,30][-1]  # 30
F '[]'(arr:Arr, idx:Int) {
	guard idx < 0
	i = arr.len() + idx
	i < 0 throws IndexNotFound("[](Arr, Int): Index $idx is illegal for array of size ${arr.len()}", arr, idx)
	arr[i]
}

doc Get array elements at specified indexes. Indexes specified by ExclusiveRange.
doc r - ExclusiveRange with negatve .end
doc %EX - [10,20,30,40][1..-1]  # [20,30]
doc %RET - Arr
F '[]'(arr:Arr, r:ExclusiveRange) {
	guard r.end is Int and r.end < 0
	r.end < 0 - arr.len() throws IndexNotFound("[](Arr, ExclusiveRange): Index ${r.end} (range end) is illegal for array of size ${arr.len()}", arr, idx)
	arr[r.start..arr.len() + r.end]
}

TEST [10,20,30,40][1..-1] == [20,30]


doc Get array elements at specified indexes.
doc arr - Array to pick items from
doc indexes - Indexes of items to pick
doc %EX - [10,20,30,40][[0,3]]  # [10, 40]
doc %RET - Arr
F '[]'(arr:Arr, indexes:Arr) indexes.map(arr[X])

TEST [10,20,30,40][[0,3]] == [10, 40]

doc Truncate an array if necessary so it would have maximum l elements.
doc a - Array to (possibly) truncate.
doc l - Maximum elements
doc %RET - Either a or new Arr of length l
doc %EX - [10,11,12].limit(2)   # [10,11]
doc %EX - [10,11,12].limit(10)  # [10,11,12]
F limit(a:Arr, l:Int) {
	a.len() <= l returns a
	a[0..l]
}

TEST [10,11,12].limit(10) == [10,11,12]
TEST [10,11,12].limit(2) == [10,11]

# --- Misc ---

{
	F() {
		global min, max
		F most(arr:Arr, f:Fun) {
			guard arr
			ret = arr[0]
			arr.each(F(elt) if f(elt, ret) { ret = elt })
			ret
		}

		F most_by_cb(arr:Arr, f:Fun, cb:Fun) {
			guard arr
			ret = arr[0]
			ret_cb = cb(ret)
			arr.each(F(elt) {
				elt_cb = cb(elt)
				if f(elt_cb, ret_cb) {
					ret = elt
					ret_cb = elt_cb
				}
			})
			ret_cb
		}

		doc TODO
		F min(arr:Arr) most(arr, (<))
		doc TODO
		F max(arr:Arr) most(arr, (>))

		# EXPERIMENTAL!
		doc TODO
		F min(arr:Arr, cb:Fun) most_by_cb(arr, (<), cb)
		doc TODO
		F max(arr:Arr, cb:Fun) most_by_cb(arr, (>), cb)
	}()
}

doc Repeat all elements in arr n times
doc arr - Elements to repeat
doc n - Number of times to repeat the elements
doc %RET - Arr
doc %EX - [10,20] * 2  # [10,20,10,20]
F *(arr:Arr, n:Int)
	collector
		for(i;n)
			arr % collect

TEST [10,20] * 2 == [10,20,10,20]

doc Cartesian product
doc %RET - Arr of Arr[2]
doc %EX - [10,20] * [30,40]  # [[10, 30], [10, 40], [20, 30], [20, 40]]
F *(a:Arr, b:Arr)
	collector
		a.each(F(elt_a) {
			b.each(F(elt_b) {
				collect([elt_a, elt_b])
			})
		})

TEST [10,20] * [30,40] == [[10, 30], [10, 40], [20, 30], [20, 40]]

doc Echo non-string. Converts x to string first, using Str()
doc x - Anything but Str
doc %RET - null
doc %EX - echo(1)
F echo(x) {
	guard x is not Str
	echo(Str(x))
}

# Built-in join() can only handle Str elements
doc Join non-strings. Converts a elements to string first, then uses built-in join().
doc Warning - behaviour subject to change!
doc a - Array to join
doc s - Delimiter
doc %RET - Str
doc %EX - [1,2,3].join("::")  # The string 1::2::3
F join(a:Arr, s:Str) {
	guard a.any(X is not Str)
	a.map(Str).join(s)
	# TODO: maybe a.map({if A is Str then A else Str(A)}).join(s)
	# TODO: consider making Str(x) == x
}

doc Used for command line arguments such as ['--vpc-id', my_vpc_id()].nuke_null()
doc If my_vpc_id() is null the whole array is not needed
doc %EX - [1,2].nuke_null()  # [1,2]
doc %EX - [1,null].nuke_null()  # []
F nuke_null(a:Arr) {
	a.any(Null) returns []
	a
}

TEST [1,2].nuke_null() == [1,2]
TEST [1,null].nuke_null() == []

# Can be more efficent I guess
doc Merge sorted arrays.
doc lte - Less-then-or-equal function to use for comparison of items in a and b
doc %RET - Arr
doc %EX - merge_sorted([1,3,10], [0, 7], (<=))  # [0, 1, 3, 7, 10]
F merge_sorted(a:Arr, b:Arr, lte:Fun) {
	ai = Iter(a)
	bi = Iter(b)
	collector
		while ai or bi {
			i = econd {
				not(ai) bi
				not(bi) ai
				lte(ai.peek(), bi.peek()) ai
				true bi
			}
			collect(i.next())
		}
}

TEST merge_sorted([1,3,10], [0, 7], (<=)) == [0, 1, 3, 7, 10]

# Current implemetation: https://en.wikipedia.org/wiki/Merge_sort
# TODO: replacte with Timsort https://en.wikipedia.org/wiki/Timsort
doc Sort an array.
doc lte - Less-then-or-equal function to use for comparison of the items in a
doc %RET - Arr
doc %EX - sort([0,5,3,-1], (<=))  # [-1, 0, 3, 5]
F sort(a:Arr, lte:Fun=(<=)) {
	# XXX: Not copied!
	a.len() <= 1 returns a
	mid = a.len() / 2
	l = a[0..mid]
	r = a[mid..null]
	merge_sorted(sort(l, lte), sort(r, lte), lte)
}

TEST sort([0,5,3,-1], (<=)) == [-1, 0, 3, 5]

doc Sort an array based on attribute value
doc lte - Less-then-or-equal function to use for comparison of the items' attributes
doc %RET - Arr
doc %EX - [{'x': 1}, {'x': 5}, {'x': 3}].sort('x')  # [{'x': 1}, {'x': 3}, {'x': 5}]
F sort(a:Arr, attr:Str, lte:Fun=(<=)) a.sort(F(a, b) lte((.)(a, attr), (.)(b, attr)))

TEST [{'x': 1}, {'x': 5}, {'x': 3}].sort('x') == [{'x': 1}, {'x': 3}, {'x': 5}]

doc TODO. Is it used even?
F split(a:Arr, delim) {
	ret = []
	cur = []
	a.each(F(elt) {
		if elt == delim {
			ret.push(cur)
			cur = []
		} else {
			cur.push(elt)
		}
	})
	ret.push(cur)
	ret
}


doc Compare arrays. Warning: Hash is used so internal Hash keys comparison is used, not ==
doc %EX - cmp([1,2], [2,3])  # {'add': [3], 'remove': [1]}
F cmp(a:Arr, b:Arr) {
	ah = Hash(a, {true})
	bh = Hash(b, {true})
	{
		'add': bh.filter(X not in ah).keys()
		'remove': ah.filter(X not in bh).keys()
	}
}

TEST cmp([1,2], [2,3]) == {'add': [3], 'remove': [1]}

doc Like cmp() but compare arrays without using Hash so that '==' is used for comparison
doc and not internal '===' for Hash keys. Much slower than cmp().
F compare(a:Arr, b:Arr) {
	{
		'add': b.filter(X not in a)
		'remove': a.filter(X not in b)
	}
}

doc Convert an array to NGS code that would produce the array when executed. Not fully functional yet.
doc %RET - Str
F code(a:Arr) "[" + a.map(code).join(', ') + "]"

# === Hash =======================================


# --- Comparisons ---

doc Compare two Hashes. Hashes must have same keys with same values in same order to return true.
doc %RET - Bool
F ==(a:Hash, b:Hash) Arr(a) == Arr(b)

doc Compare hashes
doc %EX - diff = cmp(current_tags, target_tags)
doc %EX - if (tags = stdlib_aws_tags(diff.add + diff.change)) {
doc %EX - 	r.run('update_tags/add', %(aws ec2 create-tags --resources ${r.id()} --tags $*tags))
doc %EX - }
doc %EX - if (tags = diff.remove / "Key=$X") {
doc %EX - 	r.run('update_tags/remove', %(aws ec2 delete-tags --resources ${r.id()} --tags $*tags))
doc %EX - }
F cmp(a:Hash, b:Hash) {
	{
		'add': b.filter(X not in a)
		'change': b.filter(X in a).filter(F(k, v) a[k] != v)
		'remove': a.filter(X not in b).keys()
	}
}

TEST cmp({"a": 1, "b":2}, {"b": 3, "d": 4}) == {"add":{"d":4}, "change":{"b":3}, "remove":["a"]}


# --- Functional ---

# Make it built in for speed?
doc Iterate a Hash.
doc h - Hash to iterate
doc cb - Function to call with successive keys and values
doc args - Additional arguments for calling cb
doc %RET - h
doc %EX - {"a": 1, "b": 2}.each(F(k, v) echo("$k=$v"))  # Outputs: "a=1" and on the next line "b=2"
F each(h:Hash, cb:Fun) {
	h.keys().each(F(k) cb(k, h[k]))
	h
}

doc Iterate a Hash.
doc h - Hash to iterate
doc cb - Function to call with successive indexes, keys and values
doc args - Additional arguments for calling cb
doc %RET - h
doc %EX - {"a": 1, "b": 2}.each_idx_key_val(F(idx, k, v) echo("[$idx] $k=$v"))
doc %EX - # Outputs: "[0] a=1" and on the next line "[1] b=2"
F each_idx_key_val(h:Hash, cb:Fun) {
	h.keys().each_idx_val(F(idx, k) cb(idx, k, h[k]))
	h
}

doc Map a Hash
doc h - Hash with source keys and values
doc mapper - Function to be called with keys and values from h
doc args - Additional arguments for calling mapper
doc %RET - Arr
doc %EX - {'a': 1, 'b': 2}.map(F(k, v) "${k}-$v")  # ['a-1', 'b-2']
F map(h:Hash, mapper:Fun)
	collector
		h % { collect(mapper(A, B)) }

TEST {'a': 1, 'b': 2}.map(F(k, v) "${k}-$v") == ['a-1', 'b-2']

doc Map Hash keys. Build new Hash with same values as in h but keys mapped by mapper.
doc h - Source hash
doc mapper - Function to be called with keys
doc args - Additional arguments for calling mapper
doc %RET - Hash
doc %EX - mapk({"a": 1}, F(k) k+"z")  # {"az": 1}
F mapk(h:Hash, mapper:Fun)
	collector/{}
		h % { collect(mapper(A), B) }

TEST mapk({"a": 1}, X+"z") == {"az": 1}

doc Map Hash values. Build new Hash with same keys as in h but values mapped by mapper.
doc h - Source hash
doc mapper - Function to be called with values
doc args - Additional arguments for calling mapper
doc %RET - Hash
doc %EX - LEN = 3
doc %EX - lines_ = fetch("/usr/share/dict/words").lines()
doc %EX - long_lines = lines_.filter({A.len()>LEN})
doc %EX - prefix_to_lines = long_lines.group(F(line) line[0..LEN])  # {"pfx1": ["pfx1a", "pfx1b", ...], "pfx2": ["pfx2a", "pfx2b", ...], ...}
doc %EX - prefix_to_count = prefix_to_lines.mapv(len)  # {"pfx1": 30, "pfx2": 35, ...}
doc %EX - top = prefix_to_count.Arr().sort(F(a, b) b[1] <= a[1]).Hash()
doc %EX - top .= limit(10)
doc %EX - echo(top)  # Outputs: {con=1219, dis=1001, pro=808, pre=607, com=600, int=543, tra=498, ove=431, per=422, imp=421}
F mapv(h:Hash, mapper:Fun)
	collector/{}
		h % { collect(A, mapper(B)) }

TEST mapv({"a": 1}, X+1) == {"a": 2}


doc Map Hash keys and values. Build new Hash with keys and values mapped by mapper.
doc h - Source hash
doc mapper - Function to be called with keys and values
doc args - Additional arguments for calling mapper
doc %EX - mapkv({"a": 1}, {[A+"zz", B+10]})  # {"azz": 11}
F mapkv(h:Hash, mapper:Fun)
	collector/{}
		h % { collect(*mapper(A, B)) }

TEST mapkv({"a": 1}, {[A+"zz", B+10]}) == {"azz": 11}

doc Filter hash. Build new hash with kev-value pairs selected by predicate.
doc h - Source hash
doc predicate - Test function to be called with one key and one value at a time
doc args - Additional arguments for calling the predicate
doc %EX - {'a': 1, 'b': 2}.filter(F(k, v) k == 'a')  # {'a': 1}
F filter(h:Hash, predicate) {
	p = Pred(predicate)
	collector/{}
		h.each(F(k, v) {
			if p(k, v)
				collect(k, v)
		})
}

TEST {'a': 1, 'b': 2}.filter(F(k, v) k == 'a') == {'a': 1}

doc Check whether all key-value pairs in Hash satisfy the given predicate
doc h - Hash to check
doc predicate - Test function to be called with one key and one value at a time
doc args - Additional arguments for calling the predicate.
doc %RET - Bool
doc %EX - {"x": 1, "y": 2}.all(F(k, v) v is Int)  # true
F all(h:Hash, predicate) {
	p = Pred(predicate)
	arr = h.keys()
	l = arr.len()
	for(i;l)
		not(p(arr[i], h[arr[i]])) returns false
	true
}

TEST {"x": 1, "y": 2}.all(F(k, v) v is Int)


doc Count number of key-value pairs in Hash that satisfy the predicate.
doc h - Hash to check
doc predicate - Test function to be called with one key and one value at a time
doc args - Additional arguments for calling the predicate.
doc %RET - Int
doc %EX - {'a': 1, 'b': 2, 'c': 11}.count(F(k, v) v>10)  # 1
F count(h:Hash, predicate) {
	p = Pred(predicate)
	collector/0
		h.each(F(k, v) {
			if p(k, v)
				collect(1)
		})
}

TEST {'a': 1, 'b': 2, 'c': 11}.count(F(k, v) v>10) == 1

# --- Conversions ---

doc Create a Hash from Arr of Arr[2]
doc arr - Array of Arrays. Each one of the sub-arrays must have exactly two elements.
doc %RET - Hash
doc %EX - Hash([['a', 1], ['c', 3]])  # {'a': 1, 'c': 3}
F Hash(arr:Arr)
	collector/{}
		arr.each(F(pair) {
			collect(*pair)
		})

TEST Hash([['a', 1], ['c', 3]]) == {'a': 1, 'c': 3}

doc TODO. Not sure it's used anywhere. Maybe remove?
F Hash(arr:Arr, attr:Str)
	collector/{}
		arr.each(F(v) collect(v[attr], v))

TEST Hash([{'x': 1}, {'x': 2}], 'x') == {1: {'x': 1}, 2: {'x': 2}}

doc Create a Hash from keys in arr using cb for values calculation
doc arr - Keys of the hash to build
doc cb - Function to be called with one key at a time. Should calculate a value for the given key.
doc %RET - Hash
doc %EX - Hash([1,2], F(x) x*2)  # {1: 2, 2: 4}
F Hash(arr:Arr, cb:Fun)
	collector/{}
		arr.each(F(elt) collect(elt, cb(elt)))

TEST Hash([1,2], F(x) x*2) == {1: 2, 2: 4}


doc Create a Hash from keys in "keys" and corresponding values in "values"
doc keys - Keys for the new Hash
doc values - Values for the new Hash
doc %RET - Hash
doc %EX - Hash(["a", "b", "c"], [1,2,3])  # {"a": 1, "b": 2, "c": 3}
F Hash(keys:Arr, values:Arr)
	collector/{}
		keys.len().each(F(idx) collect(keys[idx], values[idx]))

TEST Hash(["a", "b", "c"], [1,2,3]) == {"a": 1, "b": 2, "c": 3}

doc Create Hash from Arr of something that has key and value attribute
doc arr - Arr with all the keys and values
doc key_attr - Name of the attribute holding the keys of newly created Hash
doc val_attr - Name of the attribute holding the values of newly created Hash
doc %EX - Hash([{"Name": "n1", "Value": "v1"},{"Name": "n2", "Value": "v2"}], "Name", "Value")  # {"n1": "v1", "n2": "v2"}
F Hash(arr:Arr, key_attr:Str, val_attr:Str)
	collector/{}
		arr.each(F(elt) collect((.)(elt, key_attr), (.)(elt, val_attr)))

TEST Hash([{"Name": "n1", "Value": "v1"},{"Name": "n2", "Value": "v2"}], "Name", "Value") == {"n1": "v1", "n2": "v2"}


# --- Misc ---

doc Filter out specific key
doc h - Source hash
doc without_k - The key to filter out
doc %RET - Hash
doc %EX - {'a': 1, 'b': 2, 'c': 3}.without('a')  # {'b': 2, 'c': 3}
F without(h:Hash, without_k) h.filter(X != without_k)

TEST {'a': 1, 'b': 2, 'c': 3}.without('a') == {'b': 2, 'c': 3}

doc Filter out specific key-value pair
doc h - Source hash
doc without_k - The key to filter out
doc without_v - The value to filter out
doc %RET - Hash
doc %EX - {'a': 1, 'b': 2, 'c': 3}.without('a', 1).without('b', 22)  # {'b': 2, 'c': 3}
F without(h:Hash, without_k, without_v)
	h.filter(F(k, v) not((k == without_k) and (v == without_v)))

TEST {'a': 1, 'b': 2, 'c': 3}.without('a', 1).without('b', 22) == {'b': 2, 'c': 3}

doc Add Hashes. Builds new hash with key-value pairs from both a and b. If same key is present in both a and b, the value from b is used.
doc %RET - Hash
doc %EX - {'a': 1, 'b': 2, 'c': 3} + {'b': 20, 'd': 40}  # {'a': 1, 'b': 20, 'c': 3, 'd': 40}
F +(a:Hash, b:Hash) {
	{**a, **b}
}


TEST {'a': 1, 'b': 2, 'c': 3} + {'b': 20, 'd': 40} == {'a': 1, 'b': 20, 'c': 3, 'd': 40}

doc Build array of Str where each resulting string is of the form "KEY=VALUE"
doc h - Source hash
doc %RET - Arr of Str
doc %EX - {'a': 1, 'b': 2}.Strs()  # ['a=1', 'b=2']
F Strs(h:Hash) h / "$X=$Y"

TEST {'a': 1, 'b': 2}.Strs() == ['a=1', 'b=2']

doc Truncate a Hash if necessary so it would have maximum l key-value pairs.
doc h - Source hash
doc l - Maximum elements
doc %RET - Hash
doc %EX - {"a": 1, "b": 2}.limit(1)  # {"a": 1}
F limit(h:Hash, l:Int) h.keys().limit(l).Hash(h[X])

TEST {"a": 1, "b": 2}.limit(3) == {"a": 1, "b": 2}
TEST {"a": 1, "b": 2}.limit(1) == {"a": 1}

doc TODO.
doc Group items from a by key returned by cb
doc args - Additional arguments for calling cb
doc %RET - Hash
F group(a:Arr, cb:Fun) {
	ret = {}
	a.each(F(elt) {
		k = cb(elt)
		ret.dflt(k, []).push(elt)
	})
	ret
}

doc Convert a Hash to NGS code that would produce the given Hash when executed. Not fully functional yet.
doc %RET - Str
F code(h:Hash) {
	'{' + h.map(F(k, v) "${k.code()}: ${v.code()}").join(', ') + '}'
}

doc Set an key in a Hash if it's not already set
doc %EX - Myhash.dflt(k, []).push(elt)
doc %RET - Hash value, the already-existed or new.
F dflt(h:Hash, k, v) {
	if k not in h {
		h[k] = v
	}
	h[k]
}

# === Box ========================================

{
	doc Parent type of FullBox and EmptyBox
	type Box
		doc Represents available value
		doc val - The value
		type FullBox(Box)
		doc Represents no value
		type EmptyBox(Box)
}

doc Do not use directly!
doc Helper constructor that throws InvalidArgument when
doc FullBox is created with zero or more than one argument.
F init(b:FullBox, *args) throw InvalidArgument("FullBox must be initialized with exactly one value")

doc FullBox constructor. Saves val into .val
doc %EX - # Simplified code from the_one() method:
doc %EX - ret = EmptyBox()
doc %EX - something.each(F(elt) {
doc %EX - 	if predicate(elt) {
doc %EX - 		ret throws TheOneFail("the_one() had more than one match")
doc %EX - 		ret = FullBox(elt)
doc %EX - 	}
doc %EX - })
doc %EX - not(ret) throws TheOneFail("the_one() had no matches")
doc %EX - ret.val # Has the value
F init(b:FullBox, val) b.val = val

doc Always true
F Bool(fb:FullBox) true

doc Always false
F Bool(eb:EmptyBox) false

doc Zero for FullBox and one for EmptyBox
F to_exit_code(b:Box) b.Bool().to_exit_code()

# === Integer ====================================

# --- Functional ---

doc Iterate from zero up to but not including n
doc cb - Function to call with current number
doc args - Additional arguments for calling cb
doc %EX - 10.each(echo)  # Outputs numbers from 0 to 9 inclusive, one on each line
doc %RET - n
F each(n:Int, cb:Fun) {
	for(i;n) cb(i)
	n
}

TEST 3.map(identity) == [0, 1, 2]
TEST 3.map(X*3) == [0, 3, 6]

doc Call cb n times without arguments.
doc cb - Function to call
doc args - Arguments for calling cb
doc %EX - r=0; 5.times(F() r=r+2);  # r is now 10
F times(n:Int, cb:Fun) {
	for(i;n) cb()
	n
}

TEST r=0; 5.times(F() r=r+2); r==10

doc Convert base-10 string to Int.
doc Throws InvalidArgument if the number in s is not well-formatted.
doc %RET - Int
doc %EX - Int(" 100 ")  # 100
F Int(s:Str) Int(s, 10)

TEST Int(" 100 ") == 100
TEST try Int(" XX ") catch(e:InvalidArgument) true
TEST Int(" XX ", 36) == 1221

doc Convert Bool to int.
doc %RET - Int
doc %EX - true.Int()   # 1
doc %EX - false.Int()  # 0
F Int(b:Bool) if b 1 0

TEST true.Int() == 1
TEST false.Int() == 0

doc Convert an Int to NGS code that would produce the integer when executed. Not fully functional yet.
doc %RET - Str
F code(n:Int) Str(n)


# === Str ========================================


# --- Constructors ---

# TODO: escaping?
doc TODO
F Str(s:Str) "'$s'"

doc Convert Null to string
doc %RET - the string "null"
F Str(n:Null) "null"
F Str(b:Bool) if b "true" "false"

doc Convert Arr to string
doc %RET - Str
F Str(a:Arr) "[${a.map(Str).join(',')}]"

doc Convert Hash to string
doc %RET - Str
F Str(h:Hash) "{" + h.map(F(k, v) "${k}=${v}").join(", ") + "}"

# --- Functional ---

doc Iterates over all string characters (currently bytes).
doc TODO: example.
doc cb - Function to be called with each character from s
doc args - Additional arguments for calling cb
doc %RET - s
F each(s:Str, cb:Fun) {
	s.len().each(F(idx) {
		cb(s[idx])
	})
	s
}

# --- Sugar ---

doc Find substring in a string.
doc haystack - The string to search in
doc needle - The string to find
doc %RET - Int or null
doc %EX - pos("abc", "cd")     # null
doc %EX - pos("abcdef", "cd")  # 2
F pos(haystack:Str, needle:Str) pos(haystack, needle, 0)

TEST pos("abc", "cd") == null
TEST pos("abcdef", "cd") == 2

TEST pos("a:b:c", ":") == 1
TEST pos("a:b:c", ":", 2) == 3

doc Determin if needle substring occurs at least once in haystack
doc haystack - The string to search in
doc needle - The string to find
doc %RET - Bool
doc %EX - "bc" in "abcd"
doc %EX - "x" not in "abcd"
F in(needle:Str, haystack:Str) pos(haystack, needle) is not Null

TEST "bc" in "abcd"
TEST "x" not in "abcd"

doc Get given character (currently byte) of the string
doc s - Original string
doc i - Index of the character to return
doc %EX - "abc"[0]  # "a"
F '[]'(s:Str, i:Int) s[i..i+1]

TEST ("abc"[0] == "a") and ("abc"[2] == "c")
TEST try "abc"[3] == "x" catch(e:InvalidArgument) true

doc Get given character (currently byte) of the string.
doc TODO: Document InvalidArgument exception.
doc s - Original string
doc i - Negative index of the character to return
doc %EX - "abc"[-1]  # "c"
F '[]'(s:Str, i:Int) {
	guard i < 0
	i < 0-s.len() throws InvalidArgument("Negative index into string is (abs) larger than the string")
	s[s.len()+i]
}

TEST ("abc"[-1] == "c") and ("abc"[-3] == "a")
TEST try "abc"[-4] == "x" catch(e:InvalidArgument) true

doc Get a substring. Indexes in s are specified by ExclusiveRange.
doc s - Original string
doc r - ExclusiveRange with negatve .end
doc %EX - "(Look ma, no parens)"[1..-1]  # "Look ma, no parens"
doc %RET - Str
F '[]'(s:Str, r:ExclusiveRange) {
	guard r.end is Int and r.end < 0
	r.end < 0 - s.len() throws InvalidArgument("Negative index (range end) into string is (abs) larger than the string")
	s[r.start..s.len() + r.end]
}

# --- Misc utilities ---

doc Split string by substring
doc %RET - Arr of Str
doc %EX - ":a:bc:d:".split(":")   # ["", "a", "bc", "d", ""]
doc %EX - ":a:bc:d:".split("bc")  # [":a:", ":d:"]
F split(s:Str, delim:Str) {
	l = delim.len()
	guard l > 0
	start = 0
	collector {
		while (p = pos(s, delim, start)) is not Null {
			collect(s[start..p])
			start = p + l
		}
		collect(s[start..null])
	}
}

TEST ":a:bc:d:".split(":") == ["", "a", "bc", "d", ""]
TEST ":a:bc:d:".split("bc") == [":a:", ":d:"]

doc Repeat string n times
doc %EX - "abc" * 3  # "abcabcabc"
F *(s:Str, n:Int) ([s]*n).join('')

# Tested with Str(Str,Int)

doc Convert anything to Str of a given width
F Str(x, target_width:Int) x.Str().Str(target_width)

doc Pad a string to given width with spaces
doc target_width - Positive pads on right, negative pads on left
doc %EX - Str("x", 3)  # 'x  '
doc %EX - Str("x",-3)  # '  x'
F Str(s:Str, target_width:Int) {
	l = s.len()
	pad_on_left = target_width < 0
	if pad_on_left {
		target_width = 0 - target_width
	}

	l >= target_width returns s

	padding = ' ' * (target_width - l)
	if pad_on_left {
		padding + s
	} else {
		s + padding
	}
}

# Not sure about this, might be confusing behaviour
doc Convert a number to a string and pad it
doc target_width - Positive pads on left, negative pads on right
doc %EX - Str(10,  4)  # '  10'
doc %EX - Str(10, -4)  # '10  '
F Str(n:Int, target_width:Int) n.Str().Str(0-target_width)

TEST Str(10,  4) == '  10'
TEST Str(10, -4) == '10  '
TEST Str("x", 3) == 'x  '
TEST Str("x",-3) == '  x'

doc Check whether a string starts with another string
doc %RET - Bool
doc %EX - "abcd".starts_with("ab")  # true
doc %EX - "ab".starts_with("abcd")  # false
F starts_with(haystack:Str, needle:Str) {
	needle.len() > haystack.len() returns false
	haystack[0..needle.len()] == needle
}

TEST "abcd".starts_with("ab")
TEST "ab".starts_with("abcd") == false

doc Check whether a string ends with another string
doc %RET - Bool
doc %EX - "abcd".ends_with("cd")  # true
doc %EX - "ab".ends_with("cdab")  # false
F ends_with(haystack:Str, needle:Str) {
	needle.len() > haystack.len() returns false
	l = haystack.len()
	haystack[l - needle.len()..l] == needle
}

TEST "abcd".ends_with("cd")
TEST "ab".ends_with("cdab") == false


doc Case-insensitive LessThan or Equal comparison for strings
doc %RET - Bool
F lte(a:Str, b:Str)
	c_strcasecmp(a, b) <= 0

doc Case sensitive LessThan or Equal comparison for strings
doc %RET - Bool
F '<='(a:Str, b:Str)
	c_strcmp(a, b) <= 0

doc Split s to strings using end-of-line separators.
doc UNIX and Windows line endings supported (Windows - not tested yet).
doc Warning: Max OS <= 9 line separation of CR (\r) is not supported
doc %EX - "xx\nyy".lines()  # %[xx yy]
F lines(s:Str) {
	# Note: Max OS <= 9 line separation of CR (\r) is not supported
	not(s) returns []
	s -= MaybeSfx('\n')
	s.split('\n').map(X - MaybeSfx('\r'))
}

doc Split s to strings using end-of-line separators and call cb for each one of the lines.
doc TODO: More efficient implementation, which would not have temporary array of all lines.
doc cb - Function to be called with each line
doc args - Additional arguments for calling cb
F lines(s:Str, cb:Fun) {
	lines(s).each(cb)
}

TEST "xx\nyy".lines() == %[xx yy]

doc Prepend each line in a with s
doc %EX - "a " + ["1", "2"]  # ["a 1", "a 2"]
F +(s:Str, a:Arr) {
	guard a.all(Str)
	a.map(s+X)
}
TEST "a " + ["1", "2"] == ["a 1", "a 2"]

doc Append s to each line in a
doc %EX - ["1", "2"] + " a"  # ["1 a", "2 a"]
F +(a:Arr, s:Str) {
	guard a.all(Str)
	a.map(X+s)
}
TEST ["1", "2"] + " a" == ["1 a", "2 a"]

doc Truncate a string if necessary so it would have maximum n characters (currently bytes).
doc s - The string to (possibly) truncate.
doc n - Maximum characters
doc marker - The truncation marker
doc %RET - Either s or new Str of length n
doc %EX - "abc".limit(5, "...")     # "abc"
doc %EX - "abcdef".limit(5, "...")  # "ab..."
doc %EX - "abcdef".limit(2)         # "ab"
F limit(s:Str, n:Int, marker:Str='') {
	s.len() <= n returns s
	if marker {
		lim = n - len(marker)
		s[0..lim] + marker
	} else {
		s[0..n]
	}
}

TEST "abc".limit(5, "...") == "abc"
TEST "abcdef".limit(5, "...") == "ab..."
TEST "abcdef".limit(2) == "ab"

doc Get character (currently byte) code. Throws InvalidArgument if s is not of length 1.
doc %EX - ord("A")  # 65 on my machine
F ord(s:Str) {
	s.len() != 1 throws InvalidArgument("ord() argument must be of length 1 exactly").set('given', s)
	ord(s, 0)
}

doc EXPERIMENTAL. For use with AWS Anchors.
F ~(a:Str, b:Str) a==b

doc Convert a Str to NGS code that would produce the string when executed. Not fully functional yet.
doc BUG: Does not do escaping.
doc %RET - Str
F code(s:Str) {
	# XXX TODO: escaping
	"'${s}'"
}


# === Logging and status reporting (WIP) =========

# TODO: timestamps

# TODO: allow control by facility and severity
#       and maybe source component or file.

# Not sure such flexibility is needed (NGS_ERR_FD)
stdlib_error_fd = ENV.NGS_ERR_FD.Int() tor 2

doc Log to standard output. Later log output will be treated specially by the shell. It will have suitable representation in the UI. Use log() when it's semantically a log.
F log(s:Str) {
	echo("[LOG] $s")
}

doc Debug to standard error.
doc "DEBUG" environment variable must be non-empty string to activate. Otherwise nothing is outputted.
doc TODO: Not output thread ID if there is only one thread.
doc TODO: Timestamps?
F debug(s:Str) {
	# TODO: Use RingBuffer when debug is off and
	#       show last N debug messages on uncaught exception
	if try ENV['DEBUG'] {
		echo(stdlib_error_fd, "[DEBUG ${c_getpid()} ${c_pthread_self().id()}] $s")
	}
}

doc Write error message to standard error.
F error(s:Str) {
	echo(stdlib_error_fd, "[ERROR ] $s")
}

doc Send status to standard error. Later status output will be treated specially by the shell. It will have suitable representation in the UI. Use status() when it's semantically a status - a task that's being done.
F status(s:Str) {
	echo(stdlib_error_fd, "(status) $s")
}

doc Write messages in a to standard error and exit
F die(a:Arr, exit_code=1) {
	guard a.all(Str)
	a % echo(stdlib_error_fd, X)
	c_exit(exit_code)
}

doc Write message in s to standard error and exit
F die(s:Str, exit_code=1) {
	echo(stdlib_error_fd, s)
	c_exit(exit_code)
}

# === Path =======================================

{
	type Path
	type SocketFile(Path)  # S_IFSOCK
	type Symlink(Path)     # S_IFLNK
	type File(Path)        # S_IFREG
	type BlockDevice(Path) # S_IFBLK
	type Dir(Path)         # S_IFDIR
	type CharDevice(Path)  # S_IFCHR
	type FifoFile(Path)    # S_IFIFO

	type StatFail(CException)

}

# TODO: reconsider naming
STDLIB_FILE_TYPE = {
	C_S_IFSOCK: SocketFile
	C_S_IFLNK:  Symlink
	C_S_IFREG:  File
	C_S_IFBLK:  BlockDevice
	C_S_IFDIR:  Dir
	C_S_IFCHR:  CharDevice
	C_S_IFIFO:  FifoFile
}

doc Issue stat() system call. Throws StatFail if the call fails.
doc %RET - Stat
doc %EX - stat("/tmp")  # <Stat st_dev=51714 st_ino=25 st_mode=17407 ...>
F stat(pathname:Str) {
	ret = c_stat(pathname)
	ret is Null throws StatFail("Failed to c_stat()").set('pathname', pathname)
	ret
}

doc Issue stat() system call. Throws StatFail if the call fails.
doc %RET - Stat
F stat(p:Path) super(p.path)

doc Issue lstat() system call. Throws StatFail if the call fails.
doc %RET - Stat
doc %EX - stat("/usr/bin/cal").st_mode   # 33261
doc %EX - lstat("/usr/bin/cal").st_mode  # 41471
F lstat(pathname:Str) {
	ret = c_lstat(pathname)
	ret is Null throws StatFail("Failed to c_lstat()").set('pathname', pathname)
	ret
}

doc Issue lstat() system call. Throws StatFail if the call fails.
doc %RET - Stat
F lstat(p:Path) super(p.path)

# TODO: better name
doc EXPERIMENTAL, do not use outside of stdlib!
doc Instanciates Path sub-type, depending on what p is
F specific(p:Path) {
	s = lstat(p)
	file_type = s.st_mode.band(C_S_IFMT)
	STDLIB_FILE_TYPE[file_type](p.path).set('stat', s)
}

doc Path constructor
doc s - path
doc subtype - Return Path sub-type, depending on lstat() call
doc %RET - Path or sub-type of Path
doc %EX - Path(".")  # <Path path=.>
doc %EX - Path(".", true)  # <Dir path=.>
doc %EX - ``find tmp/v8``.map(Path(X, true)).map(typeof).name.Stats()  # <Stats: {Dir=287, File=9220}>
F Path(s:Str, subtype=false) {
	ret = Path()
	ret.path = s
	if subtype {
		ret.specific()
	} else {
		ret
	}
}

doc Path constructor
doc s - path
F init(p:Path, s:Str) {
	p.path = s
}

doc Path constructor. Duplicates other Path.
doc other - Path to duplicate
F init(p:Path, other:Path) {
	p.path = other.path
}

doc Checks whether the path is accessible using access(2) and F_OK.
doc %RET - Bool
F Bool(p:Path) c_access(p.path, C_F_OK) == 0

TEST Path('/').Bool()
TEST Path('/no-such-file').Bool() == false
TEST Path('/', true) is Dir

# TODO: better exceptions (use correct type, not string, maybe use errno)
# TODO: support platforms with non ":" path delimiter?
doc Finds given binary and returns it's full path.
doc Throws ExecutableNotFound if the binary was not found.
doc Search strategy: "/" in the name of the binary means that given executable_name is a path so it's returned as-is (wrapped in Path).
doc If PATH environment variable exists, the given directories are searched.
doc If PATH is not set built-in value for PATH is used to search: /usr/local/bin:/usr/bin:/bin:/sbin:/usr/sbin
doc %RET - Path
doc %EX - find_in_path("ls")  # <Path path=/bin/ls>
F find_in_path(executable_name:Str) {
	debug("[find_in_path] got ${executable_name}")
	if "/" in executable_name {
		debug("[find_in_path] leaving unprocessed ${executable_name}")
		return Path(executable_name)
	}
	path = ENV.get('PATH', '/usr/local/bin:/usr/bin:/bin:/sbin:/usr/sbin').split(':')
	debug('[find_in_path] will search')
	ret = path.map(F(dir) Path(dir / executable_name)).first()
	debug("[find_in_path] ${executable_name} found at ${ret}")
	ret is Null throws ExecutableNotFound().set('path', path).set('name', executable_name)
	ret
}

doc String representation of a Path (or it's sub-type)
doc %RET - Str
doc %EX - find_in_path("ls").Str()  # The string: <Path path=/bin/ls>
F Str(p:Path) "<${p.typeof().name} path=${p.path}>"

STDLIB_PATH_SEP = '/'

doc Concatenate two path parts using STDLIB_PATH_SEP (currently "/") but should be platform-specific later.
doc %RET - Str
doc %EX - mydir="tmp"
doc %EX - mydir / "myfile"  # "tmp/myfile"
F /(a:Str, b:Str) "$a$STDLIB_PATH_SEP$b"

doc Concatenate two path parts using STDLIB_PATH_SEP (currently "/") but should be platform-specific later.
doc %RET - Str
doc %EX - mydir="tmp/"
doc %EX - mydir / "myfile"  # "tmp/myfile"
F /(a:Str, b:Str) {
	guard a and (a[-1] == STDLIB_PATH_SEP)
	"$a$b"
}

doc Concatenate two path parts using STDLIB_PATH_SEP (currently "/") but should be platform-specific later.
doc %RET - Str
doc %EX - mydir="./"
doc %EX - mydir / "myfile"  # "myfile"
F /(a:Str, b:Str) {
	guard (a == '.') or (a == './')
	b
}

doc Concatenate two Path-s using /(a:Str, b:Str)
doc %RET - Path
doc %EX - Path("tmp") / Path("v8")  # <Path path=tmp/v8>
F /(a:Path, b:Path) Path(a.path / b.path)

{ type DirFail(CException) }

doc List directory contents. Warning: "." and ".." are included.
doc Throws DirFail when directory can not be listed.
doc subtype - Select type of returned items: true for Path sub-type, false for Path type
doc %RET - Arr of Path or it's sub-type
doc %EX - dir("tmp/v8", true).filter(File)  # [ ..., <File path=tmp/v8/README.md fd=null>, <File path=tmp/v8/LICENSE.valgrind fd=null>, ... ]
doc %EX - dir("tmp/v8", true).filter(Dir)   # [ ..., <Dir path=tmp/v8/tools>, <Dir path=tmp/v8/infra>, ... ]
F dir(dirname:Str, subtype=false) collector dir(dirname, collect, subtype)

# TODO: recurse ?
# TODO: filter out "." and ".." ?
doc List directory contents and call cb with Path() of each found item. Warning: "." and ".." are included.
doc %RET - unspecified at this time, do not count on it
doc %EX - 's=Stats(); dir("tmp/v8", {s.push(A.typeof().name)}, true); s  # <Stats: {File=23, Dir=16}>'
F dir(dirname:Str, cb:Fun, subtype=false) {
	d = c_opendir(dirname)
	d is Null throws DirFail('Failed to list directory contents').set('dirname', dirname)
	finally()
		body => {
			while entry = c_readdir(d) {
				cb(Path(dirname / entry.d_name, subtype=subtype))
			}
		}
		cleanup => {
			r = c_closedir(d)
			r != 0 throws DirFail('Failed to close directory after listing').set('dirname', dirname)
		}
}

# XXX: might not be correct on all platforms
TEST dir("/").path.has("/var")
TEST dir("/").all({A.typeof().name == 'Path'})
TEST dir("/", subtype=true).all({ (A is Path) and (A.typeof().name != 'Path') })

doc Work in progress, do not use!
F glob(pattern:Str, start_dir='.') {


}

# === Commands and processes (WIP) ===============

# TODO: better exceptions (use correct type, not string, maybe use errno)
F dup2(oldfd:Int, newfd:Int) {
	while true {
		status = c_dup2(oldfd, newfd)
		status != -1 returns newfd
		get_c_errno() != C_EINTR throws "dup2() failed"
	}
}

# TODO: Use some thread-local copy of the environment?
#       This would allow simple handling of modifications
#       for exec'ed processes.

# TODO: detect and process errors, throw exception(s)
# TODO: better exceptions (use correct type, not string, maybe use errno)
doc Read all data from a file referenced by file descriptor.
doc fd - File descriptor to read from
doc %RET - Str
doc %EX - read(0)  # All data from stdin
F read(fd:Int) {
	ret = []
	while true {
		debug("[read] will read from fd $fd")
		result = c_read(fd, 4096)
		debug("[read] read from fd $fd : <<${result}>>")
		result[0] == 0 returns ret.join('')
		if result[0] > 0 {
			ret.push(result[1])
		} else {
			e = get_c_errno()
			if e != C_EINTR {
				debug("[read] read from fd $fd failed, errno $e")
				throw "[read] failed to c_read()"
			}
		}
	}
}

doc Write data to a file referenced by file descriptor.
doc WARNING: Incomplete implementation.
doc TODO: handle errors, throw exceptions.
doc TODO: handle possible EINTR.
doc fd - File descriptor to write to
doc %RET - unspecified at this time, do not count on it
F write(s:Str, fd:Int) fd.c_write(s)

{ type TtyCheckFail(CException) }

doc Check whether given fd represents a TTY. Uses ISATTY(3).
doc Throws TtyCheckFail.
doc %RET - Bool
F isatty(fd:Int) {
	ret = c_isatty(fd)
	errno = get_c_errno()

	ret == 1 returns true
	ret != 0 throws TtyCheckFail("c_isatty($fd) - unknown response code $ret").set('fd', fd).set('isatty_returned', ret)

	errno in [C_EINVAL, C_ENOTTY] returns false
	throw TtyCheckFail("c_isatty() - failed").set('fd', fd)
}

# --- Pipe ---

# http://www.microhowto.info/howto/capture_the_output_of_a_child_process_in_c.html

{
	type Pipe
	type PipeCreateFail(CException)
}

stdlib_fork_lock = Lock()

# TODO: better exceptions (use correct type, not string, maybe use errno)
doc Pipe constructor. Create UNIX pipe using PIPE(2). Throws PipeCreateFail if pipe can not be created.
doc %EX - p = Pipe()
F init(pipe:Pipe) {
	result = c_pipe()
	# result: [result_code, read_end, write_end]
	result[0] != 0 throws PipeCreateFail("Failed to create Pipe")
	pipe.read_fd = result[1]
	pipe.write_fd = result[2]
	debug("[Pipe] created pipe with read_fd=${pipe.read_fd} and write_fd=${pipe.write_fd}")
}

STDLIB_CHILD_TO_PARENT_PIPE_DIR = 1
STDLIB_PARENT_TO_CHILD_PIPE_DIR = 2

doc Pipe constructor. Create UNIX pipe using PIPE(2). Throws PipeCreateFail if pipe can not be created.
doc direction - One of: STDLIB_CHILD_TO_PARENT_PIPE_DIR or STDLIB_PARENT_TO_CHILD_PIPE_DIR
doc %EX - p = Pipe(STDLIB_PARENT_TO_CHILD_PIPE_DIR)
F init(pipe:Pipe, direction:Int) {
	init(pipe)
	init(args())
}

F Str(p:Pipe) "<Pipe read_fd=${p.read_fd} write_fd=${p.write_fd}>"

# TODO: exception on fail, maybe close() wrapper for c_close()

doc Close writing end of the Pipe
F close_writing_end(p:Pipe) p.write_fd.c_close()

doc Close reading end of the Pipe
F close_reading_end(p:Pipe) p.read_fd.c_close()

doc Write to Pipe. TODO: document if it throws.
doc %RET - unspecified at this time, do not count on it
F write(p:Pipe, s:Str) p.write_fd.c_write(s)

doc Read from Pipe. TODO: document if it throws.
doc %RET - read data
doc %EX - data = read(myipe)
F read(p:Pipe) p.read_fd.read()

doc DUP2(2) writing file descriptor
F dup2_writing_end(p:Pipe, newfd:Int) dup2(p.write_fd, newfd)

doc DUP2(2) reading file descriptor
F dup2_reading_end(p:Pipe, newfd:Int) dup2(p.read_fd, newfd)

doc Get child process end file descriptor of Pipe. It's the writing end for Pipe(STDLIB_CHILD_TO_PARENT_PIPE_DIR).
F child_fd(p:Pipe) {
	guard p.direction == STDLIB_CHILD_TO_PARENT_PIPE_DIR
	p.write_fd
}

doc Get child process end file descriptor of Pipe. It's the reading end for Pipe(STDLIB_PARENT_TO_CHILD_PIPE_DIR).
F child_fd(p:Pipe) {
	guard p.direction == STDLIB_PARENT_TO_CHILD_PIPE_DIR
	p.read_fd
}

doc Get parent process end file descriptor of Pipe. It's the reading end for Pipe(STDLIB_CHILD_TO_PARENT_PIPE_DIR).
F parent_fd(p:Pipe) {
	guard p.direction == STDLIB_CHILD_TO_PARENT_PIPE_DIR
	p.read_fd
}

doc Get parent process end file descriptor of Pipe. It's the writing end for Pipe(STDLIB_PARENT_TO_CHILD_PIPE_DIR).
F parent_fd(p:Pipe) {
	guard p.direction == STDLIB_PARENT_TO_CHILD_PIPE_DIR
	p.write_fd
}

# --- File ---

{ type FileIOFail }

F init(fail:FileIOFail, name:Str, errno:Int, message:Str) init(args())

F init(f:File, path:Str) {
	f.fd = null
	init(args())
}

F init(f:File, fd:Int) {
	f.fd = fd
	init(args())
}

doc String representation of File
doc %EX - open(File("tmp/v8/LICENSE"), "r").Str().echo()  # Output: <File path=tmp/v8/LICENSE fd=4>
F Str(f:File) "<File path=${f.path} fd=${f.fd}>"

TEST File('xy').Str() == '<File path=xy fd=null>'

F open(f:File, flags:Str) {
	f.fd is not Null throws FileIOFail(null, "open(f:File, flags:Str): file is already open")
	fd = c_open(f.path, flags)
	fd <= 0 throws FileIOFail(f.path, get_c_errno(), "Failed to open the file ${f.path}")
	f.fd = fd
	f
}

F basename(s:Str) $(basename $s).Str() - Sfx('\n')

# TODO: something more efficient than reading all of it. Some kind of streaming.
F lines(f:File, cb:Fun) {
	finally()
		body => {
			f.open('r')
			f.fd.read().lines(cb)
		}
		cleanup => {
			f.close()
		}
}

F close(f:File) {
	f.fd is Null throws InvalidArgument("File is not open. close() expects an open file").set('file', f)
	ret = c_close(f.fd)
	ret < 0 throws FileIOFail(f.path, get_c_errno(), "Failed to close the file $f")
}

doc fetch() and parse() the given file
F read(filename:Str) {
	data = fetch(filename)
	parse(data, {'filename': filename})
}

doc read standard input and parse() it
F read() read(0).parse({'source': 'stdin'})

# --- Redir ---

F Str(r:Redir) "<Redirect ${r.fd} ${r.marker} ${r.datum}>"

# --- Process ---

{
	type Process
	type ExecutableNotFound(Exception)
}

F '.'(p:Process, attr:Str) {
	guard attr == 'stdout'
	p.outputs[1]
}

F '.='(p:Process, attr:Str, v) {
	guard attr == 'stdout'
	p.outputs[1] = v
}

F '.'(p:Process, attr:Str) {
	guard attr == 'stderr'
	p.outputs[2]
}

F '.='(p:Process, attr:Str, v) {
	guard attr == 'stderr'
	p.outputs[2] = v
}

F finished_ok(p:Process) p.exit_code == 0

F finished_ok(p:Process) {
	guard p.executable.path == '/bin/false'
	p.exit_code == 1
}

F finished_ok(p:Process) {
	guard p.executable.path in ['/usr/bin/test', '/bin/fuser', '/bin/ping']
	p.exit_code in [0, 1]
}

F init(p:Process, c:Command) {
	p.command = c
	p.executable = null
	p.pid = null
	p.exit_code = null
	p.exit_signal = null
	p.pipes = {}
	p.outputs = {1:null, 2:null}
	p.reading_threads = []
	p.writing_threads = []
	# p.lock = Lock()
}

F Bool(p:Process) {
	p.wait()
	p.exit_code == 0
}

# TODO: better exceptions (use correct type, not string)
F wait(p:Process) {

	p.pid is Null throws "Can not wait() on Process without PID"

	p.exit_code is Int returns p

	debug("[wait] joining reading and writing threads")
	p.reading_threads.join()
	p.reading_threads = []
	p.writing_threads.join()
	p.writing_threads = []

	debug("[wait] will waitpid(${p.pid})")
	w = c_waitpid(p.pid)
	debug("[wait] waitpid(${p.pid}) -> ${w}")
	p.exit_code = C_WEXITSTATUS(w[1])
	p.exit_signal = C_WTERMSIG(w[1])
	not(finished_ok(p)) throws ProcessFail(p)
	p
}

F to_exit_code(p:Process) p.wait().exit_code

F Str(p:Process) p.wait().stdout

# --- $() ---

# TODO: better exceptions (use correct type, not string)
# TODO: c_waitpid() - handle signals
# TODO: split to methods for easy behaviour modification
# TODO: capture stderr
# TODO: provide additional communication channel on additional fd?
# TODO: handle built-in commands: do not execve,
# INFO: bash - redir.c
doc Execute an external command and wait for it to finish.
doc c - Command type instance, typically constructed by NGS when parsing the contents of $(...) .
doc %EX - if $(test -f /myfile) { ... }
doc %EX - # or
doc %EX - p = $(node main.js serve &)
doc %EX - YOUR_TESTS_OF_NODE_SERVER_HERE
doc %EX - p.kill()
doc %RET - Process
F '$()'(c:Command) {

	# Special case: $($cmd)
	if (c.argv.len() == 1) and (c.argv[0] is Command) {
		c = c.argv[0]
	}

	debug_pfx = '[stdlib $()]'
	debug("$debug_pfx Parsed command: ${c.argv}")

	process = Process(c)
	try {
		process.executable = find_in_path(c.argv[0])
	} catch(nf:ExecutableNotFound) {
		throw ProcessFail(process).set('cause', nf).set('message', 'Executable not found')
	}
	# child fd -> Pipe
	pipes = process.pipes
	if 'top_level' not in c.options {
		pipes[1] = Pipe(STDLIB_CHILD_TO_PARENT_PIPE_DIR)
	}

	c.redirects.each(F(r:Redir) {
		# WIP. Continue here: support functions and Pipe objects
	})

	pipes % { process.outputs[A] = null }

	pid = c_fork()

	pid == -1 throws "Failed to fork()"

	debug("$debug_pfx PID after fork: $pid")

	child_fds = pipes / child_fd(Y)
	parent_fds = pipes / parent_fd(Y)

	if pid == 0 {
		# === Child ===
		# TODO: -------------------- test - start --------------------

		for(i=3;i<100;i+=1) {
			if i not in child_fds {
				i.c_close()
			}
		}
		# TODO: -------------------- test - end --------------------
		parent_fds % c_close
		pipes % F(fd, pipe) {
			dup2(pipe.child_fd(), fd)
		}
		# Redirections (WIP) - start
		c.redirects.each(F(r:Redir) {

			F fd_or_dflt(fd:Int, dflt) fd
			F fd_or_dflt(fd:Null, dflt) dflt

			eswitch r.marker {
				'<'  { flags = 'r'; target_fd = fd_or_dflt(r.fd, 0); }
				'>'  { flags = 'w'; target_fd = fd_or_dflt(r.fd, 1); }
				'>>' { flags = 'a'; target_fd = fd_or_dflt(r.fd, 1); }
			}

			# TODO: Maybe support File or some other datum types later?
			if r.datum is Str {
				f = File(r.datum).open(flags)
				ok = c_dup2(f.fd, target_fd)
				# TODO: better exception
				ok < 0 throws "Failed to dup2(${f.fd}, ${target_fd}). Errno ${get_c_errno()}"
			}
		})
		# Redirections (WIP) - end
		result = c_execve(process.executable.path, c.argv, ENV.Strs())
		# TODO: propagate this error to parent, don't know how yet
		throw "$debug_pfx failed to execve()"
	}

	if pid > 0 {
		# === Parent ===
		process.pid = pid
		child_fds % c_close
		debug("$debug_pfx reading all output of the child process")
		# XXX: maybe make it chunk based with c_poll() and single thread
		pipes_to_read_from = pipes ? F(fd, pipe) { pipe.direction == STDLIB_CHILD_TO_PARENT_PIPE_DIR }
		# TODO: some error handling inside these threads and after joining them
		process.reading_threads = pipes_to_read_from.map(F(fd, pipe) {
			Thread({
				process.outputs[fd] = pipe.read()
				pipe.close_reading_end()
				debug("$debug_pfx read all output of the child process for descriptor $fd, closing reading/parent end")
			})
		})
		# echo("R ${c.reading_threads}")
		if '&' not in c.options {
			process.wait()
		}
	}

	# TODO: pid < 0 => throw exception with errno

	process
}

TEST $(true).Bool()
TEST $(false).Bool() == false
TEST "$(/bin/echo -n abc)" == 'abc'

F ``(c:Command) ('$()')(c).Str()

F ````(c:Command) {
	p = ('$()')(c)
	p.stdout.parse({'process': p})
}

F kill(pid:Int, sig:Int=SIGNALS.TERM) {
	ret = c_kill(pid, sig)
	ret == -1 throws KillFail("Failed to kill pid $pid with signal $sig")
	ret != 0 throws Error("c_kill() did not return 0 or -1")
	ret
}

# XXX: Must join reader/writer threads!
F kill(p:Process, sig:Int=SIGNALS.TERM) {
	p.pid is Null throws InvalidArgument("Can't kill() a process that does not have a pid")
	kill(p.pid, sig)
}

F parse(s:Str) parse(s, {})

F parse(s:Str, hints:Hash) s

F parse(s:Str, hints:Hash) {
	ret = FullBox(decode_json(s)) tor EmptyBox()
	guard ret
	ret.val
}

# WIP
F unparse(data, hints:Hash) {
	1
}

doc Returns c, wihout any processing. Convenient way to pass ready-to-run Command as an argument
doc %EX - F run_when_needed(c:Command) { ... $(c) ... }
doc %EX - ...
doc %EX - run_when_needed(%(ls >/tmp/my_ls))
F '%()'(c:Command) c

F lines(p:Process) {
	p.wait()
	p.stdout.lines()
}

# TODO: ability to handle running process & it's streaming stdout
F lines(p:Process, cb:Fun) {
	p.wait()
	p.stdout.lines(cb)
}

# === Parse aws output ===========================
# TODO: move to separate auto-loaded file maybe?

F stdlib_aws_straighten_tags(a:Arr) a.each(stdlib_aws_straighten_tags)

F stdlib_aws_straighten_tags(h:Hash) {
	if 'Tags' in h {
		h.Tags = Hash(h.Tags.Key, h.Tags.Value)
	}
}

# For the case of { "SecurityGroups": [ "sg-XXXXXXXX" ] }
# Which is output of aws elb apply-security-groups-to-load-balancer --load-balancer-name SOMETHING -beame-servers-authz --security-groups sg-XXXXXXXX
F stdlib_aws_straighten_tags(s:Str) null

TEST instances = [{"Tags": [{"Key": "k", "Value": "v"},{"Key": "k2", "Value": "v2"}]}]; stdlib_aws_straighten_tags(instances); instances.Tags == [{"k": "v", "k2": "v2"}]
TEST instances = ["something"]; stdlib_aws_straighten_tags(instances); instances == ["something"]

F parse(s:Str, hints:Hash) {
	guard try hints['process'].command.argv[0] == 'aws'

	# aws ec2 create-tags/delete-tags
	s == '' returns null

	data = decode_json(s)
	guard data is Hash

	# Use the only top-level key that has array as it's value
	# Thanks goes to Elastic Beanstalk which complicates this,
	# all other APIs seem to return only one top-level key.
	# ( aws elasticbeanstalk describe-configuration-options )

	top_level_vals = data.values().filter(Arr)

	guard top_level_vals.len() == 1

	data = top_level_vals[0]

	# Anyone cares about Reservations? Certainly it's not the common case so...
	if data.all('ReservationId' in X) {
		data = data.Instances.flatten()
	}
	data.stdlib_aws_straighten_tags()
}

F parse(s:Str, hints:Hash) {
	guard try hints['process'].command.argv[0] == 'find'
	argv = hints['process'].command.argv
	guard '-printf' not in argv
	zero_sep = '-print0' in argv
	if zero_sep then s.split(chr(0))[0..-1] else s.lines()
}

# === config =====================================

STDLIB_CONFIG = {}

F config(k:Str) {
	# TODO: think, organize
	#       what about structured data? JSON?
	# TODO: read from config files
	# TODO: read from command line switches
	debug("[config] getting key '$k'")
	v = try ENV["NGS_$k"]
	if v {
		debug("[config] Value config for key '$k' found in the environment variable 'NGS_${k}': '$v'")
		return parse(v)
	}
	v = try STDLIB_CONFIG[k]
	if v is not Null {
		debug("Value config for key '$k' found in STDLIB_CONFIG: $v")
		return v
	}
	v
}

F config(s:Str, x) {
	debug("Configuring ${s}=${x}")
	STDLIB_CONFIG[s] = x
}

# === Match, Pfx, Sfx ============================

{
	doc Sucessfull or unsucessfull match result
	type Match

		doc Sucessfull match result
		doc matches - Succsessfull matches
		type MatchY(Match)

		doc Unsucessfull match result
		type MatchN(Match)

	type MatchFail(Exception)

	type SubSeq
		doc Prefix subsequence of a sequence
		type Pfx(SubSeq)
			type MaybePfx(Pfx)
			type MustPfx(Pfx)
		doc Suffix subsequence of a sequence
		type Sfx(SubSeq)
			type MaybeSfx(Sfx)
			type MustSfx(Sfx)
}

F init(my:MatchY, matches:Arr) init(args())
F Bool(my:MatchY) true
F Bool(my:MatchN) false
F to_exit_code(m:Match) m.Bool().to_exit_code()

F init(mf:MatchFail, msg:Str, container, pattern) init(args())

F init(s:SubSeq, val) s.val = val

# The common case
F Pfx(val) MustPfx(val)
F Sfx(val) MustSfx(val)

F Str(s:SubSeq) "<${s.typeof().name} ${s.val}>"

F -(s:Str, pfx:Pfx) {
	s.starts_with(pfx.val) returns s[pfx.val.len()..null]
	pfx is MustPfx throws MatchFail("Given string '$s' does not start with prefix '$pfx.val'", s, pfx)
	s
}

TEST "abc" - Pfx("a") == "bc"
TEST try "abc" - Pfx("wa") catch(mf:MatchFail) true
TEST "abc" - MaybePfx("wa") == "abc"


F -(s:Str, sfx:Sfx) {
	s.ends_with(sfx.val) returns s[0 .. (s.len() - sfx.val.len())]
	sfx is MustSfx throws MatchFail("Given string '$s' does not end with suffix '$sfx.val'", s, sfx)
	s
}

TEST "abc" - Sfx("c") == "ab"
TEST try "abc" - Sfx("cd") catch(mf:MatchFail) true
TEST "abc" - MaybeSfx("cd") == "abc"

F ~(s:Str, pfx:Pfx) {
	not(s.starts_with(pfx.val)) returns MatchN()
	ret = MatchY([pfx.val])
	ret.before = ''
	ret.after = s[pfx.val.len()..null]
	ret
}

F ~(s:Str, sfx:Sfx) {
	not(s.ends_with(sfx.val)) returns MatchN()
	ret = MatchY([sfx.val])
	ret.before = s[0..(s.len() - sfx.val.len())]
	ret.after = ''
	ret
}

# TODO: make it a low priority method imlementation
F '[]'(my:MatchY, idx:Int) my.matches[idx]

TEST ("abc" ~ /a(.)c/)[1] == 'b'


# === RegExp =====================================

# TODO: better exceptions
F ~(s:Str, r:RegExp, offset:Int=0, options:Int=0) {
	not(options) and not(s) returns MatchN()
	result = c_pcre_exec(r, s, offset, options)
	if result is Int {
		result == C_PCRE_ERROR_NOMATCH returns MatchN()
		result == 0 throws Error("Too many captures. Max 20")
		result < 0 throws Error("RegExp matching error in c_pcre_exec").set('code', result)
		assert(false, "Unexpected integer result from c_pcre_exec")
	}
	assert(result is Arr, "c_pcre_exec must return either integer or an array")
	ret = MatchY(
		result.map(2, F(start_pos, end_pos) {
			if start_pos >= 0
				s[start_pos..end_pos]
			else
				null
		})
	)
	ret.named = r.names.mapv(F(capture_num) try ret.matches[capture_num])
	ret.positions = result.map(2, F(start_pos, end_pos) [start_pos, end_pos])
	ret.whole = ret.matches[0]
	ret.before = s[0..result[0]]
	ret.after = s[result[1]..null]
	ret
}

TEST r=c_pcre_compile("a(.)c", 0); m = "xabcy" ~ r; m.matches == ["abc", "b"] and m.before == 'x' and m.after == 'y' and m.whole == 'abc'
TEST r=c_pcre_compile("a(.)c", 0); m = "xAbcy" ~ r; m is MatchN

PCRE_NEWLINE_TO_OPTIONS = {
	         13: C_PCRE_NEWLINE_CR,
	         10: C_PCRE_NEWLINE_LF,
	13*256 + 10: C_PCRE_NEWLINE_CRLF,
	         -2: C_PCRE_NEWLINE_ANYCRLF,
	         -1: C_PCRE_NEWLINE_ANY,
}

F ~~(s:Str, r:RegExp, collect_unmatched:Bool=false) {
	collector {
		m = (~)(s, r, 0)
		if not(m) {
			if collect_unmatched collect(s)
			return null
		}
		start_offset = m.positions[0][0]
		next_offset = m.positions[0][1]
		if collect_unmatched and start_offset then collect(s[0..start_offset])
		collect(m)
		option_bits = r.options
		utf8 = option_bits.band(C_PCRE_UTF8).Bool()
		option_bits = option_bits.band([C_PCRE_NEWLINE_CR, C_PCRE_NEWLINE_LF, C_PCRE_NEWLINE_CRLF, C_PCRE_NEWLINE_ANY, C_PCRE_NEWLINE_ANYCRLF].reduce(0, bor))
		option_bits = option_bits or PCRE_NEWLINE_TO_OPTIONS.get(PCRE_NEWLINE, 0)
		crlf_is_newline = option_bits in [C_PCRE_NEWLINE_ANY, C_PCRE_NEWLINE_CRLF, C_PCRE_NEWLINE_ANYCRLF]
		while true {
			options = 0
			if start_offset == next_offset {
				next_offset == len(s) breaks
				options = bor(C_PCRE_NOTEMPTY_ATSTART, C_PCRE_ANCHORED)
			}
			m = (~)(s, r, next_offset, options)
			if m {
				if collect_unmatched {
					if next_offset != m.positions[0][0] {
						collect(s[next_offset..m.positions[0][0]])
					}
				}
				start_offset = m.positions[0][0]
				next_offset = m.positions[0][1]
				collect(m)
				continue
			}
			options == 0 breaks
			next_offset += 1
			if (crlf_is_newline) and (try s[next_offset-1..next_offset+1] == '\r\n') {
				next_offset += 1
				continue
			}
			if utf8 {
				while (next_offset < len(s)) and (s[next_offset].ord().band(0xC0) == 0x80) {
					next_offset += 1
				}
				continue
			}
		}
		if collect_unmatched and (next_offset < len(s)) {
			collect(s[next_offset..null])
		}
	}
}

# TODO: test ~~() \r\n skipping
# Crashes on Ubuntu 14.04 clang 3.5.0 (Travis CI)
TEST (try ENV.TRAVIS and ENV.CC == "clang") returns true; ("ab\r\ncd" ~~ /(*CRLF)|./m).whole.filter(len) == ['a', 'b', 'c', 'd']
# Crashes on Ubuntu 14.04 clang 3.5.0 (Travis CI)
TEST (try ENV.TRAVIS and ENV.CC == "clang") returns true; ("ab\r\ncd" ~~ /|./m).whole.filter(len) == ['a', 'b', '\r', 'c', 'd']
# UTF-8 of "" is 209(D1), 143(8F)
# Skip for older library using try ... catch
TEST try ("ab" ~~ /(*UTF)|\\x8F|b/).whole.filter(len) == ['b'] catch(e:RegExpCompileFail) 'not recognized' in e.message

# Last two are for repeated searches
STDLIB_REGEXP_FLAGS = {
	'i': C_PCRE_CASELESS
	'm': C_PCRE_MULTILINE
	's': C_PCRE_DOTALL
	'x': C_PCRE_EXTENDED

	'a': C_PCRE_ANCHORED
	'n': C_PCRE_NOTEMPTY_ATSTART
}

F //(regexp:Str, flags:Str) {
	# Maybe add each(Str,Fun) ?
	# TOOD: bitwise or instead of sum()
	options = flags.map(F(flag) {
		STDLIB_REGEXP_FLAGS[flag] tor throw RegExpCompileFail("Unknown flag $flag").set('regexp', regexp).set('flags', flags)
	}).sum()

	c_pcre_compile(regexp, options)
}

TEST Bool("A" ~ /a/i)

doc Returns the string with the regexp cut out of it.
F -(s:Str, r:RegExp) {
	m = s ~ r
	not(m) throws InvalidArgument('String does not contain the RegExp').set('string', s).set('regexp', r)
	s[0..m.positions[0][0]] + s[m.positions[0][1]..null]
}

TEST "abc01def23" - /[0-9]+/ == "abcdef23"

F split(s:Str, r:RegExp) (~~)(s, r, true).filter(Str)

# Crashes on Ubuntu 14.04 clang 3.5.0 (Travis CI)
TEST (try ENV.TRAVIS and ENV.CC == "clang") returns true; "ab01de12f".split(/[0-9]+/) == ['ab', 'de', 'f']


F without(s:Str, r:RegExp) s.split(r).join('')

TEST (try ENV.TRAVIS and ENV.CC == "clang") returns true; "ab01de12f".without(/[0-9]+/) == 'abdef'

# TODO: make it a low priority method imlementation
F '[]'(s:Str, r:RegExp) {
	not((m = s ~ r)) throws InvalidArgument("String does not contain the given RegExp").set('container', s).set('regexp', r)
	m.whole
}

TEST "ab01de12f"[/[0-9]+/] == '01'

F Pred(r:RegExp) F regexp_pred(x) x ~ r

TEST %[w1 w2].filter(/1/) == %[w1]

F replace(s:Str, r:RegExp, mapper:Fun) {
	(~~)(s, r, true).map([ F(m:MatchY) mapper(m.whole), F(s:Str) s ]).join('')
}

# === Fun ========================================

F *(cb:Fun, n:Int) n.map({ cb() })

TEST a = Box * 2; a[0] is Box and a[1] is Box and a[0] !== a[1]

# === Null =======================================

F code(n:Null) "null"


# === exit_hook - Print uncaught exception =======

F exception_specific_message(e:Exception) null

F exception_specific_message(gnf:GlobalNotFound) "Global '${gnf.name}' not found"

doc Don't use, subject to change, including name
F SafeStr(val) "$val" tor "(Failed to inspect <${val.typeof().name tor '(unknown type)'}>)"

F inspect(val) [SafeStr(val)]
F inspect(r:Real) ["Real: $r"]
F inspect(i:Int) ["Int: $i"]
F inspect(s:Str) ["String: $s"]
F inspect(a:Arr) ["Array of size ${a.len()}"] + a.map_idx_val({"[${SafeStr(A)}] = ${SafeStr(B)}"})
F inspect(h:Hash) ["Hash of size ${h.len()}"] + h.map({"[${SafeStr(A)}] = ${SafeStr(B)}"})

F inspect(p:Process) {
	collector {
		c = collect
		c("Process")
		c("command = ${p.command}")
		c("pid = ${p.pid}")
		c("exit_code = ${p.exit_code}")
		c("exit_signal = ${p.exit_signal}")
		%[stdout stderr].each(F(attr) {
			val = (.)(p, attr)
			val_lines = if val is Null [] else val.lines()
			c("$attr (${val_lines.len()} lines):")
			("  " + val_lines) % c
		})
	}
}


F print_exception(e:Exception, level:Int = 0, parent:Exception = null) {

	F err(message:Str) error("$pfx$message")

	pfx = "  " * level
	h = Hash(e)

	err("Exception of type ${e.typeof().name} occured")

	if esm = exception_specific_message(e) {
		err(esm)
	}

	if 'message' in h {
		err("Message: ${h.message}")
	}

	info_keys = h.keys() - %[message backtrace cause]

	F print_info(k) {
		out = inspect(h[k]) tor ["(Failed to inspect)"]
		assert(out is Arr)
		assert(out.len() > 0)
		if out.len() == 1 {
			err("Info: $k = ${out[0]}")
		} else {
			err("Info: $k:")
			("  " + out) % err
		}

		# err("Info: $k is hash of size ${h[k].len()}")
	}

	info_keys % print_info

	if 'backtrace' in h {

		parent_frames = parent.backtrace.frames tor []

		h.backtrace.frames.each_idx_val(F(idx, frame) {

			# Don't print frames that overlap with parent exception
			frame.ip == (try parent_frames[idx].ip) returns null

			l = resolve_instruction_pointer(frame.ip)
			closure = " [in ${frame.closure.attrs().name}]" tor ''
			err("Frame $idx: ${l.file}:${l.first_line}:${l.first_column} - ${l.last_line}:${l.last_column}$closure")
		})
	}

	if 'cause' in h {
		err("Cause:")
		print_exception(e.cause, level+1, e)
	}

}

exit_hook = Hook()

# TODO: consider running this hook item last.
#       If it has exception, it could prevent
#       user-defined cleanups.
@hook(exit_hook, 'print_exception') F(exit_info:Hash) {
	if exit_info.exception is not Null {
		error("--- Exception during execution of main code ---")
		print_exception(exit_info.exception)
	}
}

@hook(exit_hook, 'exception_to_exit_code') F(exit_info:Hash) {
	if exit_info.exception is not Null {
		try {
			exit_info.exit_code = exit_info.exception.to_exit_code()
		} catch(e:Exception) {
			error("--- Exception during converting exception to exit code ---")
			print_exception(e)
		}
	}
}

# === Random =====================================
# This is _not_ crypto safe random!

srand(time())

STDLIB_MAX_RAND_REAL = Real(RAND_MAX)
STDLIB_RAND_SAFETY_MAX = 100

F rand_uniq(something, n:Int) {
	# TODO: Fix the guard - it does not work with Range currently
	# guard n <= something.len()
	result = []
	safety_counter = 0
	while len(result) < n {
		r = rand(something)
		if r in result {
			safety_counter += 1
			safety_counter == STDLIB_RAND_SAFETY_MAX throws Error("Not making progress in rand_uniq(something, n:Int)")
		} else {
			result.push(r)
			safety_counter = 0
		}
	}
	result
}

F rand(something, n:Int) n.map({ rand(something) })

F rand(n:Int) {
	r = rand()
	(RAND_MAX+1) % n == 0 returns r % n
	scale = Real(n) / STDLIB_MAX_RAND_REAL
	Real(r) * scale \ floor \ Int
}

# TODO: Sequence super-type?

F rand(a:Arr) a[rand(a.len())]

F rand(a:Str) a[rand(a.len())]

F rand(a:Str, n:Int) super(a, n).join('')

F rand(r:Range) {
	guard r.step == 1
	points = r.end - r.start
	if r is InclusiveRange points += 1
	rand(points) + r.start
}

# === retry facility =============================

{
	type RetryFail(Error)
}

F body_missing_in_retry() throw InvalidArgument("'body' argument missing in retry()")

# TODO: Hande NoNext that could occur in sleep iterator
F retry(
	times:Int=60,
	sleep=1,
	logger:Fun=debug,
	success_predicate=Bool,
	catch_exceptions=true,
	title="<retry>",
	progress_cb:Fun={null},
	success_cb:Fun={A},
	fail_cb=null,
	body:Fun=body_missing_in_retry
) {
	guard sleep is Int or sleep is Iter
	sleep_iter = if sleep is Int then ConstIter(sleep) else sleep
	result = null  # otherwise it will be local to try { ... }
	for(i;times) {
		n = i + 1
		progress_cb(n, times)
		logger("$title Attempt $n out of ${times}")
		try {
			result = body()
		} catch(e:Exception) {
			logger("$title Exception $e")
			not(catch_exceptions) throws e
		}
		if success_predicate(result) {
			return success_cb(result)
		}
		if(i < times - 1) {
			s = sleep_iter.next()
			logger("$title Sleeping ${s} seconds")
			$(sleep "$s")
		}
	}
	fail_cb is Null throws RetryFail()
	fail_cb()
}

TEST t = 0; retry(body={t+=1; false}, fail_cb={"OK"}, times=5, sleep=0) == "OK" and t == 5
TEST t = 0; retry(body={t+=1; "OK"}, fail_cb={"NOTOK"}, sleep=0) == "OK" and t == 1

# === Misc =======================================

STDLIB_HEX_DIGITS='0123456789ABCDEF'

doc Encodes each character in a string as two uppercase hexadecimal digits
F encode_hex(s:Str) {
	s.map(F(char) {
		n = ord(char)
		STDLIB_HEX_DIGITS[n / 16] + STDLIB_HEX_DIGITS[n % 16]
	}).join('')
}

STDLIB_INVALID_URI_CHAR_RE = /[^-a-zA-Z0-9_.!~*'()]/
#'

F encode_uri_component(s:Str) s.replace(STDLIB_INVALID_URI_CHAR_RE, F(char) '%' + encode_hex(char))

TEST encode_uri_component("ab+c%") == "ab%2Bc%25"


STDLIB_HTML_ESCAPE = {'&': '&amp;', '<': '&lt;', '>': '&gt;'}

F encode_html(s:Str) s.map(STDLIB_HTML_ESCAPE.get(X, X)).join('')

TEST "ab>+c%&'".encode_html() == "ab&gt;+c%&amp;'"


STDLIB_HTML_ATTR_ESCAPE = STDLIB_HTML_ESCAPE + {'"': '&quot;', "'": '&#39;'}

F encode_html_attr(s:Str) s.map(STDLIB_HTML_ATTR_ESCAPE.get(X, X)).join('')

TEST "ab>+c%&'".encode_html_attr() == "ab&gt;+c%&amp;&#39;"

doc Uset by match EXPR { ... } construct
doc %RET - a ~ b
F match(a,b) a ~ b

# === Misc tests =================================

# expr1 op= expr2
TEST a = 1; a+=1 ; a*=10; a == 20
TEST a=[{"x": 7}, {"x": 8}]; a .= x; a == [7, 8]
TEST a=[1,2]; a .= map(F(x) x*2); a[0]+=10; a == [12,4]

TEST o = {'a': 1, 'b': [null, false, true, 3.14], 'nothing': null}; decode_json(encode_json(o)) == o
TEST h={'a': 1, 'b': 2, 'c': 3}; h.update({'b': 20, 'd': 40}); h == {'a': 1, 'b': 20, 'c': 3, 'd': 40}

TEST F opt(a, b=10, *rest) [b, rest]; opt(1) == [10, []]
TEST F opt(a, b=10, *rest) [b, rest]; opt(1, 2) == [2, []]
TEST F opt(a, b=10, *rest) [b, rest]; opt(1, 2, 3) == [2, [3]]
TEST F opt(a, b=10, *rest) [b, rest]; opt(1, b=10) == [10, []]
TEST F opt(a, b=10, *rest, **kw) [b, rest, kw]; opt(1, b=20) == [20, [], {"b": 20}]
TEST F opt(a, b=10, *rest, **kw) [b, rest, kw]; opt(1, c=20) == [10, [], {"c": 20}]
TEST F opt(a, b=10, *rest) [b, rest]; try opt(1, c=20) == [10, []] catch(e:ImplNotFound) true
TEST F opt(a, b=10, *rest, **kw) [b, rest, kw]; opt(1, b=30, **{"b": 20}) == [20, [], {"b": 20}]
TEST F opt(a, b=10, *rest, **kw) [b, rest, kw]; opt(1, b=30, **{"b": 20}, b=40) == [40, [], {"b": 40}]
TEST F opt(a, b=10, *rest, **kw) [a, b, rest, kw]; opt(1, 100, 200, **{"b": 20}, b=40) == [1, 100, [200], {"b": 40}]
TEST F f(a) a; f(**{"a": 10}) == 10
TEST F f(a=7) a; f(**{"a": 10}) == 10

TEST F construct(x:Int) F() x; f1=construct(1); f2=construct(2); (f1==f1) and (f1!=f2)
TEST 1.1 < 1.11
TEST 1.1 + 1.1 == 2.2
TEST F uniq_attrs_func() "some body"; uniq_attrs_func[0].attrs({"a": 1}); uniq_attrs_func[0].attrs() == {"a": 1}
TEST attrs((+)[0])['name'] == '+'
# TODO: more introspection tests
TEST params((+)[0])[0]['name'] == 'a'
TEST params((+)[0])[0]['type'] === Real
TEST "config" in globals()
TEST args=['1', '+', '2']; $(expr $*args).Str()[0..1] == '3'
TEST time() > 1466662171
TEST a=[10,20,30]; f=a[X]; f(1) == 20
TEST a=[10,20,30]; f=X[1]; f(a) == 20

# === Arr tests ==================================
TEST [10,20,30,40][0..2] == [10,20]
TEST [10,20,30,40][1..2] == [20]
TEST (try [10,20,30,40][-1..2] catch(e:InvalidArgument) "OK") == "OK"
TEST [10,20,30,40][2..null] == [30, 40]
TEST (try [10,20,30,40][2..1] catch(e:InvalidArgument) "OK") == "OK"
TEST (try [10,20,30,40][2..10] catch(e:InvalidArgument) "OK") == "OK"
TEST [10,20,30,40][4..null] == []
TEST a=[1,2,3,4]; a[4..4]=["END"]; a[2..2]=["MIDDLE"]; a[0..0]=["START"]; a[0..1] = ["start"]; a == ["start", 1, 2, "MIDDLE", 3, 4, "END"]

# === Str tests ==================================
TEST "abcd"[1..3] == "bc"
TEST s="abcd"; s[4..4]="END"; s[2..2]="MIDDLE"; s[0..0]="START"; s[0..1] = "s"; s == "sTARTabMIDDLEcdEND"

# === NormalTypeInstance tests ===================
TEST a = Path("a"); b = Path("a"); (a == b) and (a !== b)
TEST Path("a") != Path("b")

# === Exceptions tests ===========================
TEST h={}; try h["a"] catch(e:KeyNotFound) true
TEST a=[]; try a[0] catch(e:IndexNotFound) true
TEST a=[]; try a[0]=1 catch(e:IndexNotFound) true
TEST type T; try T().xyz catch(e:AttrNotFound) true
TEST try NO_SUCH_GLOBAL catch(e:GlobalNotFound) true
TEST try c_lseek(0, 0, "bad arg") catch(e:InvalidArgument) true
TEST try compile("xyz(", "something") catch(e:CompileFail) true
TEST try 1(2, 3) catch(e:DontKnowHowToCall) true
TEST type T; try echo(T(), T()) catch(e:ImplNotFound) true
TEST try F f() f(); try f() catch(e:StackDepthFail) true
TEST try [].pop() catch(e:EmptyArrayFail) true
TEST try [].shift() catch(e:EmptyArrayFail) true

# === Partial application tests ==================
TEST [{"val": 10, "flag": false}, {"val": 20, "flag": true}].filter(X.flag).val == [20]
TEST [[1, 10], [2,20]].map(X[0]) == [1, 2]
TEST [1,2].map([10,20,30][X]) == [20, 30]
TEST [[1],[2,3]].filter(X.has(1)) == [[1]]
