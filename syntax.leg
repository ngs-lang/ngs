%{
#include <stdarg.h>
#include <string.h>
#include "ngs.h"
#include "ast.h"
#include "syntax.h"
#include "obj.h"

// gcc still warns about unused yymatchDot() and yyAccept(). clang does not.
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-function"
#pragma GCC diagnostic ignored "-Wunused-label"
#pragma GCC diagnostic ignored "-Wunused-parameter"

#define YY_CTX_LOCAL 1

#define YY_MAX_LINES (10000)

// TODO: use read()
#define YY_INPUT(yy, buf, result, max_size)		\
  { \
    int yyc = getc(yy->input_file); \
	if(yyc == EOF) { \
		result = 0; \
	} else { \
		*(buf) = yyc; \
		yy->seq_pos++; \
		if(yyc == '\n') { \
			yy->lines++; \
			assert(yy->lines < YY_MAX_LINES); \
			yy->lines_postions[yy->lines] = yy->seq_pos; \
		} \
		yyprintf((stderr, "<%c>", yyc)); \
		result = 1; \
	} \
  }

#define ALLOC_NODE(dst, type_) (dst) = NGS_MALLOC(sizeof(ast_node)); dst->type=type_
#define CAPTURE_LOCATION(name) { \
	name->location.first_line = location[0]; \
	name->location.first_column = location[1]; \
	name->location.last_line = location[2]; \
	name->location.last_column = location[3]; \
}
#define MAKE_NODE(name, type_) \
	ast_node *name = NGS_MALLOC(sizeof(*name)); name->type = type_; name->data = NULL; name->warning = NULL; \
	CAPTURE_LOCATION(name) \
	DEBUG_PARSER("[ast_node] at %p type %3d (%-12s) %d:%d-%d:%d\n", name, name->type, NGS_AST_NODE_TYPES_NAMES[name->type], name->location.first_line, name->location.first_column, name->location.last_line, name->location.last_column);
// TODO: check whether it's appropriate to use Boehm's "atomic" allocation.
#define COPY_NODE(dst, src) (dst) = NGS_MALLOC(sizeof(ast_node)); memcpy((dst), (src), sizeof(ast_node))
#define MAKE_REQ_ARG_NODE(name, val) MAKE_NODE(name, ARG_NODE); name->first_child = val; val->next_sibling = NULL;
#define PREPEND_NODE(list, elt) elt->next_sibling = list->first_child; list->first_child = elt; if(!list->last_child) { list->last_child=elt; };

#define MAKE_IDENTIFIER_NODE(var_name, s) MAKE_NODE(var_name, IDENTIFIER_NODE); var_name->name = ngs_strdup(s);
#define MAKE_STRING_NODE(var_name, s) \
	MAKE_NODE(var_name, STR_COMPS_NODE); \
		MAKE_NODE(var_name##_comp, STR_COMP_IMM_NODE); \
		var_name##_comp->name = ngs_strdup(s); \
		append_ast_node_child(var_name, var_name##_comp);

#define HANDLE_FAILED_MATCH(rule_name) \
	if(yy->__pos > yy->fail_pos) {\
		yy->fail_pos = yy->__pos; \
		yy->fail_rule = rule_name; \
	}

void append_ast_node_child(ast_node *target, ast_node *child) {
	// printf("TARGET %p, CHILD %p\n", target, child);
	if(!target->first_child) {
		target->first_child = child;
		target->last_child = child;
		return;
	}
	target->last_child->next_sibling = child;
	target->last_child = child;
}

ast_node *wrap_in_func(ast_node *node, int save_orig, int location[4], char *docstring, int args_are_optional, int argc, ...) {
	int i;
	va_list varargs;
	ast_node *p;
	MAKE_NODE(func, FUNC_NODE);
	MAKE_NODE(params, PARAMS_NODE);
	MAKE_STRING_NODE(doc, docstring);

	func->first_child = params;
	if(save_orig) {
		func->data = (void *)node; // Save original node for possible unwrapping
	}
	params->next_sibling = node;
	node->next_sibling = doc;

	va_start(varargs, argc);
	for(i=0, p=NULL; i<argc; i++) {
		MAKE_NODE(param, PARAM_NODE);
		MAKE_IDENTIFIER_NODE(param_name, va_arg(varargs, char *))
		MAKE_IDENTIFIER_NODE(param_type, va_arg(varargs, char *))
		param->first_child = param_name;
		param_name->next_sibling = param_type;
		if(args_are_optional) {
			MAKE_NODE(dflt, NULL_NODE);
			param_type->next_sibling = dflt;
		}
		if(p) {
			p->next_sibling = param;
		} else {
			params->first_child = param;
		}
		p = param;
	}
	va_end(varargs);
	return func;
}

// TODO: name the function
ast_node *call_node_partial_application(ast_node *orig, int location[4]) {
	ast_node *p, *arg;
	int save_orig = 0;
	// Option 1:
	//   orig - CALL_NODE
	//   first_child - callable
	//   first_child->next_sibling - args
	//   first_child->next_sibling children - [arg]
	// Option 2:
	//   orig - FIELD_NODE or NS_NODE (which are later treated as call nodes)

	// Handle erroneously wrapped X.something when it's actually X.something(blah)
	if(orig->type == CALL_NODE && orig->first_child->type == FUNC_NODE && orig->first_child->data) {
		((ast_node *)(orig->first_child->data))->next_sibling = orig->first_child->next_sibling;
		orig->first_child = orig->first_child->data;
		return wrap_in_func(orig, 0, location, "Partial application syntax - X.something(blah)", 1, 3, "X", "Any", "Y", "Any", "Z", "Any");
	}

	save_orig = orig->type == FIELD_NODE || orig->type == NS_NODE;

	p = orig->first_child;
	if(p->type == FIELD_NODE || p->type == NS_NODE) {
		// TODO: apply call_node_partial_application later so it will not be a special case?
		p = p->first_child;
	}
	if(p->type == IDENTIFIER_NODE && strlen(p->name) == 1) {
		if(p->name[0] == 'X' || p->name[0] == 'Y' || p->name[0] == 'Z') {
			// wrap_in_func(ast_node *node, int location[4], char *docstring, int argc, ...) {
			return wrap_in_func(orig, save_orig, location, "Partial application syntax", 1, 3, "X", "Any", "Y", "Any", "Z", "Any");
		}
	}
	if(orig->type == FIELD_NODE || orig->type == NS_NODE) {
		if(orig->first_child->next_sibling->type == EXPRESSIONS_NODE) {
			p = orig->first_child->next_sibling->first_child;
			if(p && !p->next_sibling && p->type == IDENTIFIER_NODE) {
				if(p->name[0] == 'X' || p->name[0] == 'Y' || p->name[0] == 'Z') {
					return wrap_in_func(orig, save_orig, location, "Partial application syntax", 1, 3, "X", "Any", "Y", "Any", "Z", "Any");
				}
			}
		}
		return orig;
	}
	for(p=orig->first_child->next_sibling->first_child; p; p=p->next_sibling) {
		arg = p->first_child;
		if(arg->type == IDENTIFIER_NODE && strlen(arg->name) == 1) {
			if(arg->name[0] == 'X' || arg->name[0] == 'Y' || arg->name[0] == 'Z') {
				// wrap_in_func(ast_node *node, int location[4], char *docstring, int argc, ...) {
				return wrap_in_func(orig, save_orig, location, "Partial application syntax", 1, 3, "X", "Any", "Y", "Any", "Z", "Any");
			}
		}
	}
	return orig;
}

// TODO: name the function
ast_node *string_node_partial_application(ast_node *orig, int location[4]) {
	ast_node *p, *pp;
	assert(orig->type == STR_COMPS_NODE);
	for(p=orig->first_child; p; p=p->next_sibling) {
		if(p->type == STR_COMP_IMM_NODE) {
			pp = p;
		} else {
			pp = p->first_child;
		}
		if(pp->type == EXPRESSIONS_NODE && pp->first_child && !pp->first_child->next_sibling && pp->first_child->type == IDENTIFIER_NODE) {
			pp = pp->first_child;
		}
		if(pp->type == IDENTIFIER_NODE && strlen(pp->name) == 1) {
			if(pp->name[0] == 'X' || pp->name[0] == 'Y' || pp->name[0] == 'Z') {
				// wrap_in_func(ast_node *node, int location[4], char *docstring, int argc, ...) {
				return wrap_in_func(orig, 0, location, "Partial application syntax - string", 1, 3, "X", "Any", "Y", "Any", "Z", "Any");
			}
		}
	}
	return orig;
}

ast_node *index_node_partial_application(ast_node *orig, int location[4]) {
	ast_node *p;
	for(p=orig->first_child; p; p=p->next_sibling) {
		if(p->type == IDENTIFIER_NODE && strlen(p->name) == 1) {
			if(p->name[0] == 'X' || p->name[0] == 'Y' || p->name[0] == 'Z') {
				return wrap_in_func(orig, 0, location, "Partial application syntax - index syntax", 1, 3, "X", "Any", "Y", "Any", "Z", "Any");
			}
		}
	}
	return orig;
}

// TODO: more efficient than two scans
ast_node *copy_ast_tree(ast_node *src) {
	ast_node *dst, *p;
	if(!src) return NULL;
	dst = NGS_MALLOC(sizeof(*dst));
	assert(dst);
	memcpy(dst, src, sizeof(*dst));
	dst->first_child = copy_ast_tree(dst->first_child);
	dst->next_sibling = copy_ast_tree(dst->next_sibling);
	for(p = dst->first_child; p; p=p->next_sibling) {
		// nothing
	}
	dst->last_child = p;
	return dst;
}

int is_exportable(ast_node *node) {
	assert(node->type == IDENTIFIER_NODE);
	if(!node->name) return 0;
	return node->name[0] != '_';
}

void process_namespace(ast_node *first_child, int location[4]) {
	ast_node *node, *identifier_to_export;
	for(node = first_child; node ; node = node->next_sibling) {
		identifier_to_export = NULL;
		if(node->type == ASSIGNMENT_NODE && node->first_child->type == IDENTIFIER_NODE) {
			identifier_to_export = node->first_child;
		}
		if(node->type == FUNC_NODE) {
			if(node->first_child->next_sibling->next_sibling->next_sibling) {
				// Function has a name
				identifier_to_export = node->first_child->next_sibling->next_sibling->next_sibling;
			}
		}
		if(node->type == SECTION_NODE) {
			process_namespace(node->first_child->next_sibling->first_child, location);
			continue;
		}
		if(identifier_to_export && is_exportable(identifier_to_export)) {
			MAKE_NODE(e, ASSIGNMENT_NODE);
				MAKE_NODE(lhs, INDEX_NODE);
					MAKE_IDENTIFIER_NODE(exports_identifier, "_exports");
					append_ast_node_child(lhs, exports_identifier);
					MAKE_STRING_NODE(exports_key, ngs_strdup(identifier_to_export->name));
					append_ast_node_child(lhs, exports_key);
				append_ast_node_child(e, lhs);
				append_ast_node_child(e, copy_ast_tree(identifier_to_export));
			e->next_sibling = node->next_sibling;
			node->next_sibling = e;
			node = e; // Skip over newly created node
		}
	}
}

%}

start = 
	commands eof

eof = !.

space = [ \t\n]+
inline_space = [ \t]+
newline_space = (inline_space? [\n]+ inline_space?)+

commands =
	space? c:command commands-separator cs:commands {
		if(c) {
			PREPEND_NODE(cs, c);
		}
		$$ = cs;
		CAPTURE_LOCATION($$);
	}
	|
	c:command commands-separator? space? {
		MAKE_NODE(ret, EXPRESSIONS_NODE);
		ret->first_child = c;
		ret->last_child = c;
		$$ = ret;
		CAPTURE_LOCATION($$);
	}
	|
	{
		MAKE_NODE(ret, EXPRESSIONS_NODE);
		$$ = ret;
	}

commands-separator = newline_space | inline_space? [;] inline_space?
items-separator = newline_space | inline_space? [,] space?

comment =
  "#" [^\n]* { $$ = NULL; }
  |
  "TEST " [^\n]+ { $$ = NULL; }

command =
	curly-code-block
	|
	assignment
	|
	inplace-assignment
	|
	function-definition
	|
	function-call
	|
	type
	|
	namespace
	|
	block
	|
	section
	|
	if
	|
	while
	|
	switch
	|
	for
	|
	& (identifier ("." | "::")) expression
	|
	comment
	|
	cp:commands-pipeline {
		// TODO: constants for flags
		MAKE_STRING_NODE(option_pair, "top_level")
			MAKE_STRING_NODE(option_name, "top_level")
			append_ast_node_child(option_pair, option_name);
			MAKE_NODE(option_value, TRUE_NODE);
			append_ast_node_child(option_pair, option_value);
		append_ast_node_child($$->first_child->next_sibling->next_sibling->next_sibling, option_pair);
		cp->number = 1;
		$$ = cp;
	}


curly-code-block =
	space? '{' space? code:expressions space? ";"? space? '}' {
		$$ = code;
	}

empty-curly-code-block =
	space? '{' space? '}' {
		MAKE_NODE(code, EXPRESSIONS_NODE);
		$$ = code;
	}

code-block = curly-code-block | expression

expressions =
	e:expression expression-delimiter es:expressions {
		if(e) {
			PREPEND_NODE(es, e);
		}
		$$ = es;
		CAPTURE_LOCATION($$);
	}
	|
	e:expression {
		MAKE_NODE(ret, EXPRESSIONS_NODE);
		ret->first_child = e;
		ret->last_child = e;
		$$ = ret;
	}

expression-delimiter =
	newline_space
	|
	inline_space? ";" space?

expression =
	comment
	|
	e:binop-expression (inline_space comment)? { $$ = e; }

binop-expression = e:binop-expression-inner {
	// Handle special "and" and "or" nodes.
	AST_NODE_TYPE_LL *ll;
	ast_node *cur, *arg0_node;

	for(ll = yy->nodes_for_type_change; ll; ll=ll->next) {
		cur = ll->node;
		if(cur->type == ll->type) {
			// Already processed this node
			// Warn here maybe? Duplicates should not appear here.
			continue;
		}
		assert(cur->type == CALL_NODE);
		arg0_node = cur->first_child->next_sibling->first_child;
		cur->type = ll->type;
		cur->first_child = arg0_node->first_child;
		cur->first_child->next_sibling = arg0_node->next_sibling->first_child;
	}
	yy->nodes_for_type_change = NULL;
	$$ = e;
}

binop-expression-inner =
	e1:chain-expression (b:binop e2:chain-expression {
		// TODO: cleaner code and better naming
		MAKE_NODE(args, ARGS_NODE);
		b->next_sibling = args;
		if(e1->type == CALL_NODE && e1->number && e1->number < b->number) {
			MAKE_NODE(next_node, CALL_NODE);
			next_node->first_child = b;
			next_node->number = b->number;
			MAKE_REQ_ARG_NODE(a2, e2);
			args->first_child = e1->first_child->next_sibling->first_child->next_sibling;
			args->first_child->next_sibling = a2;
			MAKE_REQ_ARG_NODE(arg_for_next_node, next_node);
			e1->first_child->next_sibling->first_child->next_sibling = arg_for_next_node;
		} else {
			MAKE_NODE(ret, CALL_NODE);
			ret->first_child = b;
			ret->number = b->number;
			// args
				MAKE_REQ_ARG_NODE(a1, e1);
				MAKE_REQ_ARG_NODE(a2, e2);
				a1->next_sibling = a2;
				args->first_child = a1;
			ret = call_node_partial_application(ret, location);
			e1 = ret;
		}
		if(e1->first_child && e1->first_child->type == IDENTIFIER_NODE) {
			ast_node_type t=0;
			AST_NODE_TYPE_LL *ll;
			if(!strcmp("and",  e1->first_child->name)) { t = AND_NODE; }
			if(!strcmp("or",   e1->first_child->name)) { t = OR_NODE; }
			if(!strcmp("tand", e1->first_child->name)) { t = TAND_NODE; }
			if(!strcmp("tor",  e1->first_child->name)) { t = TOR_NODE; }
			if(t) {
				// TODO: dedup. Somehow "or" node in 'echo("a" == "a" or "b" == "b")' is registered twice
				ll = NGS_MALLOC(sizeof(*ll));
				assert(ll);
				ll->node = e1;
				ll->type = t;
				ll->next = yy->nodes_for_type_change;
				yy->nodes_for_type_change = ll;
			}
		}
	}
	|
	space "returns" {
		// e1 returns e2 => if e1 { return e2 }
		MAKE_NODE(ret, IF_NODE);
			ret->first_child = e1;
			MAKE_NODE(yes, RETURN_NODE);
				MAKE_NODE(if_yes, NULL_NODE);
				yes->first_child = if_yes;
			e1->next_sibling = yes;
			MAKE_NODE(no, NULL_NODE);
			yes->next_sibling = no;
		e1 = ret;
	} (inline_space e2:expression {
		// if -> old e1 -> return    -> return value
		e1->first_child->next_sibling->first_child = e2;
	})?
	|
	space "breaks" {
		// e1 breaks => if e1 { break }
		MAKE_NODE(ret, IF_NODE);
			ret->first_child = e1;
			MAKE_NODE(yes, BREAK_NODE);
			e1->next_sibling = yes;
			MAKE_NODE(no, NULL_NODE);
			yes->next_sibling = no;
		e1 = ret;
	}
	|
	space "continues" {
		// e1 continues => if e1 { continue }
		MAKE_NODE(ret, IF_NODE);
			ret->first_child = e1;
			MAKE_NODE(yes, CONTINUE_NODE);
			e1->next_sibling = yes;
			MAKE_NODE(no, NULL_NODE);
			yes->next_sibling = no;
		e1 = ret;
	}
	|
	space "throws" space e2:expression {
		// e1 throws e2 => if e1 { throw e2 }
		MAKE_NODE(ret, IF_NODE);
			ret->first_child = e1;
			MAKE_NODE(yes, THROW_NODE);
				yes->first_child = e2;
			e1->next_sibling = yes;
			MAKE_NODE(no, NULL_NODE);
			yes->next_sibling = no;
		e1 = ret;
	}
	)* {
		// XXX
		$$ = e1;
	}

binop = binop1 | binop2

binop1 = inline_space? (
	<"|">  @@ 120 @@
	| <"==="> @@ 130 @@
	| <"!=="> @@ 130 @@
	| <"=="> @@ 130 @@
	| <"!="> @@ 130 @@
	| <"=~"> @@ 130 @@
	| <"!~"> @@ 130 @@
	| <"->"> @@ 140 @@
	| <"<="> @@ 150 @@
	| <"<">  @@ 150 @@
	| <">="> @@ 150 @@
	| <">">  @@ 150 @@
	| <"~~"> @@ 150 @@
	| <"~">  @@ 150 @@
	| <"...">@@ 160 @@
	| <".."> @@ 160 @@
	| <"+?"> @@ 190 @@
	| <"+">  @@ 190 @@
	| <"-">  @@ 190 @@
	| <"*">  @@ 200 @@
	| <"%">  @@ 200 @@
	| <"/">  @@ 200 @@
	| <"?">  @@ 200 @@
	| <"\\"> @@ 200 @@
	) space?

binop2 = inline_space op:binop2op space { $$ = op; }

binop2op =
	  <"is not">  @@ 90 @@
	| <"is">      @@ 90 @@
	| <"and">     @@ 65 @@
	| <"or">      @@ 60 @@
	| <"in">      @@ 70 @@
	| <"not in">  @@ 70 @@
	| <"tand">    @@ 50 @@
	| <"tor">     @@ 40 @@

inplace-assignment-op = <[-+*/%]> {
	MAKE_NODE(ret, IDENTIFIER_NODE);
	ret->name = ngs_strdup(yytext);
	$$ = ret;
}

chain-item = e:identifier
		| e:array-literal
		| e:imm-array-literal
		| e:number
		| e:string
		| e:parenthesized-expr
		| e:hash-literal
		| e:imm-hash-literal
		| e:abc-function-literal
		| e:subshell
abc-function-literal {
	$$ = e;
	CAPTURE_LOCATION($$)
};

chain-expression-without-assignments = b:chain-item (
		inline_space? a:function-call-arguments {
			// TODO: deduplicate chain-expression-without-assignments/chain-expression
			// printf("CHAIN/FCALL\n");
			MAKE_NODE(ret, CALL_NODE);
			ret->first_child = b;
			ret->first_child->next_sibling = a;
			ret = call_node_partial_application(ret, location);
			b = ret;
		}
		|
		"[" space? idx:expression space? "]" {
			MAKE_NODE(ret, INDEX_NODE);
			ret->first_child = b;
			ret->first_child->next_sibling = idx;
			ret = index_node_partial_application(ret, location);
			b = ret;
		}
		|
		"." e:chain-item {
			MAKE_NODE(ret, FIELD_NODE);
				ret->number = 902;
				ret->first_child = b;
				ret->first_child->next_sibling = e;
				ret = call_node_partial_application(ret, location);
			b = ret;
		}
		|
		"::" e:chain-item {
			MAKE_NODE(ret, NS_NODE);
				ret->number = 903;
				ret->first_child = b;
				ret->first_child->next_sibling = e;
				ret = call_node_partial_application(ret, location);
			b = ret;
		}
	)*
	{
		$$ = b;
		CAPTURE_LOCATION($$)
	}


chain-expression = b:basic-expression (
		inline_space? a:function-call-arguments {
			// printf("CHAIN/FCALL\n");
			MAKE_NODE(ret, CALL_NODE);
			ret->first_child = b;
			ret->first_child->next_sibling = a;
			ret = call_node_partial_application(ret, location);
			b = ret;
		}
		|
		"[" space? idx:expression space? "]" {
			MAKE_NODE(ret, INDEX_NODE);
			ret->first_child = b;
			ret->first_child->next_sibling = idx;
			ret = index_node_partial_application(ret, location);
			b = ret;
		}
		|
		inline_space? op:inplace-assignment-op "=" space? e:expression {
			MAKE_NODE(ret, ASSIGNMENT_NODE);
			ret->number = 950; // XXX: needed?

			MAKE_NODE(call_node, CALL_NODE);
				call_node->first_child = op;
				MAKE_NODE(call_args, ARGS_NODE);
					MAKE_NODE(call_arg1, ARG_NODE);
						call_arg1->first_child = copy_ast_tree(b);
						call_arg1->first_child->next_sibling = NULL;
					MAKE_NODE(call_arg2, ARG_NODE);
						call_arg2->first_child = e;
						call_arg2->first_child->next_sibling = NULL;
					call_arg1->next_sibling = call_arg2;
					call_args->first_child = call_arg1;
				call_node->first_child->next_sibling = call_args;

			ret->first_child = b;
			b->next_sibling = call_node;
			b = ret;
		}
		|
		inline_space? ".=" space? e:expression {
			MAKE_NODE(ret, ASSIGNMENT_NODE);
			ret->number = 950; // XXX: needed?
			ret->first_child = b;

			if(e->type == CALL_NODE) {
				MAKE_NODE(call_arg1, ARG_NODE);
					call_arg1->first_child = copy_ast_tree(b);
					call_arg1->next_sibling = e->first_child->next_sibling->first_child;
				e->first_child->next_sibling->first_child = call_arg1;
				b->next_sibling = e;
			} else {
				MAKE_NODE(field_node, FIELD_NODE);
					append_ast_node_child(field_node, copy_ast_tree(b));
					append_ast_node_child(field_node, e);
				b->next_sibling = field_node;
			}

			b = ret;
		}
		|
		inline_space? "=" space? e:expression {
			MAKE_NODE(ret, ASSIGNMENT_NODE);
			b->next_sibling = e;
			ret->first_child = b;
			b = ret;
		}
		|
		"." e:chain-item {
			MAKE_NODE(ret, FIELD_NODE);
				ret->number = 902;
				ret->first_child = b;
				ret->first_child->next_sibling = e;
				ret = call_node_partial_application(ret, location);
			b = ret;
		}
		|
		"::" e:chain-item {
			MAKE_NODE(ret, NS_NODE);
				ret->number = 903;
				ret->first_child = b;
				ret->first_child->next_sibling = e;
				ret = call_node_partial_application(ret, location);
			b = ret;
		}
	)*
	{
		$$ = b;
		CAPTURE_LOCATION($$)
	}

basic-expression =
	if
	| while
	| switch
	| cond
	| for
	| comment
	| "null"  { MAKE_NODE(ret, NULL_NODE); $$ = ret; }
	| "true"  { MAKE_NODE(ret, TRUE_NODE); $$ = ret; }
	| "false" { MAKE_NODE(ret, FALSE_NODE); $$ = ret; }
	| number
	| string
	| regexp
	| assignment
	| inplace-assignment
	| var-scope-declaration
	| function-definition
	| return
	| break
	| continue
	| namespace
	| collector
	| block
	| section
	| guard
	| try-catch
	| throw
	| type
	| subshell
	| super
	| PRINT_AST
	| identifier
	| array-literal
	| imm-array-literal
	| hash-literal
	| abc-function-literal
	| imm-hash-literal
	| tree-literal
	| parenthesized-expr

parenthesized-expr = "(" space? e:expression space? ")" {
		MAKE_NODE(ret, EXPRESSIONS_NODE);
		ret->name = "()";
		ret->first_child = e;
		ret->last_child = e;
		$$ = ret;
}

assignment =
	i:identifier space? "=" space? e:expression {
		MAKE_NODE(ret, ASSIGNMENT_NODE);
		i->next_sibling = e;
		ret->first_child = i;
		$$ = ret;
	}

inplace-assignment = i:identifier space? op:inplace-assignment-op "=" space? e:expression {
	MAKE_NODE(ret, ASSIGNMENT_NODE);

	MAKE_NODE(call_node, CALL_NODE);
		call_node->first_child = op;
		MAKE_NODE(call_args, ARGS_NODE);
			MAKE_NODE(call_arg1, ARG_NODE);
				call_arg1->first_child = copy_ast_tree(i);
				call_arg1->first_child->next_sibling = NULL;
			MAKE_NODE(call_arg2, ARG_NODE);
				call_arg2->first_child = e;
				call_arg2->first_child->next_sibling = NULL;
			call_arg1->next_sibling = call_arg2;
			call_args->first_child = call_arg1;
		call_node->first_child->next_sibling = call_args;

	ret->first_child = i;
	i->next_sibling = call_node;
	$$ = ret;
}

function-definition =
	doc:optional-doc inline_space? "F" name:function-definition-name space? "(" space? params:function-definition-parameters space? ")" space? body:code-block {
		MAKE_NODE(ret, FUNC_NODE);
		ret->first_child = params;
		params->next_sibling = body;
		body->next_sibling = doc;
		doc->next_sibling = name;
		$$ = ret;
	}

function-definition-name =
	space+ (
		i:identifier { $$ = i; }
		| ("'" <([-|=!@?<>~+*/%()$a-zA-Z0-9.`": ]|"["|"]")+> "'" | <[-|=!@?~+*/%$.`\\]+> ) {
			MAKE_NODE(ret, IDENTIFIER_NODE);
			ret->name = ngs_strdup(yytext);
			$$ = ret;
		}
	)
	| { $$ = NULL; }

function-definition-parameters =
	acc:params-node
	(
		arg:function-definition-parameter { append_ast_node_child(acc, $$); }
		(items-separator arg:function-definition-parameter { append_ast_node_child(acc, $$); } )*
	)* {
		$$ = acc;
		CAPTURE_LOCATION($$);
	}

params-node = { MAKE_NODE(ret, PARAMS_NODE); $$ = ret; }

# TODO: make sure it's the last one (or the last ones are *args, **kwargs later)
# *args at any other positon is a syntax error for now
function-definition-parameter =
	"**" space? i:identifier {
		MAKE_NODE(ret, PARAM_NODE);
			MAKE_NODE(arr, IDENTIFIER_NODE);
			arr->name = "Hash";
			MAKE_NODE(splat, HASH_SPLAT_NODE);
			ret->first_child = i;
			i->next_sibling = arr;
			arr->next_sibling = splat;
		$$ = ret;
	}
	|
	"*" space? i:identifier {
		MAKE_NODE(ret, PARAM_NODE);
			MAKE_NODE(arr, IDENTIFIER_NODE);
			arr->name = "Arr";
			MAKE_NODE(splat, ARR_SPLAT_NODE);
			ret->first_child = i;
			i->next_sibling = arr;
			arr->next_sibling = splat;
		$$ = ret;
	}
	|
	i:identifier t:function-definition-parameter-type d:function-definition-default-value {
		MAKE_NODE(ret, PARAM_NODE);
		ret->first_child = i;
		i->next_sibling = t;
		t->next_sibling = d;
		$$ = ret;
	}
	|
	t:chain-expression-without-assignments {
		MAKE_NODE(ret, PARAM_NODE);
			MAKE_NODE(unnamed, IDENTIFIER_NODE);
			unnamed->name = "_unnamed";
			ret->first_child = unnamed;
			unnamed->next_sibling = t;
			t->next_sibling = NULL;
		$$ = ret;
	}

# TODO: check if we can remove c:identifier limitation and let it be something
#       like expression. Currently the problem with expression is that it
#       captures assignment so you can't do "x:Int=10". It gives var "x" and type "10"
#       when evaluated.
function-definition-parameter-type =
	space? ":" space? c:chain-expression-without-assignments { $$ = c; }
	|
	{
		MAKE_NODE(ret, IDENTIFIER_NODE);
		ret->name = "Any";
		$$ = ret;
	}

function-definition-default-value =
	space? "=" space? c:expression { $$ = c; }
	|
	{
		$$ = NULL;
	}

namespace = "ns" opt_params:namespace-optional-parameters (c:curly-code-block | c:empty-curly-code-block) {

		// ns(opt_params) { c } OR ns(opt_params) { }
		// (transforms to)
		// F(opt_params) {
		//   local _exports
		//   _exports = Namespace()
		//   c
		//   _exports
		// }()

		MAKE_NODE(code, EXPRESSIONS_NODE);

			// local _exports
			MAKE_NODE(local_exports, LOCAL_NODE);
				MAKE_IDENTIFIER_NODE(local_exports_identifier, "_exports")
				append_ast_node_child(local_exports, local_exports_identifier);
			append_ast_node_child(code, local_exports);

			// exports = Namespace()
			MAKE_NODE(set_exports, ASSIGNMENT_NODE);
				MAKE_IDENTIFIER_NODE(exports_identifier, "_exports")
				append_ast_node_child(set_exports, exports_identifier);
				MAKE_NODE(call_namespace_constructor, CALL_NODE);
                    MAKE_IDENTIFIER_NODE(namespace_constructor, "Namespace");
                    MAKE_NODE(namespace_constructor_args, ARGS_NODE);
                    call_namespace_constructor->first_child = namespace_constructor;
                    namespace_constructor->next_sibling = namespace_constructor_args;
				append_ast_node_child(set_exports, call_namespace_constructor);

			append_ast_node_child(code, set_exports);

			// SET NAMESPACE FOR COMPILER PHASE
			MAKE_NODE(set_ns, SET_NS_NODE);
				MAKE_IDENTIFIER_NODE(set_ns_exports_identifier, "_exports")
				append_ast_node_child(set_ns, set_ns_exports_identifier);
			append_ast_node_child(code, set_ns);

			// c, the original body
			append_ast_node_child(code, c);

			// exports
			MAKE_IDENTIFIER_NODE(exports_identifier2, "_exports")
			append_ast_node_child(code, exports_identifier2);

		// F() { ... } ()
		MAKE_NODE(ret, CALL_NODE);
			// TODO: better location. Currently points only to "ns" string.
			ast_node *callable = wrap_in_func(code, 0, location, "Namespace syntax", 0, 0);
			if(opt_params->type == PARAMS_NODE) {
				opt_params->next_sibling = callable->first_child->next_sibling;
				callable->first_child = opt_params;
			}

			append_ast_node_child(ret, callable);
			MAKE_NODE(args, ARGS_NODE);
			append_ast_node_child(ret, args);

		// TODO: make "exports['var'] = var" conditional - only if "var" is local
		process_namespace(c->first_child, location);

		$$ = ret;
	}

namespace-optional-parameters =
	space? "(" space? params:function-definition-parameters space? ")" { $$ = params; }
	|
	{ MAKE_NODE(ret, NULL_NODE); $$ = ret; }

identifier-as-text = <[%_a-zA-Z]+[_a-zA-Z0-9]*> {
		MAKE_STRING_NODE(s, yytext);
		$$ = s;
	}

text-till-eol = <[^\n]+> [\n] {
		MAKE_STRING_NODE(s, yytext);
		$$ = s;
	}


doc-line =
	inline_space? "doc " id:identifier-as-text " -" inline_space? [\n] {
		MAKE_NODE(kv, EXPRESSIONS_NODE);
			MAKE_STRING_NODE(v, "");
			append_ast_node_child(kv, id);
			append_ast_node_child(kv, v);
		$$ = kv;
	}
	|
	inline_space? "doc " id:identifier-as-text " - " txt:text-till-eol {
		MAKE_NODE(kv, EXPRESSIONS_NODE);
			append_ast_node_child(kv, id);
			append_ast_node_child(kv, txt);
		$$ = kv;
	}
	|
	inline_space? "doc " txt:text-till-eol {
		MAKE_NODE(kv, EXPRESSIONS_NODE);
			MAKE_STRING_NODE(k, "");
			append_ast_node_child(kv, k);
			append_ast_node_child(kv, txt);
		$$ = kv;
	}
	|
	inline_space? "doc" inline_space? [\n] {
		$$ = NULL;
	}


doc-lines = acc:doc-node (l:doc-line {
	if(l) {
		//                                kv-pair     STR_COMPS_NODE STR_COMP_IMM_NODE
		if(acc->last_child && (!strcmp(acc->last_child->first_child->first_child->name, l->first_child->first_child->name))) {
			// Same key as above - append the text to existing array
			append_ast_node_child(acc->last_child->first_child->next_sibling, l->first_child->next_sibling);
		} else {
			// New key - make new array
			MAKE_NODE(kv, EXPRESSIONS_NODE);
				MAKE_NODE(arr, ARR_LIT_NODE);
					append_ast_node_child(arr, l->first_child->next_sibling);
				append_ast_node_child(kv, l->first_child);
				append_ast_node_child(kv, arr);
			append_ast_node_child(acc, kv);
		}
	}
})+ { $$ = acc; }

doc-node = { MAKE_NODE(ret, HASH_LIT_NODE); $$ = ret; }

optional-doc =
	e:doc-lines { $$ = e; }
	|
	{ MAKE_NODE(ret, NULL_NODE); $$ = ret; }

function-call =
	f:basic-expression inline_space? args:function-call-arguments {
		MAKE_NODE(ret, CALL_NODE);
		ret->first_child = f;
		ret->first_child->next_sibling = args;
		ret = call_node_partial_application(ret, location);
		$$ = ret;
	}

function-call-arguments = "(" space? a:function-call-arguments-without-parens space? ")" (space w:function-call-external-argument {
		append_ast_node_child(a, w);
	})* {
	$$ = a;
}

# NOTE: the "=>" syntax is deprecated
function-call-external-argument =
	("with" | "do") space a:function-call-argument {
		$$ = a;
	}
	|
	i:identifier space? "=>" space? e:expression {
		MAKE_NODE(ret, ARG_NODE);
		ret->first_child = e;
		MAKE_STRING_NODE(arg_name, i->name);
		e->next_sibling = arg_name;
		ret->warning = ngs_strdup("Using deprecated key/value arrow syntax for external function call argument of the form f() k => v");
		$$ = ret;
	}

function-call-arguments-without-parens =
	acc:args-node
	(
		arg:function-call-argument { append_ast_node_child(acc, $$); }
		(items-separator arg:function-call-argument { append_ast_node_child(acc, $$); } )*
	)* {
		$$ = acc;
		CAPTURE_LOCATION($$);
	}

args-node = { MAKE_NODE(ret, ARGS_NODE); $$ = ret; }

function-call-argument =
	i:identifier space? "=" space? e:expression {
		MAKE_NODE(ret, ARG_NODE);
		ret->first_child = e;
		MAKE_STRING_NODE(arg_name, i->name);
		e->next_sibling = arg_name;
		$$ = ret;
	}
	|
	"**" space? e:expression {
		MAKE_NODE(ret, ARG_NODE);
			MAKE_NODE(splat, HASH_SPLAT_NODE);
				splat->first_child = e;
			ret->first_child = splat;
		$$ = ret;
	}
	|
	"*" space? e:expression {
		MAKE_NODE(ret, ARG_NODE);
			MAKE_NODE(splat, ARR_SPLAT_NODE);
				splat->first_child = e;
			ret->first_child = splat;
		$$ = ret;
	}
	|
	e:expression {
		MAKE_NODE(ret, ARG_NODE);
		ret->first_child = e;
		$$ = ret;
	}

array-literal =
		"[" space? "]" {
				MAKE_NODE(ret, ARR_LIT_NODE);
				$$ = ret;
		}
		| "[" space? items:array-items space? ","? space? "]" {
				$$ = items;
				CAPTURE_LOCATION($$);
		}

array-items =
		acc:array-literal-node array-item { append_ast_node_child(acc, $$); } (items-separator array-item { append_ast_node_child(acc, $$); })* {
			$$ = acc;
			CAPTURE_LOCATION($$);
		}

array-item =
	"*" space? e:expression {
		MAKE_NODE(ret, ARR_SPLAT_NODE);
			ret->first_child = e;
		$$ = ret;
	}
	| expression

array-literal-node = {
		MAKE_NODE(ret, ARR_LIT_NODE);
		$$ = ret;
}

imm-array-literal =
		"%[" space? "]" {
				MAKE_NODE(ret, ARR_LIT_NODE);
				$$ = ret;
		}
		| "%[" ws:imm-array-words space? "]" {
				MAKE_NODE(ret, ARR_LIT_NODE);
				ret->first_child = ws->first_child->next_sibling->first_child;
				$$ = ret;
				CAPTURE_LOCATION($$);
		}

imm-array-words = acc:command-words-node (
		space?
		(
			array-command-word {
				append_ast_node_child(acc->first_child->next_sibling, $$);
			}
		)
	)+ {
	$$ = acc;
	CAPTURE_LOCATION($$);
}


hash-literal =
		"{" space? "}" {
				MAKE_NODE(ret, HASH_LIT_NODE);
				$$ = ret;
		}
		| "{" space? items:hash-items space? ","? space? "}" {
				$$ = items;
		}

hash-items =
		acc:hash-literal-node hash-item { append_ast_node_child(acc, $$); } (items-separator hash-item { append_ast_node_child(acc, $$); })* {
			$$ = acc;
			CAPTURE_LOCATION($$);
		}

hash-item =
		"**" space? e:expression {
			MAKE_NODE(ret, HASH_SPLAT_NODE);
			ret->first_child = e;
			$$ = ret;
		}
		|
		k:expression space? ":" space? v:expression {
			MAKE_NODE(ret, EXPRESSIONS_NODE);
			ret->first_child = k;
			ret->last_child = v;
			k->next_sibling = v;
			$$ = ret;
		}

hash-literal-node = {
		MAKE_NODE(ret, HASH_LIT_NODE);
		$$ = ret;
}

imm-hash-literal =
		"%{" space? "}" {
				MAKE_NODE(ret, HASH_LIT_NODE);
				$$ = ret;
		}
		| "%{" ws:imm-hash-words space? "}" {
				MAKE_NODE(ret, HASH_LIT_NODE);
				ast_node *p, *kv;
				(void) kv; // "Unused variable warning". Dunno why.
				for(p = ws->first_child->next_sibling->first_child; p; p=p->next_sibling) {
					if(p->type == HASH_SPLAT_NODE) {
						append_ast_node_child(ret, p);
						continue;
					}
					MAKE_NODE(kv, EXPRESSIONS_NODE);
					append_ast_node_child(kv, p);
					p = p->next_sibling;
					assert(p); // should be there, imm-hash-words should ensure that
					append_ast_node_child(kv, p);
					append_ast_node_child(ret, kv);
				}
				$$ = ret;
				CAPTURE_LOCATION($$);
		}

imm-hash-words = acc:command-words-node (
		space?
		(
			hash-command-word {
				append_ast_node_child(acc->first_child->next_sibling, $$);
			}
		)
		space
		(
			hash-command-word {
				append_ast_node_child(acc->first_child->next_sibling, $$);
			}
		)
	)+ {
	$$ = acc;
	CAPTURE_LOCATION($$);
}

tree-literal = "\\" i:identifier-as-text n:tree-node (inline_space? attr:identifier-as-text inline_space? "=" inline_space? e:expression {
		MAKE_NODE(kv, EXPRESSIONS_NODE);
		kv->first_child = attr;
		kv->last_child = e;
		attr->next_sibling = e;

		append_ast_node_child(n->first_child->next_sibling->first_child->first_child, kv);
	})* (inline_space? arr:array-literal {
		n->first_child->next_sibling->first_child->next_sibling->first_child = arr;
	})? {
		MAKE_REQ_ARG_NODE(a0, i);
		a0->next_sibling = n->first_child->next_sibling->first_child;
		n->first_child->next_sibling->first_child = a0;
	$$ = n;
	CAPTURE_LOCATION($$);
}

tree-node = {
	MAKE_NODE(ret, CALL_NODE);
		MAKE_IDENTIFIER_NODE(func, "\\");
		MAKE_NODE(args, ARGS_NODE);
			MAKE_NODE(h, HASH_LIT_NODE);
			MAKE_REQ_ARG_NODE(a1, h);
			MAKE_NODE(arr, ARR_LIT_NODE);
			MAKE_REQ_ARG_NODE(a2, arr);
			a1->next_sibling = a2;
			args->first_child = a1;
		ret->first_child = func;
		func->next_sibling = args;
	$$ = ret;
	CAPTURE_LOCATION($$);

}

abc-function-literal = c:curly-code-block {
	$$ = wrap_in_func(c, 0, location, "ABC function literal", 1, 3, "A", "Any", "B", "Any", "C", "Any");
}

for =
	for-i-n
	|
	for-start-cond-incr
	|
	for-in

for-start-cond-incr =
	"for" space? "(" init:code-block ";" space? cond:code-block space? ";" space? incr:code-block space? ")" space? body:code-block {
		MAKE_NODE(ret, FOR_NODE);
		init->next_sibling = cond;
		cond->next_sibling = incr;
		incr->next_sibling = body;
		ret->first_child = init;
		$$ = ret;
	}

for-i-n =
	"for" space? "(" space? i:identifier space? ";" space? e:code-block space? ")" space? body:code-block {
		MAKE_NODE(ret, FOR_NODE);

			MAKE_NODE(init_node, ASSIGNMENT_NODE);
			ret->first_child = init_node;
				COPY_NODE(init_node->first_child, i);
				ALLOC_NODE(init_node->first_child->next_sibling, INT_NODE);
				init_node->first_child->next_sibling->number = 0;

			MAKE_NODE(cond_node, CALL_NODE);
			init_node->next_sibling = cond_node;
				ALLOC_NODE(cond_node->first_child, IDENTIFIER_NODE);
				cond_node->first_child->name = "<";
				MAKE_NODE(cond_args, ARGS_NODE);
					MAKE_NODE(cond_arg1, ARG_NODE);
						COPY_NODE(cond_arg1->first_child, i);
						cond_arg1->first_child->next_sibling = NULL;
					MAKE_NODE(cond_arg2, ARG_NODE);
						COPY_NODE(cond_arg2->first_child, e);
						cond_arg2->first_child->next_sibling = NULL;
					cond_arg1->next_sibling = cond_arg2;
					cond_args->first_child = cond_arg1;
				cond_node->first_child->next_sibling = cond_args;

			MAKE_NODE(incr_node, ASSIGNMENT_NODE);
			cond_node->next_sibling = incr_node;

				COPY_NODE(incr_node->first_child, i);

				MAKE_NODE(incr_plus_node, CALL_NODE);
				incr_node->first_child->next_sibling = incr_plus_node;
					ALLOC_NODE(incr_plus_node->first_child, IDENTIFIER_NODE);
					incr_plus_node->first_child->name = "+";

					MAKE_NODE(incr_plus_args, ARGS_NODE);
						MAKE_NODE(incr_plus_arg1, ARG_NODE);
							COPY_NODE(incr_plus_arg1->first_child, i);
							incr_plus_arg1->first_child->next_sibling = NULL;
						MAKE_NODE(incr_plus_arg2, ARG_NODE);
							ALLOC_NODE(incr_plus_arg2->first_child, INT_NODE);
							incr_plus_arg2->first_child->number = 1;
							incr_plus_arg2->first_child->next_sibling = NULL;
						incr_plus_arg1->next_sibling = incr_plus_arg2;
						incr_plus_args->first_child = incr_plus_arg1;
					incr_plus_node->first_child->next_sibling = incr_plus_args;

			incr_node->next_sibling = body;

		$$ = ret;
	}

for-in =
	"for" space? v:identifier space "in" space e:code-block space? body:code-block {
		MAKE_NODE(ret, EXPRESSIONS_NODE);

			// v_iter = Iter(e)
			MAKE_NODE(iter_assignment, ASSIGNMENT_NODE);
				// Not sure exposing the ..._iter variable like this is a good idea
				MAKE_IDENTIFIER_NODE(iter_var, ngs_strcat(v->name, "_iter"));
				append_ast_node_child(iter_assignment, iter_var);
				MAKE_NODE(iter_call, CALL_NODE);
					MAKE_IDENTIFIER_NODE(iter_identifier, "Iter");
					append_ast_node_child(iter_call, iter_identifier);
					MAKE_NODE(iter_call_args, ARGS_NODE);
						MAKE_REQ_ARG_NODE(iter_call_arg_e, e);
						append_ast_node_child(iter_call_args, iter_call_arg_e);
					append_ast_node_child(iter_call, iter_call_args);
				append_ast_node_child(iter_assignment, iter_call);
			append_ast_node_child(ret, iter_assignment);

			// while v_iter { ... }
			MAKE_NODE(while_iter, WHILE_NODE);

				MAKE_IDENTIFIER_NODE(while_cond, ngs_strcat(v->name, "_iter"));
				while_iter->first_child = while_cond;

				MAKE_NODE(while_body, EXPRESSIONS_NODE);

					// v = next(v_iter)
					MAKE_NODE(var_assignment, ASSIGNMENT_NODE);
						append_ast_node_child(var_assignment, v);
						MAKE_NODE(next_call, CALL_NODE);
							MAKE_IDENTIFIER_NODE(next_identifier, "next");
							append_ast_node_child(next_call, next_identifier);
							MAKE_NODE(next_call_args, ARGS_NODE);
								MAKE_IDENTIFIER_NODE(next_call_arg_iter_identifier, ngs_strcat(v->name, "_iter"));
								MAKE_REQ_ARG_NODE(next_call_arg_iter, next_call_arg_iter_identifier);
								append_ast_node_child(next_call_args, next_call_arg_iter);
							append_ast_node_child(next_call, next_call_args);
						append_ast_node_child(var_assignment, next_call);
					append_ast_node_child(while_body, var_assignment);

					// body
					append_ast_node_child(while_body, body);

				while_cond->next_sibling = while_body;
			append_ast_node_child(ret, while_iter);

		// print_ast(ret, 0);
		$$ = ret;
	}

if =
	"if" !identifier-continuation space? cond:code-block (space "then")? space? yes:code-block no:if-optional-else-block {
		MAKE_NODE(ret, IF_NODE);
		ret->first_child = cond;
		cond->next_sibling = yes;
		yes->next_sibling = no;
		$$ = ret;
	}

if-optional-else-block =
	(space? "else" space?)? inline_space? c:code-block { $$ = c; }
	|
	{ MAKE_NODE(ret, NULL_NODE); $$ = ret; }

while =
	"while" !identifier-continuation space? cond:code-block space? body:code-block {
		MAKE_NODE(ret, WHILE_NODE);
		ret->first_child = cond;
		cond->next_sibling = body;
		$$ = ret;
	}

switch =
	acc:any-switch !identifier-continuation space? datum:code-block { append_ast_node_child(acc, datum) } space? "{"
		(
			space? e:expression space? c:code-block {
				MAKE_NODE(case_node, EXPRESSIONS_NODE);
					append_ast_node_child(case_node, e);
					append_ast_node_child(case_node, c);
				append_ast_node_child(acc, case_node);
			}
		)+
	space? "}" {
		$$ = acc;
	}

cond =
	acc:any-cond { MAKE_NODE(dummy, NULL_NODE); append_ast_node_child(acc, dummy) } space? "{"
		(
			space? e:code-block space? c:code-block {
				MAKE_NODE(case_node, EXPRESSIONS_NODE);
					append_ast_node_child(case_node, e);
					append_ast_node_child(case_node, c);
				append_ast_node_child(acc, case_node);
			}
		)+
	space? "}" {
        // First element of acc is NULL_NODE for unifority of data layout inside acc with "swicth"
		$$ = acc;
	}

any-switch = switch-keyword | eswitch-keyword | match-keyword | ematch-keyword

switch-keyword  = "switch"  { MAKE_NODE(ret, SWITCH_NODE); ret->number = SWITCH_NODE_SWITCH;  $$ = ret; }
eswitch-keyword = "eswitch" { MAKE_NODE(ret, SWITCH_NODE); ret->number = SWITCH_NODE_ESWITCH; $$ = ret; }
match-keyword   = "match"   { MAKE_NODE(ret, SWITCH_NODE); ret->number = SWITCH_NODE_MATCH;   $$ = ret; }
ematch-keyword  = "ematch"  { MAKE_NODE(ret, SWITCH_NODE); ret->number = SWITCH_NODE_EMATCH;  $$ = ret; }

any-cond =  cond-keyword | econd-keyword
cond-keyword    = "cond"    { MAKE_NODE(ret, SWITCH_NODE); ret->number = SWITCH_NODE_COND;    $$ = ret; }
econd-keyword   = "econd"   { MAKE_NODE(ret, SWITCH_NODE); ret->number = SWITCH_NODE_ECOND;   $$ = ret; }


number = 
	<[-+]?"0x"[0-9a-fA-F]+> ! ([a-zA-Z] | "." [0-9a-fA-F]) {
		MAKE_NODE(ret, INT_NODE);
		ret->number = strtol(yytext, NULL, 16);
		$$ = ret;
	}
	|
	<[-+]?[0-9]+[.][0-9]+> ! ([a-zA-Z] | "." [0-9]) {
		MAKE_NODE(ret, REAL_NODE);
		ret->data = NGS_MALLOC(sizeof(NGS_REAL));
		*(NGS_REAL *)ret->data = strtod(yytext, NULL);
		$$ = ret;
	}
	|
	<[-+]?[0-9]+> ! ([a-zA-Z] | "." [0-9])  {
		MAKE_NODE(ret, INT_NODE);
		ret->number = atol(yytext);
		$$ = ret;
	}

super = "super" { MAKE_NODE(ret, SUPER_NODE); $$ = ret; }

identifier =
	<[_a-zA-Z]+[_a-zA-Z0-9]*> {
		MAKE_NODE(ret, IDENTIFIER_NODE);
		ret->name = ngs_strdup(yytext);
		$$ = ret;
	}
	| "('" <([-|=!@?<>~+*/%()$a-zA-Z0-9.`: ]|"["|"]")+> "')" {
		MAKE_NODE(ret, IDENTIFIER_NODE);
		ret->name = ngs_strdup(yytext);
		$$ = ret;
	}
	| "(" <("$()" | "$[]" | [-|=!@?~+*/%$<>.\[\]:]+ | "is not" | "not in")> ")" {
		MAKE_NODE(ret, IDENTIFIER_NODE);
		ret->name = ngs_strdup(yytext);
		$$ = ret;
	}

identifier-continuation = <[_a-zA-Z0-9]+>

var-scope-declaration-keyword =
	"local" { MAKE_NODE(ret, LOCAL_NODE); $$ = ret }
	| "upvar" { MAKE_NODE(ret, UPVAR_NODE); $$ = ret }
	| "global" { MAKE_NODE(ret, GLOBAL_NODE); $$ = ret }

var-scope-declaration =
	l:var-scope-declaration-keyword space var-scope-declaration-item { append_ast_node_child(l, $$); } (space? "," space? var-scope-declaration-item { append_ast_node_child(l, $$); })* {
		$$ = l;
		CAPTURE_LOCATION($$);
	}

var-scope-declaration-item = i:identifier e:var-scope-declaration-item-optional-value {
		if(!e) {
			$$ = i;
			return;
		}
		MAKE_NODE(ret, ASSIGNMENT_NODE);
		i->next_sibling = e;
		ret->first_child = i;
		$$ = ret;
	}

var-scope-declaration-item-optional-value = (space? "=" space? e:expression) { $$ = e } | { $$ = NULL; }

string = string-sq | string-dq

string-sq =
	"'" acc:str-comps-node (
		string-sq-imm { append_ast_node_child(acc, $$); } |
		string-escape { append_ast_node_child(acc, $$); } )* "'" {
		$$ = acc;
	}

string-dq =
	"\"" acc:str-comps-node (
		string-dq-imm { append_ast_node_child(acc, $$); } |
		string-escape { append_ast_node_child(acc, $$); } |
		string-dq-dollar-expansion { append_ast_node_child(acc, $$); })* "\"" {
		acc = string_node_partial_application(acc, location);
		$$ = acc;
	}

string-sq-imm =
	<[^\'\\]+> {
		MAKE_NODE(content, STR_COMP_IMM_NODE);
		content->name = ngs_strdup(yytext);
		$$ = content;
	}

string-dq-imm =
	<[^$\"\\]+> {
		MAKE_NODE(content, STR_COMP_IMM_NODE);
		content->name = ngs_strdup(yytext);
		$$ = content;
	}

string-dq-dollar-expansion =
	s:subshell                 { MAKE_NODE(ret, STR_COMP_EXPANSION_NODE); append_ast_node_child(ret, s); $$ = ret; }
	| "$"  v:identifier        { MAKE_NODE(ret, STR_COMP_EXPANSION_NODE); append_ast_node_child(ret, v); $$ = ret; }
	| "$"  c:curly-code-block  { MAKE_NODE(ret, STR_COMP_EXPANSION_NODE); append_ast_node_child(ret, c); $$ = ret; }
	| "$*" v:identifier        { MAKE_NODE(ret, STR_COMP_SPLAT_EXPANSION_NODE); append_ast_node_child(ret, v); $$ = ret; }
	| "$*" c:curly-code-block  { MAKE_NODE(ret, STR_COMP_SPLAT_EXPANSION_NODE); append_ast_node_child(ret, c); $$ = ret; }

# https://en.wikipedia.org/wiki/Escape_sequences_in_C
string-escape = "\\" (
		"a"  { MAKE_NODE(content, STR_COMP_IMM_NODE); content->name = ngs_strdup("\a"); $$ = content; } |
		"b"  { MAKE_NODE(content, STR_COMP_IMM_NODE); content->name = ngs_strdup("\b"); $$ = content; } |
		"e"  { MAKE_NODE(content, STR_COMP_IMM_NODE); content->name = ngs_strdup("\x1B"); $$ = content; } |
		"f"  { MAKE_NODE(content, STR_COMP_IMM_NODE); content->name = ngs_strdup("\f"); $$ = content; } |
		"n"  { MAKE_NODE(content, STR_COMP_IMM_NODE); content->name = ngs_strdup("\n"); $$ = content; } |
		"r"  { MAKE_NODE(content, STR_COMP_IMM_NODE); content->name = ngs_strdup("\r"); $$ = content; } |
		"t"  { MAKE_NODE(content, STR_COMP_IMM_NODE); content->name = ngs_strdup("\t"); $$ = content; } |
		"\\" { MAKE_NODE(content, STR_COMP_IMM_NODE); content->name = ngs_strdup("\\"); $$ = content; } |
		"'"  { MAKE_NODE(content, STR_COMP_IMM_NODE); content->name = ngs_strdup("\'"); $$ = content; } |
		"\"" { MAKE_NODE(content, STR_COMP_IMM_NODE); content->name = ngs_strdup("\""); $$ = content; } |
		"$"  { MAKE_NODE(content, STR_COMP_IMM_NODE); content->name = ngs_strdup("$"); $$ = content; }
	)

str-comps-node = {
		MAKE_NODE(ret, STR_COMPS_NODE);
		$$ = ret;
}

regexp =
	"/" acc:str-comps-node (
		regexp-imm { append_ast_node_child(acc, $$); } |
		regexp-escape { append_ast_node_child(acc, $$); } )* "/" flags:regexp-flags {
		MAKE_NODE(ret, REGEXP_NODE);
			append_ast_node_child(ret, acc);
			append_ast_node_child(ret, flags);
		$$ = ret;
	}

regexp-imm =
	<[^/\\]+> {
		MAKE_NODE(content, STR_COMP_IMM_NODE);
		content->name = ngs_strdup(yytext);
		$$ = content;
	}

regexp-escape = "\\" (
		"/"  { MAKE_NODE(content, STR_COMP_IMM_NODE); content->name = ngs_strdup("/"); $$ = content; } |
		<.>  {
			MAKE_NODE(content, STR_COMP_IMM_NODE);
				content->name = NGS_MALLOC_ATOMIC(3);
				content->name[0] = '\\';
				content->name[1] = yytext[0];
				content->name[2] = 0;
			$$ = content;
		}
	)

regexp-flags = <[a-zA-Z0-9]*> {
		MAKE_NODE(ret, STR_COMPS_NODE);
			MAKE_NODE(content, STR_COMP_IMM_NODE);
			content->name = ngs_strdup(yytext);
			append_ast_node_child(ret, content);
		$$ = ret;
	}



return = "return" r:return-node (inline_space e:expression { r->first_child = e; })? { $$ = r; }
return-node = {
	MAKE_NODE(ret, RETURN_NODE);
		MAKE_NODE(ret_value_null, NULL_NODE);
		ret->first_child = ret_value_null;
	$$ = ret;
}

break = "break" { MAKE_NODE(ret, BREAK_NODE); $$ = ret; }
continue = "continue" { MAKE_NODE(ret, CONTINUE_NODE); $$ = ret; }

collector = "collector" init:collector-init space c:code-block {
		MAKE_NODE(ret, CALL_NODE);
			MAKE_IDENTIFIER_NODE(collector_identifier, "collector");
			MAKE_NODE(args, ARGS_NODE);
				MAKE_REQ_ARG_NODE(a1, init);
				MAKE_REQ_ARG_NODE(a2, wrap_in_func(c, 0, location, "Collector syntax body", 0, 1, "collect", "Any"));
				a1->next_sibling = a2;
				args->first_child = a1;
			ret->first_child = collector_identifier;
			collector_identifier->next_sibling = args;
		$$ = ret;
		CAPTURE_LOCATION($$);
	};

collector-init =
	"/" e:expression { $$ = e; }
	| { MAKE_NODE(arr, ARR_LIT_NODE); $$ = arr; }

block = "block" space i:identifier space c:code-block {
	MAKE_NODE(ret, CALL_NODE);
		MAKE_IDENTIFIER_NODE(block_identifier, "block");
		MAKE_NODE(args, ARGS_NODE);
			MAKE_REQ_ARG_NODE(a1, wrap_in_func(c, 0, location, "Block syntax body", 0, 1, ngs_strdup(i->name), "Any"));
			args->first_child = a1;
		ret->first_child = block_identifier;
		block_identifier->next_sibling = args;
	$$ = ret;
	CAPTURE_LOCATION($$);	
}

section = "section" space name:string space c:code-block {
	MAKE_NODE(ret, SECTION_NODE);
	ret->first_child = name;
	ret->first_child->next_sibling = c;
	$$ = ret;
	CAPTURE_LOCATION($$);
}

guard = "guard" space c:code-block {
	MAKE_NODE(ret, GUARD_NODE);
	ret->first_child = c;
	$$ = ret;
}

try-catch = "try" space acc:try-catch-node c:code-block { append_ast_node_child(acc, $$); }
	(space? "catch" space? "(" space? params:function-definition-parameters space? ")" space? body:code-block {
		MAKE_NODE(ret, FUNC_NODE);
		MAKE_STRING_NODE(doc, "Try ... catch syntax, catch clause");
		ret->first_child = params;
		params->next_sibling = body;
		append_ast_node_child(acc, ret);

		// --- Name the catch clause - start ---
		// Assumption: there will not be a lot of catch() clauses so it will work reasonably fast
		char name_buf[256];
		int n;
		ast_node *p;
		// TODO: maybe something better than loop?
		for(p=acc->first_child, n=0; p; p=p->next_sibling) {
			n++;
		}
		// TODO: Check whether naming the wrapping function here causes it to be registered with it's name.
		//       This is undesirable (and might lead to bugs?)
		snprintf(name_buf, sizeof(name_buf)-1, "<catch-clause-%d>", n-1);
		MAKE_IDENTIFIER_NODE(catch_identifier, name_buf);
		body->next_sibling = doc;
		doc->next_sibling = catch_identifier;
		// --- Name the catch clause - end ---
	})*
	{
	$$ = acc;
	CAPTURE_LOCATION($$);
}

try-catch-node = { MAKE_NODE(ret, TRY_CATCH_NODE); $$ = ret; }

throw = "throw" space e:expression { MAKE_NODE(ret, THROW_NODE); ret->first_child = e; $$ = ret; }

# type MyType => MyType = Type('MyType')
# TODO: Style warning for identifiers starting with lower case letter
type = doc:optional-doc inline_space? "type" space i:identifier inline_space? opt_args:optional-function-call-arguments {
	MAKE_NODE(ret, ASSIGNMENT_NODE);
		MAKE_NODE(call, CALL_NODE);
			MAKE_IDENTIFIER_NODE(type_identifier, "Type");
			call->first_child = type_identifier;
			MAKE_STRING_NODE(type_string, ngs_strdup(i->name));
			MAKE_REQ_ARG_NODE(a1, type_string);

			MAKE_REQ_ARG_NODE(a2, doc);
			a1->next_sibling = a2;

			MAKE_NODE(ns, GET_NS_NODE);
			MAKE_REQ_ARG_NODE(a3, ns);
			a2->next_sibling = a3;

			if(opt_args->type != NULL_NODE) {
				a3->next_sibling = opt_args->first_child;
				opt_args->first_child = a1;
				type_identifier->next_sibling = opt_args;
			} else {
				MAKE_NODE(args, ARGS_NODE);
					args->first_child = a1;
					type_identifier->next_sibling = args;
			}
		ret->first_child = i;
		i->next_sibling = call;
	$$ = ret;
	CAPTURE_LOCATION($$);
}

optional-function-call-arguments =
	function-call-arguments
	| { MAKE_NODE(no, NULL_NODE); $$ = no; }

subshell =
	"$(" cmd:commands-pipeline ")" { $$ = cmd; }
	| "$[" cmd:commands-pipeline "]" { $$ = cmd; cmd->first_child->name = ngs_strdup("$[]"); $$ = cmd; }
	| "%(" cmd:commands-pipeline ")" { cmd->first_child->name = ngs_strdup("%()"); $$ = cmd; }
	| "``" cmd:commands-pipeline "``" { cmd->first_child->name = ngs_strdup("````"); $$ = cmd; }
	| "`" cmd:commands-pipeline "`" { cmd->first_child->name = ngs_strdup("``");  $$ = cmd; }

commands-pipeline = inline_space? acc:commands-pipeline-node
	(
		o:commands-pipeline-option {
			append_ast_node_child(acc->first_child->next_sibling->next_sibling->next_sibling, o);
		}
		inline_space?
	)*
	(
		(
			(
				p:commands-pipe {
					append_ast_node_child(acc->first_child->next_sibling->next_sibling, p);
				}
			) | {
				MAKE_NODE(p2, NULL_NODE);
				append_ast_node_child(acc->first_child->next_sibling->next_sibling, p2);
			}
		)
		inline_space?
	)
	c1:command-words {
		append_ast_node_child(acc->first_child->next_sibling, c1);
	}
	(
		p:commands-pipe {
			append_ast_node_child(acc->first_child->next_sibling->next_sibling, p);
		}
		inline_space?
		c:command-words {
			append_ast_node_child(acc->first_child->next_sibling, c);
		}
		inline_space?
	)*
	(
		(
			p:commands-pipe {
				append_ast_node_child(acc->first_child->next_sibling->next_sibling, p);
			}
		) | {
			MAKE_NODE(p2, NULL_NODE);
			append_ast_node_child(acc->first_child->next_sibling->next_sibling, p2);
		}
		inline_space?
	)
	("&" {
		MAKE_NODE(option, EXPRESSIONS_NODE);
			MAKE_STRING_NODE(option_k, "&");
			append_ast_node_child(option, option_k);
			MAKE_NODE(option_v, TRUE_NODE);
			append_ast_node_child(option, option_v);
		append_ast_node_child(acc->first_child->next_sibling->next_sibling->next_sibling, option);
	} inline_space? )? {
	$$ = acc;
	CAPTURE_LOCATION($$);
}

commands-pipeline-node = {
	MAKE_NODE(ret, COMMANDS_PIPELINE_NODE);
		MAKE_IDENTIFIER_NODE(f, "$()");
		append_ast_node_child(ret, f);
		MAKE_NODE(commands, ARR_LIT_NODE);
		append_ast_node_child(ret, commands);
		MAKE_NODE(pipes, ARR_LIT_NODE);
		append_ast_node_child(ret, pipes);
		MAKE_NODE(options, HASH_LIT_NODE);
		append_ast_node_child(ret, options);
	$$ = ret;
}

commands-pipe = <"|"> {
	MAKE_NODE(ret, COMMANDS_PIPE_NODE);
		MAKE_STRING_NODE(name, yytext);
		append_ast_node_child(ret, name);
		MAKE_NODE(options, HASH_LIT_NODE);
		append_ast_node_child(ret, options);
	$$ = ret;
}

commands-pipeline-option =
	i:identifier "::" (
		e:expression {
			MAKE_NODE(ret, EXPRESSIONS_NODE);
				MAKE_STRING_NODE(option_k, i->name);
				append_ast_node_child(ret, option_k);
				append_ast_node_child(ret, e);
			$$ = ret;
		}
		| {
			MAKE_NODE(ret, EXPRESSIONS_NODE);
				MAKE_STRING_NODE(option_k, i->name);
				append_ast_node_child(ret, option_k);
				MAKE_NODE(option_v, TRUE_NODE);
				append_ast_node_child(ret, option_v);
			$$ = ret;
		}
	)

command-words = acc:command-words-node
	(
		o:command-option {
			append_ast_node_child(acc->first_child->next_sibling->next_sibling->next_sibling, o);
		}
		inline_space?
	)*
	(
		(
			command-redirect {
				append_ast_node_child(acc->first_child->next_sibling->next_sibling, $$);
			}
		|
			command-word {
				append_ast_node_child(acc->first_child->next_sibling, $$);
			}
		)
		inline_space?
	)+ {
	$$ = acc;
	CAPTURE_LOCATION($$);
}

command-words-node = {
	MAKE_NODE(ret, COMMAND_NODE);
		MAKE_IDENTIFIER_NODE(f, "$()");
		append_ast_node_child(ret, f);
		MAKE_NODE(argv, EXPRESSIONS_NODE);
		append_ast_node_child(ret, argv);
		MAKE_NODE(redirects, EXPRESSIONS_NODE);
		append_ast_node_child(ret, redirects);
		MAKE_NODE(options, HASH_LIT_NODE);
		append_ast_node_child(ret, options);
	$$ = ret;
}


unquoted-basic-command-word-node = {
	MAKE_NODE(ret, STR_COMPS_NODE);
	$$ = ret;
}


unquoted-basic-command-word = acc:unquoted-basic-command-word-node (

	<[-+a-zA-Z0-9/=,._@:]+> {
		MAKE_NODE(s, STR_COMP_IMM_NODE); \
		s->name = ngs_strdup(yytext); \
		append_ast_node_child(acc, s);
	}
	| esc:string-escape { append_ast_node_child(acc, esc); }
	| e:string-dq-dollar-expansion { append_ast_node_child(acc, e); }
)+ {
	$$ = acc;
}

basic-command-word = string | unquoted-basic-command-word

command-word =
	"$*" c:code-block {
		MAKE_NODE(splat, ARR_SPLAT_NODE);
			splat->first_child = c;
		$$ = splat;
	}
	| "$" c:curly-code-block { $$ = c; }
	| "$" i:identifier { $$ = i; }
	| basic-command-word

array-command-word =
	number
	| command-word
	| imm-array-literal
	| imm-hash-literal

hash-command-word =
	number
	| command-word
	| imm-array-literal
	| imm-hash-literal
	| "$**" c:code-block {
		MAKE_NODE(splat, HASH_SPLAT_NODE);
			splat->first_child = c;
		$$ = splat;
	}

command-option =
	i:identifier ":" (
		e:expression {
			MAKE_NODE(ret, EXPRESSIONS_NODE);
				MAKE_STRING_NODE(option_k, i->name);
				append_ast_node_child(ret, option_k);
				append_ast_node_child(ret, e);
			$$ = ret;
		}
		| {
			MAKE_NODE(ret, EXPRESSIONS_NODE);
				MAKE_STRING_NODE(option_k, i->name);
				append_ast_node_child(ret, option_k);
				MAKE_NODE(option_v, TRUE_NODE);
				append_ast_node_child(ret, option_v);
			$$ = ret;
		}
	)

command-redirect =
	rfd:redir-fd rm:redir-marker inline_space? dst:command-word {
		MAKE_NODE(ret, REDIR_NODE);
		append_ast_node_child(ret, rfd);
		append_ast_node_child(ret, rm);
		append_ast_node_child(ret, dst);
		$$ = ret;
	}

redir-fd = <[0-9]+> {
		MAKE_NODE(ret, INT_NODE);
		ret->number = atoi(yytext);
		$$ = ret;
	}
	| { MAKE_NODE(ret, NULL_NODE); $$ = ret; }

redir-marker =
	<(">>" | ">" | "<<" | "<")> { MAKE_STRING_NODE(ret, yytext); $$ = ret; }

PRINT_AST = "PRINT_AST" space e:expression {
	printf("PRINTING AST\n");
	print_ast(e, 0);
	$$ = e;
}

%%
#undef ALLOC_NODE
#undef MAKE_NODE
#undef COPY_NODE
#undef MAKE_REQ_ARG_NODE
#undef PREPEND_NODE
#undef HANDLE_FAILED_MATCH
#pragma GCC diagnostic pop

// TODO: more efficient implementation
void position_to_line_col(yycontext *yy, int pos, int result[]) {
	int line;
	result[0] = -1;
	result[1] = -1;
	for(line=yy->lines; line>=0; line--) {
		if(yy->lines_postions[line] <= pos) {
			result[0] = line+1;
			result[1] = pos-yy->lines_postions[line]+1;
			return;
		}
	}
}
