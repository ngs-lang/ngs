ns(TL=Timeline, TCTI=TextualCommandTimelineItem) {
	# WIP
	global init, JsonData

	_cp = require("aws/CodePipeline.ngs")

	# TODO:
	# * Recreate previous version but cleanly
	# * Move transformation to table from shell.ngs to this file
	# * Add row/object-fields semantics
	# * Consider add nested context to render()
	# * UI action should have
	#	* Reference to the original command and the output
	#   * ID of the object
	#   * Action name

	type Element()

		type Screen(Element)
		type Timeline(Element)
		type TimelineItem(Element)
		type Object(Element)

		type Scalar(Element)
		type Table(Element)
			type Columns(Element)
			type Column(Element)
			type Rows(Element)
			type Row(Element)
			# TODO: Cell
		type Properties(Element)
		type List(Element)
		type ProcessStatus(Element)
		type Progress(Element)

	F raw(h:Hash) {'$type': '$raw'} + h

	F init(e:Element, children:Arr) {
		children.assert(Repeat(Element), "All children of Element must be of type Element. Have ${children}")
		init(args())
	}
	# TODO: serialization design
	F JsonData(e:Element) {
		# Note: all Element subtypes need to reside in this namespace
		#       if they don't, there could be name collisions
		{'$type': e.Type().name} + e.Hash().JsonData()
	}

	F JsonData(p:Properties) {
		{'$type': p.Type().name} + p.Hash().JsonData()::{A.props = {'$type': 'Hash'} + A.props}
	}

	F init(s:Scalar, value) init(args())
	F init(c:Column, name:Str) init(args())
	F init(p:Properties, props:Hash) init(args())
	F init(p:ProcessStatus, name:Str, text:Str) init(args())  # TODO: improve + add semantics
	F init(p:Progress, step:Int, total_steps:Int) init(args())


	F Element(x:AnyOf(Num, Str, Bool, Null)) Scalar(x)
	F Element(a:AnyOf(Arr, ArrLike)) List(a.map(Element))

	F init(r:Row, fields_names, h:AnyOf(Hash, HashLike)) {
		super(r)
		r.children = fields_names.map(F(field_name) {
			val = h.get(field_name)
			Element(val)
		})
	}

	# TODO: improve heuristics of detection when to render to table
	F Element(a:Arr) {
		guard a =~ Repeat(AnyOf(Hash, HashLike), 1..null)

		fields_names = a.map(keys).flatten().uniq()  # TODO: make fields order configurable?

		if a[0] is _cp::Pipeline {
			fields_names .= reject('last_execution_id')  # Temp hack
		}

		Table().set(
			columns = fields_names.map(Column).Columns()
			rows = a.map(Row(fields_names, X)).Rows()
		)
	}

	F keys_are_strings(h) h.keys().all(Str)
	F Element(h:AnyOf(Hash, HashLike)) Properties(h.assert(keys_are_strings, "Element(Hash) - keys must be strings").mapv(Element))

	F Element(tcti:TCTI) {
		tcti.command.Element()
	}

	F Element(tl:TL) {
		Timeline(tl.items.map(Element))
	}

	# TODO: Fix later. It's semantically incorrect to display path as just a string
	F Element(p:Path) Scalar(p.path)

	section "ProcessesPipeline" {
		# TODO: Use AbstractProcess
		F Element(pp:ProcessesPipeline) {
			processes = pp.processes
			guard processes
			p = processes[-1]
			{ p.stdout.decode({'process': p}) }.Result().dflt({
				error("In shell.ngs, trying to decode:")
				print_exception(A.val)
				# throw InvalidArgument("Element() could not decode process output").set(process=p)
				p.stdout  # TODO: maybe split into lines
			}).get().Element()
		}
	}

	section "AWS" {
		# TODO: Move whatever possible from CodePipeline.ngs to AbstractProcess.ngs

		# WIP
		# Think: it's probably not always the case that Status should be a UI object
		F Element(s:AbstractProcess::Status::Status) {
			Object([
				ProcessStatus(s.Type().name, s.text)
			])
		}

		# TODO: .total_steps might not be known
		F Element(p:_cp::Progress) Progress(p.step, p.total_steps)

		F Element(cp:_cp::Pipeline) {
			throw NotImplemented("Converting AWS CodePipeline to arbitrary Element is not implemented yet")
		}

		# WIP
		F init(r:Row, fields_names:Arr, pipeline:_cp::Pipeline) {
			super(r, fields_names, pipeline)
			idx = Iter(0..null)
			idxs = fields_names.Hash({idx.next()})  # Ex: {name=0, status=1, sources=2, revisions=3, last_executed=4, approvals=5, progress=6}
			r.children.filter(Object).each(F(o) o.cur = raw({'type': 'AWS::CodePipeline::Pipeline', 'id': pipeline.name}))
			for k in %[status last_executed progress] {
				r.children[idxs[k]].when(Object, {
					# Later: A.action = 'navigate'
					# For now, deduce that "ref" means navigate
					A.ref = raw({'type': 'AWS::CodePipeline::Execution', 'id': pipeline.last_execution_id})
				})
			}
		}

		# Later
		F Element(r:_cp::Revision) Element(Str(r))
		F Element(s:_cp::Source) Element(Str(s))
		F Element(a:_cp::Action) Element(Str(a))
	}

	# ngs -ppj 'require("aws/CodePipeline.ngs")::pipelines::list().(ui::Element)'
	# ngs -ppj '$(ls).(ui::Element)'
}
