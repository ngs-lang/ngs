ns(GlobalRes=Res, GlobalResDef=ResDef) {

	# Documentation hack as documentation for namespaces

	doc Amazon Web Services. This namespace is under development. Use at your own risk.
	doc This namespace contains resource types that implement common methods: find(), create(), delete(), converge()
	doc AMI_OWNER_DEBIAN - The string "379101102735"
	doc AMI_OWNER_AMAZON - The string "801119661308"
	F _doc() {

	}

	_exports.meta(_doc.Arr()[0].meta())

	# TODO: alert or handle somehow the special case when anchor properties are changed,
	#       this might be a programming error.

	# TODO: track newly added resources and provide a method to list them or have a callback

	# TODO: Use JSON tags. Currently special symbols in tag name or value will cause problems.
	# http://docs.aws.amazon.com/cli/latest/userguide/shorthand-syntax.html

	# TODO: log describe AWS CLI commands too

	# Methods with added implementations
	global Str, init, find, latest, create, update, delete, users_ids, run, id, ids, (==), code

	# --------------------------------------------------
	# Constants
	# --------------------------------------------------

	# From https://wiki.debian.org/Cloud/AmazonEC2Image/Jessie
	AMI_OWNER_DEBIAN = '379101102735'
	AMI_OWNER_AMAZON = '801119661308'
	INSTANCE_STATES = %[pending running shutting-down terminated stopping stopped]
	# VOLUME_STATES = %[creating available in-use deleting deleted error]
	# SNAPSHOT_STATES = %[pending completed error]
	_SNAPSHOT_AMI_RE = /^Created by CreateImage.* for (ami-[a-z0-9]+)/
	_REGION_RE = /^[a-z]{2,3}-[a-z]{2,20}-[0-9]+$/
	_AZ_RE = /^([a-z]{2,3}-[a-z]{2,20}-[0-9]+)([a-z])$/

	# --------------------------------------------------
	# Misc utilities
	# --------------------------------------------------

	doc Convert hash to Key=...,Value=... strings suitable for passing to AWS CLI.
	doc %RET - Arr of Str
	doc %EX - diff = Diff(current_tags, target_tags)
	doc %EX - if (tags = cli_tags(diff.add + diff.change)) {
	doc %EX - 	r.run('add tags', %(aws ec2 create-tags --resources ${r.id()} --tags $*tags))
	doc %EX - }
	F cli_tags(h:Hash) h / "Key=$X,Value=$Y"

	doc Convert Hash with AWS filters to command line arguments.
	doc Key-value pairs in which value is null or an EmptyBox object are discarded.
	doc TODO: make it JSON when keys or values contain special characters such as = or ,
	doc %RET - Arr of Str
	F cli_filters(h:Hash) {
		unboxed = h.rejectv(NoData).mapv(only(Box, get)).reject(X == [])
		unboxed.mapv(only(Pfx, { "${A.val}*" })).mapv(only(Arr, X.join(","))).map("Name=$X,Values=$Y")
	}

	TEST AWS2::cli_filters({}) == []
	TEST AWS2::cli_filters({"x": "y", "z": null, "w": FullBox("ww")}) == ['Name=x,Values=y', 'Name=w,Values=ww']
	TEST AWS2::cli_filters({"x": Pfx("aa"), "z": EmptyBox()}) == ['Name=x,Values=aa*']

	doc Convert hash to Name=tag:...,Values=... strings suitable for passing to AWS CLI as filters.
	doc %EX - filters = AWS2::cli_filters({'vpc-id': ...})
	doc %EX - vpcs = ``aws ec2 describe-vpcs --filters $*filters``
	F cli_tags_filters(h:Hash) h / "Name=tag:$X,Values=$Y"
	TEST AWS2::cli_tags_filters({}) == []
	TEST AWS2::cli_tags_filters({"x": "y"}) == ['Name=tag:x,Values=y']

	_aws_cached_regions = null

	# --- regions ---
	_regions = cached({
		if r = ENV.Box('NGS_AWS_REGIONS').map(X.split(',')).get(null) {
			debug("AWS", "Regions: Using NGS_AWS_REGIONS environment variable with value $r")
			r
		} else {
			``aws ec2 describe-regions``.RegionName.sort()
		}
	})
	doc Get list of AWS regions. If NGS_AWS_REGIONS environment variable is set, it is used as comma separated list. Otherwise AWS CLI command describe-regions is used.
	doc In future, the results of AWS CLI call might be cached.
	F regions() _regions()

	doc Call cb in parallel threads, each with AWS region name as argument.
	doc cb - Must return an array. regions() sets ._Region in the result and flattens the results
	doc %RET - Arr
	doc %EX - ins = AWS2::regions({ ``aws ec2 describe-instances --region $A $*filters`` })
	F regions(cb:Fun) {
		regs = regions()
		regs.pmap(F(r) {
			data = cb(r)
			data._Region = r
			data
		}).flatten()
	}

	# --- zones ---
	# TODO: support regions
	_zones = cached({ ``aws ec2 describe-availability-zones``.ZoneName.sort() })
	doc Internal method. Please do not use. It does not support regions yet.
	doc %STATUS - internal
	doc %RET - Arr of Str
	F zones() _zones()


	# --------------------------------------------------
	# CreateOnly
	# --------------------------------------------------

	doc A Box for a property which is to be used only at creation time, not when a resource is updated
	type CreateOnly(FullBox)

	# --------------------------------------------------
	# Res
	# --------------------------------------------------

	doc AWS resource
	type Res(GlobalRes)

	# TODO: always output at least ID of the creates resources
	#       because if update() fails the resourcs is difficult to find
	doc Run a command. Internal method. Please do not use outside the AWS library.
	doc %STATUS - internal
	F run(r:Res, log_pfx:Str, cp:CommandsPipeline, do_decode=true) r.def.run("${r} ${log_pfx}", cp, do_decode)

	F _diff_tags(current_tags:Hash, target_tags:Hash) {
		# target_tags.mapv(typeof).echo()
		d = HashDiff()
		d.add = target_tags.rejectv(NoData).reject(X in current_tags)
		d.change = target_tags.rejectv(NoData).filter(X in current_tags).filter(F(k, v) current_tags[k] != v)
		d.remove = target_tags.filterv(NoData).keys().filter(X in current_tags)
		d
	}

	doc Don't call directly, use converge(). API subject to change.
	doc Update tags using AWS CLI "aws ec2 create-tags" and "aws ec2 delete-tags".
	doc The required AWS CLI is computed from current tags in r.props.Tags, and desired tags in r.def.anchor.Tags and props.Tags
	doc %RET - Do not count on this value.
	F _update_tags(r:Res, props:Hash) {
		target_tags = r.def.anchor.get('Tags', {}) + props.get('Tags', {})
		current_tags = r.props.get('Tags', {})

		debug('AWS', "Current tags: $current_tags. Target tags: $target_tags (from anchor and properties)")
		diff = _diff_tags(current_tags, target_tags)

		if (tags = cli_tags(diff.add + diff.change)) {
			r.run('adding tags', %(aws ec2 create-tags --resources ${r.id()} --tags $*tags))
		}

		if (tags = diff.remove.map("Key=$X")) {
			r.run('removing tags', %(aws ec2 delete-tags --resources ${r.id()} --tags $*tags))
		}
	}

	doc Get unique identifier of a resource
	doc %EX - AWS2::Instance().find().resources[0].id()  # i-0011b2.....
	F id(r:Res) {
		r.props.(r.def.typeof().user.id)
	}

	# --------------------------------------------------
	# ResDef
	# --------------------------------------------------

	doc AWS Resource definition
	type ResDef(GlobalResDef)

	doc Initialize ResDef from kw. Defaults: null for ._Region and empty hash for .Tags
	F init(rd:ResDef, **kw) {
		if '_RelatedTo' in kw {
			rd.related_to = kw._RelatedTo
			kw.del('_RelatedTo')
			rd.related_to.ensure_array().each(F(rel) {
				prop = rd.typeof().user.related_to[rel.typeof()]
				kw.(prop) = rel
			})
		}
		super(rd, {'_Region': null, 'Tags': {}} + kw)
	}

	doc Initialize ResDef from _ngs_tags. Sets ._Region to null and .Tags to _ngs_tags.
	F init(rd:ResDef, _ngs_tags:Hash) super(rd, {'_Region': null, 'Tags': _ngs_tags})

	doc Run an external command related to the resource definition. Will not run the command if rd.dry_run is true.
	doc do_decode - Whether to decode the output
	doc %RET - Either parsed output or finished CommandsPipeline (processes in CommandsPipeline finished)
	doc %STATUS - internal
	F run(rd:ResDef, log_pfx:Str, cp:CommandsPipeline, do_decode=true) {
		assert(cp.commands.len() == 1, "Don't know how to print pipeline")
		if rd.dry_run {
			rd.log(log_pfx, "would run: ${cp.commands[-1].argv.join(' ')}")
			null
		} else {
			rd.log(log_pfx, "running: ${cp.commands[-1].argv.join(' ')}")
			if do_decode {
				``$cp``
			} else {
				$($cp)
			}
		}
	}

	F _assert_anchor_has_only_known_keys(rd:ResDef, *known_keys) {
		rd.anchor.without('_Region', null).without('Tags', {}).each(F(k, v) {
			k not in known_keys throws InvalidArgument("Anchor contains unknown key '$k'. Known keys are: $known_keys")
		})
	}

	F _assert_props_has_only_known_keys(rd:ResDef, props:Hash, *known_keys) {
		props.without('META').each(F(k, v) {
			k not in known_keys throws InvalidArgument("Props contains unknown key '$k'. Known keys are: $known_keys")
		})
	}

	# --------------------------------------------------
	# Parameter
	# --------------------------------------------------

	doc A Box for a property which is to be used only at creation time, not when a resource is updated
	type Parameter

		F init(p:Parameter, res_type:Type, param_name:Str, param_value) init(args())

	detect = Hook()

	# --------------------------------------------------
	# (updaters)
	# --------------------------------------------------

	F _make_one_at_a_time_list_updater(getter:Fun, add_command, remove_command, eq:Fun=(==)) {

		commands = {
			'add': add_command
			'remove': remove_command
		}

		F process_command(r:Res, command:Arr, item_to_add) {
			collector {
				command.each(F(c) {
					item = if c is Fun then c(item_to_add) else c
					item.ensure_array().each(collect)
				})
				if command.none(Fun) {
					collect(item_to_add)
				}
			}.replace('ID', r.id())
		}

		F list_updater(r:Res, target) {
			echo("list_updater() active")
			current_list = getter(r.props)
			echo("list_updater() current list: $current_list")
			target_list = ensure_array(target)
			diff = Diff(current_list, target_list, eq)
			echo("list_updater() diff: $diff")

			for op in %[add remove] {
				diff.(op).each(F(item) {
					cmd = process_command(r, commands[op], item)
					echo("list_updater() cmd: $cmd")
					result = r.def.run('Updating ' + r.def.typeof().user.display_name, %($*cmd))
				})
			}
		}
	}

	# --------------------------------------------------
	# (helpers)
	# --------------------------------------------------

	# Resolve ids of resources and use one
	_one_id = only(ResDef, the_one + ids)

	# --- filters helper ---
	F _make_filters_argv(rd:ResDef, filtersNamesToAnchorNames:Hash, transform:Hash={}) {
		h = filtersNamesToAnchorNames.mapv(F(anchor_name) {
			rd.anchor.Box(anchor_name).map(transform.get(anchor_name, identity))
		})
		Argv({
			'--filters':
				cli_filters(h) +
				rd.anchor.Tags.cli_tags_filters()
		})
	}

	# --------------------------------------------------
	# Declarative primitives methods
	# --------------------------------------------------

	F find(rd:ResDef) {
		type_user_data = rd.typeof().user
		allowed_keys_sources = %[find_props_to_filters find_props_to_args find_props_to_post_filters]
		allowed_keys = allowed_keys_sources.map(F(aks) type_user_data.get(aks, {}).keys()).flatten()
		if %[find_supports_tags find_tags_command_1].any(X in type_user_data) {
			allowed_keys .= push('Tags')
		}
		rd._assert_anchor_has_only_known_keys(*allowed_keys)

		find_props_filters = collector/{} type_user_data.get('find_props_to_filters', {}).each(F(anchor_name, filter_name) {
			v = rd.anchor.Box(anchor_name) # .map(transform.get(anchor_name, identity))
			# TODO: check that there is only one result?
			# TODO: maybe it's not id() that should be used in some cases?
			v .= map(only(ResDef, ids))
			collect(filter_name, v)
		})
		tags_filters = if type_user_data.get('find_supports_tags') {
			rd.anchor.Tags.cli_tags_filters()
		} else {
			[]
		}
		find_props_args = collector/{} type_user_data.get('find_props_to_args', {}).each(F(anchor_name, arg_name) {
			v = rd.anchor.Box(anchor_name)
			v .= map(only(ResDef, ids))
			collect(arg_name, v)
		})

		argv = Argv({ '--filters': cli_filters(find_props_filters) + tags_filters } + find_props_args)
		res_type = type_user_data.res_type
		rd.resources = ``$*{type_user_data.find_command} $*argv``.map(res_type(rd, X))
		type_user_data.Box('find_describe_command').each(F(cmd) {
			rd.resources.each(F(r) {
				argv = cmd + [id(r)]
				props = ``$*argv``
				if type_user_data.get('find_describe_remove_top_level_hash', false) {
					assert(props is Hash)
					assert(props.len() == 1)
					props = props.values().the_one()
				}
				props.each(F(k, v) {
					if k in r.props {
						assert(r.props[k] == v)
						return
					}
					r.props[k] = v
				})
			})
		})
		type_user_data.get('find_props_to_post_filters', {}).each(F(prop_name, dummy) {
			prop_name not in rd.anchor returns
			rd.resources .= reject(F(r) {
				r.props[prop_name] != rd.anchor[prop_name]
			})
		})
		rd
	}

	# TODO: give error when getting create only property not wrapped in CreateOnly
	F create(rd:ResDef, **orig_props) {
		props = orig_props.mapv(only(CreateOnly, get))
		type_user_data = rd.typeof().user
		allowed_keys = type_user_data.get('create_props_to_args', {}).keys() # + type_user_data.get('create_opt', [])
		if type_user_data.get('find_supports_tags') {
			allowed_keys .= push('Tags')
		}
		rd._assert_anchor_has_only_known_keys(*allowed_keys)
		required_keys = type_user_data.get('create_props_required', [])
		for k in required_keys {
			if not([props, rd.anchor].get(k)) {
				throw InvalidArgument("'$k' parameter is required when creating ${type_user_data.display_name}")
			}
		}
		argv = type_user_data.get('create_props_to_args', {}).mapkv(F(prop, arg) {
			if prop is Fun {
				return [arg, prop(rd)]
			}
			[arg, rd.opt_prop(prop, props).map(F(x) only(ResDef, ids)(x))]
		}).Argv()
		result = rd.run('Creating ' + rd.typeof().user.display_name, %($*{type_user_data.create_command} $*argv))
		rd.dry_run returns []
		if (result is Hash) and (result.len() == 1) {
			result = result.values()[0]
		}
		result = [result]

		# Some API calls (sg) only return the ID of the created resource
		result .= map(F(maybe_id) {
			maybe_id is not Str returns maybe_id
			q(maybe_id).map(identity).the_one()
		})

		result.each(F(h:Hash) {
			if 'Tags' in h {
				h.Tags .= Hash('Key', 'Value')
			}
		})
		res_type = type_user_data.res_type
		if not(rd.dry_run) {
			rd.created(result.map(res_type(rd, X)), orig_props)
		}
	}

	# TODO: Give better error when orig_props contains
	#       create only (unrecognized by update) property
	F update(r:Res, orig_props:Hash) {
		props = orig_props.rejectv(CreateOnly)
		type_user_data = r.def.typeof().user
		allowed_keys = type_user_data.get('update_methods', {}).keys()
		if type_user_data.get('find_supports_tags') {
			allowed_keys .= push('Tags')
		}
		r.def._assert_props_has_only_known_keys(props, *allowed_keys)
		if type_user_data.get('find_supports_tags') {
			r._update_tags(props)
		}
		props.without('Tags').each(F(k, v) {
			# update_how = type_user_data.update_methods[k]
			# current_list = update_how::current_list(r.props)
			# target_list = ensure_array(v)
			m = type_user_data.update_methods[k]
			m(r, v)
		})
	}

	F delete(r:Res) {
		type_user_data = r.def.typeof().user
		r.run('Deleting ' + type_user_data.display_name, %($*{type_user_data.delete_command} ${r.props.(type_user_data.id)}))
	}


	# --------------------------------------------------
	# Vpc
	# --------------------------------------------------

	type Vpc(ResDef)
	type VpcRes(Res)

	Vpc.user = %{
		prefix       vpc
		id           VpcId
		display_name VPC

		find_command          %[aws ec2 describe-vpcs]
		find_supports_tags    ${true}
		find_props_to_filters %{
			CidrBlock cidr
			IsDefault isDefault
			VpcId     vpc-id
			State     state
		}

		create_command       %[aws ec2 create-vpc]
		create_props_to_args %{
			CidrBlock --cidr-block
		}
		create_props_required %[CidrBlock]

		delete_command       %[aws ec2 delete-vpc --vpc-id]

		res_type     ${VpcRes}
	}

	# --- Extract VPC ID ---
	F _eval_vpc_id(x) x
	F _eval_vpc_id(rd:Vpc) rd.ids().the_one()

	# --------------------------------------------------
	# Internet Gateway
	# --------------------------------------------------

	type Igw(ResDef)
	type IgwRes(Res)

	Igw.user = %{
		prefix                igw
		id                    InternetGatewayId
		display_name          "Internet Gateway"

		find_command          %[aws ec2 describe-internet-gateways]
		find_supports_tags    ${true}
		find_props_to_filters %{
			InternetGatewayId  internet-gateway-id
			Attachments.VpcId  attachment.vpc-id
			State              state
		}

		create_command        %[aws ec2 create-internet-gateway]
		delete_command        %[aws ec2 delete-internet-gateway --internet-gateway-id]

		update_methods        %{
			Attachments.VpcId ${
				_make_one_at_a_time_list_updater(
					F get_current_list(props:Hash) props.Attachments.VpcId,
					%[aws ec2 attach-internet-gateway --internet-gateway-id ID --vpc-id],
					%[aws ec2 detach-internet-gateway --internet-gateway-id ID --vpc-id]
				)
			}
		}

		res_type              ${IgwRes}
	}

	# --------------------------------------------------
	# RouteTable (WIP)
	# --------------------------------------------------

	doc Internal type. Please do not use.
	doc %STATUS - internal
	type _RouteBox(FullBox)

	F _normalize(r:_RouteBox) r.get().without('Origin').without('State').sort()

	doc Internal method. Please do not use.
	doc %STATUS - internal
	doc %EX - # TODO: example
	F ==(a:_RouteBox, b:_RouteBox) _normalize(a) == _normalize(b)

	type RouteTable(ResDef)
	type RouteTableRes(Res)

	F _route_cidr(route) route.DestinationCidrBlock
	F _route_to_argv(route) {
		Argv({
			'--destination-cidr-block': route.DestinationCidrBlock
			'--gateway-id': route.get('GatewayId')
			'--instance-id': route.get('InstanceId')
			'--network-interface-id': route.get('NetworkInterfaceId')
			'--vpc-peering-connection-id': route.get('VpcPeeringConnectionId')
			'--nat-gateway-id': route.get('NatGatewayId')
		})
	}

	# CONTINUE HERE
	# TODO: Think of more efficient behaviour of "eq"
	# TODO: normalize_presence_list
	# TODO: support ResDef for GatewayId, InstanceId, maybe others
	RouteTable.user = %{
		prefix        rtb
		id            RouteTableId
		display_name "Routing Table"

		find_command          %[aws ec2 describe-route-tables]
		find_supports_tags    ${true}
		find_props_to_filters %{
			RouteTableId route-table-id
			VpcId        vpc-id
		}

		create_command       %[aws ec2 create-route-table]
		create_props_to_args %{
			VpcId --vpc-id
		}
		create_props_required %[VpcId]

		update_methods        %{
			Routes  ${
				_make_one_at_a_time_list_updater(
					F get_current_list(props:Hash) props.Routes,
					%[aws ec2 create-route --route-table-id ID $_route_to_argv],
					%[aws ec2 delete-route --route-table-id ID --destination-cidr-block $_route_cidr],
					eq = F(a,b) {
						F _normalize(x) x.without('Origin').without('State').sort()
						_normalize(a) == _normalize(b)
					}
				)
			}
		}

		delete_command        %[aws ec2 delete-route-table --route-table-id]

		res_type ${RouteTableRes}
	}

	# --------------------------------------------------
	# SecGroup
	# --------------------------------------------------

	type SecGroup(ResDef)
	type SecGroupRes(Res)

	SecGroup.user = %{
		prefix                sg
		id                    GroupId
		display_name          "Security Group"

		find_command          %[aws ec2 describe-security-groups]
		find_supports_tags    ${true}
		find_props_to_filters %{
			Description description
			GroupId          group-id
			GroupName        group-name
			VpcId            vpc-id
			OwnerId          owner-id
		}

		create_command       %[aws ec2 create-security-group]
		create_props_to_args %{
			Description      --description
			GroupName        --group-name
			VpcId            --vpc-id
		}
		create_props_required %[Description GroupName]


		res_type     ${SecGroupRes}
	}

		# delete_command       %[aws ec2 delete-vpc --vpc-id]

	doc Initialize SecGroup from security group name and vpc.
	doc %EX - AWS2::SecGroup("https-server", AWS2::Vpc(...))
	F init(rd:SecGroup, GroupName:Str, VpcId) {
		guard VpcId is Str or VpcId is Vpc
		super(rd, GroupName=GroupName, VpcId=VpcId)
	}

	F users_ids(r:SecGroup) r.resources.map(F(res) {
		{
			'GroupId': res.props.GroupId
			'UserId': res.props.OwnerId
		}
	})

	doc Internal type. Please do not use.
	doc %STATUS - internal
	type _IpPermBox(FullBox)

	# Cleans up AWS Security Group IpPermissions so it's possible to compare current and desired states of IpPermissions
	# TODO: cleanup FromPort -1 & ToPort -1
	F _cleanup(x:_IpPermBox) {
		ret = x.val
		ret .= filter(F(k, v) (v is not Arr) or v)
		ret .= without('IpRanges', [{"CidrIp": "0.0.0.0/0"}])
		ret .= without('Ipv6Ranges', [{"CidrIpv6": "::/0"}])
		if 'UserIdGroupPairs' in ret {
			# Hash is ordered.
			ret.UserIdGroupPairs .= map(sort)
		}
		ret
	}

	doc Internal method. Please do not use.
	doc %STATUS - internal
	F ==(a:_IpPermBox, b:_IpPermBox) {
		a .= _cleanup()
		b .= _cleanup()
		a.len() != b.len() returns false
		not(Diff(a, b))
	}

	doc Declarative primitive for updating AWS Security Group resources
	doc %STATUS - internal
	F update(sg:SecGroupRes, props:Hash) {

		debug("AWS", "${sg} Updating SG")

		if 'IpPermissions' in props {
			# PrefixListIds - http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_IpPermission.html
			# (Valid for AuthorizeSecurityGroupEgress, RevokeSecurityGroupEgress and DescribeSecurityGroups only)
			# sg.props.IpPermissions.each(F(perm) perm.del('PrefixListIds'))
			target_perms = normalize_presence_list(props.IpPermissions)
			target_perms.each(F(r) r.val .= _IpPermBox())
			diff = Diff(sg.props.IpPermissions/_IpPermBox, target_perms, full=true)

			if diff.add {
				sg.run('add SG ingress rules', %(aws ec2 authorize-security-group-ingress --group-id ${sg.props.GroupId} --ip-permissions $*{diff.add.val / encode_json}))
			}
			if diff.remove {
				sg.run('remove SG ingress rules', %(aws ec2 revoke-security-group-ingress --group-id ${sg.props.GroupId} --ip-permissions $*{diff.remove.val / encode_json}))
			}
		}

		if 'IpPermissionsEgress' in props {
			diff = Diff(sg.props.IpPermissionsEgress/_IpPermBox, props.IpPermissionsEgress/_IpPermBox, full=true)
			if diff.add {
				sg.run('add SG egress rules', %(aws ec2 authorize-security-group-egress --group-id ${sg.props.GroupId} --ip-permissions $*{diff.add.val / encode_json}))
			}
			if diff.remove {
				sg.run('remove SG egress rules', %(aws ec2 revoke-security-group-egress --group-id ${sg.props.GroupId} --ip-permissions $*{diff.remove.val / encode_json}))
			}
		}

		sg._update_tags(props)
	}

	doc Declarative primitive for deleting AWS Security Group resources
	F delete(r:SecGroupRes) {
		r.run('Delete security group', %(aws ec2 delete-security-group --group-id ${r.props.GroupId}))
	}

	# --------------------------------------------------
	# Subnet
	# --------------------------------------------------

	doc Declarative primitive for referencing AWS Subnet resources.
	doc Supported anchor items: VpcId (required for creation), Tags, CidrBlock (required for creation), AvailabilityZone.
	doc Supported properties: Tags.
	type Subnet(ResDef)
	doc Single declarative primitive resource describing AWS Subnet
	type SubnetRes(Res)

	# XXX: change to new layout and use the generic find() and create() above
	Subnet.user = %{
		prefix subnet
		id     SubnetId
	}

	doc Declarative primitive for finding AWS Subnet resources
	F find(rd:Subnet) {
		debug("AWS", "Find Subnet ${rd}")
		rd._assert_anchor_has_only_known_keys('Tags', 'VpcId', 'CidrBlock', 'AvailabilityZone')
		filters = ['--filters'] +? ( rd.anchor.Tags.cli_tags_filters() + cli_filters({
			'vpc-id':             rd.anchor.Box('VpcId').map(_eval_vpc_id)
			'cidr':               rd.anchor.Box('CidrBlock')
			'availability-zone':  rd.anchor.Box('AvailabilityZone')
		}))
		rd.resources = ``aws ec2 describe-subnets $*filters``.map(SubnetRes(rd, X))
		rd
	}

	# TODO: Support multiple subnets so one could easily set up new VPC for RDS and ELB
	# TODO: Migrate to Argv
	doc Declarative primitive for creating AWS Subnet resources
	doc %STATUS - internal
	F create(rd:Subnet, **props) {
		rd._assert_props_has_only_known_keys(props, 'VpcId', 'CidrBlock', 'AvailabilityZone')
		vpcid = rd.req_prop('VpcId', props)._eval_vpc_id()
		cidr = rd.req_prop('CidrBlock', props)
		az = rd.opt_prop('AvailabilityZone', props).map({ ['--availability-zone', A] }).get([])
		result = rd.run('Create Subnet', %(aws ec2 create-subnet --vpc-id $vpcid --cidr-block $cidr $*az))
		rd.resources = rd.resources or []
		if not(rd.dry_run) {
			filters = cli_filters({'subnet-id': result.Subnet.SubnetId})
			rd.created(``aws ec2 describe-subnets --filters $*filters``.map(SubnetRes(rd, X)), props)
		}
	}

	doc Declarative primitive for updating AWS Subnet resources
	doc %STATUS - internal
	F update(r:SubnetRes, props:Hash) {
		debug("AWS", "${r} Updating Subnet")
		r.def._assert_props_has_only_known_keys(props, 'Tags')
		r._update_tags(props)
	}

	doc Declarative primitive for deleting AWS Subnet resources
	F delete(r:SubnetRes) {
		r.run('Delete Subnet', %(aws ec2 delete-subnet --subnet-id ${r.props.SubnetId}))
	}

	# --------------------------------------------------
	# Image
	# --------------------------------------------------

	doc Declarative primitive for referencing AWS AMI resources.
	doc Supported anchor items: State (defaults to "available"), OwnerId, Name (Str or Pfx), RootDeviceType, VirtualizationType (defaults to hvm), VolumeType, ImageId.
	doc Supported properties: (not supported yet).
	type Image(ResDef)
	doc Single declarative primitive resource describing AWS AMI
	type ImageRes(Res)

	Image.user = %{
		prefix ami
		id     ImageId
	}


	# debian-jessie-amd64-hvm
	doc Declarative primitive for finding AWS AMI resources
	F find(rd:Image) {
		debug("AWS", "Find Image ${rd}")
		rd._assert_anchor_has_only_known_keys('OwnerId', 'Name', 'State', 'RootDeviceType', 'VirtualizationType', 'VolumeType', 'ImageId', 'Tags')
		args = Argv({
			'--owners': rd.anchor.Box('OwnerId')
			'--filters': rd.anchor.Tags.cli_tags_filters() + cli_filters({
				'state':                            rd.anchor.get('State', 'available')
				'virtualization-type':              rd.anchor.get('VirtualizationType', 'hvm')
				'name':                             rd.anchor.Box('Name').filter({A is Str or A is Pfx})
				'root-device-type':                 rd.anchor.Box('RootDeviceType')
				'block-device-mapping.volume-type': rd.anchor.Box('VolumeType')
				'image-id':                         rd.anchor.Box('ImageId')
				})
		})
		resources = ``aws ec2 describe-images $*args``
		if 'Name' in rd.anchor and rd.anchor.Name is Pfx {
			resources .= filter({A.Name ~ rd.anchor.Name})
		}
		rd.resources = resources / ImageRes(rd, X)
		debug("AWS", "found ${resources.len()} ${rd.typeof().name} resources")
		rd
	}

	# TODO: convert it to something more uniform,
	#       a property in Anchor for example, so one
	#       could just select the latest image with Anchor
	doc Declarative primitive for referencing latest AWS AMI resources. Will probably be reworked to be special anchor item.
	doc %EX - AWS2::Image(OwnerId=AWS_AMI_OWNER_DEBIAN, Name=Pfx('debian-jessie-amd64-hvm'), RootDeviceType='ebs', VolumeType='gp2').latest()
	F latest(rd:Image) {
		rd.find_if_needed()
		assert(rd.resources.len() >= 1, "Can not find latest() image because there are no images")
		rd.resources = [rd.resources.sort({ A.props.CreationDate <= B.props.CreationDate })[-1]]
		rd
	}

	# --------------------------------------------------
	# Instance
	# --------------------------------------------------

	# TODO: State property (now assuming "running")

	doc Declarative primitive for referencing AWS Instance resources.
	doc Supported anchor items: VpcId, State (defaults to pending and running, pass "*" for all states except shutting-down and terminated, pass null for all states), InstanceId, ImageId (required for creation), KeyName, SubnetId, InstanceType, PublicIpAddress (Bool), PrivateIpAddresses, UserData
	doc Supported properties: Tags, SecurityGroups, State (running/stopped), SourceDestCheck.
	type Instance(ResDef)
	doc Single declarative primitive resource describing AWS Instance
	type InstanceRes(Res)

	Instance.user = %{
		prefix         i
		id             InstanceId
		columns_order  %[InstanceId tag_Name tag_env tag_role IPs InstanceType State KeyName SecurityGroups AZ RestOfTags]
	}

	detect.instance_state = F(x) {
		x not in INSTANCE_STATES returns null
		Parameter(Instance, 'State', x)
	}

	# TODO: use botocore/data/ec2/DATE/service-2.json
	detect.instance_type = F(x) {
		not(x ~ /^[a-z]+[0-9]+[.][0-9]*[a-z]+$/) returns null
		Parameter(Instance, 'InstanceType', x)
	}

	# TODO: regions?
	# TODO: availability zones?
	# TODO: IPs

	doc Initialize Instance (ResDef) from kwargs
	F init(rd:Instance, **kwargs) {
		t = {} + kwargs
		t.State = kwargs.get('State', %[pending running])
		if t.State is NoData {
			t.State = INSTANCE_STATES - ['shutting-down', 'terminated']
		}
		if t.State == '*' {
			t.State = null
		}
		super(rd, **t)
	}

	doc Declarative primitive for finding AWS Instance resources
	F find(rd:Instance) {
		debug("AWS", "Find Instance ${rd}")
		instance_ids = rd.anchor.get('InstanceId')
		rd.anchor.Box('_Elb').each(F(elb) {
			assert(rd.anchor._Elb is Elb, "_Elb must be of type AWS2::Elb")
			instance_ids = elb.map(F(elb) elb.Instances).flatten()
		})
		rd.anchor.Box('_Eip').each(F(eip) {
			assert(rd.anchor._Eip is Eip, "_Eip must be of type AWS2::Eip")
			instance_ids = eip.get('InstanceId').without('')  # '' can happen in "standard" domain
		})
		if instance_ids == [] {
			rd.resources = []
			return
		}
		filters = Argv({
			'--instance-ids': instance_ids
			'--filters': rd.anchor.Tags.cli_tags_filters() + cli_filters({
				'instance-state-name': rd.anchor.get('State')
				'vpc-id': rd.anchor.Box('VpcId').map(only(ResDef, ids)).map(the_one)
				'block-device-mapping.volume-id': rd.anchor.Box('_VolumeId').map(only(ResDef, ids))
			})
		})

		debug("AWS2::Instance", "Filters: $filters")

		regs = cond {
			rd.anchor._Region is Arr { rd.anchor._Region }
			rd.anchor._Region == '*' { regions() }
		}

		resources = if regs {
			instances = regs.pmap(F(r) {
				ins = ``aws ec2 describe-instances --region $r $*filters``
				ins._Region = r
				ins
			}).flatten()
			# .filter(F(i) try i.PublicIpAddress)
		} else {
			``aws ec2 describe-instances $*filters``
		}

		if regs {
			debug("AWS", "found ${resources.len()} ${rd.typeof().name} resources in ${resources.group({A._Region}).len()} regions (${resources.group({A.Placement.AvailabilityZone}).len()} zones)")
		} else {
			debug("AWS", "found ${resources.len()} ${rd.typeof().name} resources in ${resources.group({A.Placement.AvailabilityZone}).len()} zones")
		}

		rd.resources = resources / InstanceRes(rd, X)
		rd
	}

	# TODO: Support multiple NICs?
	# TODO: ImageId should be able to be in props too, not just anchor
	doc Declarative primitive for creating AWS Instance resources
	doc %STATUS - internal
	F create(rd:Instance, **props) {
		rd.log('create', 'Instance')
		for prop_name in %[ImageId] {
			prop_name not in rd.anchor throws InvalidArgument("Anchor must contain $prop_name when creating an instance")
		}

		args = Argv({
			'--image-id':            rd._image_id()
			'--key-name':            rd.opt_prop('KeyName', props)
			'--security-group-ids':  _sgs(rd, props).map(F(sgs) Diff([], sgs).add)
			'--subnet-id':           rd.opt_prop('SubnetId', props).map(only(ResDef, ids))
			'--instance-type':       rd.opt_prop('InstanceType', props)
			['--associate-public-ip-address', '--no-associate-public-ip-address']: rd.opt_prop('PublicIpAddress', props)
			'--private-ip-address':  rd.opt_prop('PrivateIpAddress', props)
			'--user-data':           rd.opt_prop('UserData', props)
		})


		result = rd.run('Create Instance', %(aws ec2 run-instances $*args))
		if not(rd.dry_run) {
			# warn("INSTANCES: ${result.Instances / InstanceRes(rd, X)}")
			rd.created(result.Instances / InstanceRes(rd, X), props)
		}
	}

	# TODO: Support EC2 classic?
	doc Declarative primitive for updating AWS Instance resources
	doc %STATUS - internal
	F update(r:InstanceRes, props:Hash) {
		debug("AWS", "${r} Update Instance")
		r._update_tags(props)

		# TODO: make SecurityGroups work with Presence
		if 'SecurityGroups' in props {
			current_sgs = r.props.SecurityGroups.GroupId
			target_sgs = _sgs(r.def, props).get()
			diff = Diff(current_sgs, target_sgs)
			if diff {
				diff.add    % { debug('AWS', "${r} - Adding SG $A") }
				diff.remove % { debug('AWS', "${r} - Removing SG $A") }
				sgs_to_set = current_sgs - diff.remove + diff.add
				r.run('Set security groups', %(aws ec2 modify-instance-attribute --instance-id ${r.id()} --groups $*sgs_to_set))
			}
		}

		# TODO: make this call for all instances of ResDef at once, not one by one
		if 'State' in props {
			a = r.props.State.Name
			b = props.State

			econd {
				a == b { "nothing to do" }
				a == "pending" and b == "running" { "nothing to do"}
				a == "stopped" and b == "running" {
					r.run('Starting instance', %(aws ec2 start-instances --instance-ids ${r.id()}))
				}
				a == "stopping" and b == "stopped" { "nothing to do" }
				a == "running" and b == "stopped" {
					r.run('Stopping instance', %(aws ec2 stop-instances --instance-ids ${r.id()}))
				}
				true throw InvalidArgument("Don't know how to transition instances state from $a to $b").set('value', b)
			}
		}

		# TODO: merge all modify-instance-attribute calls
		if 'SourceDestCheck' in props and props.SourceDestCheck != r.props.SourceDestCheck {
			args = Argv({
				['--source-dest-check', '--no-source-dest-check']: props.SourceDestCheck
			})
			r.run('Set SourceDestCheck', %(aws ec2 modify-instance-attribute --instance-id ${r.id()} $*args))
		}

		if 'InstanceType' in props and props.InstanceType != r.props.InstanceType {
			r.run('Change instance type', %(aws ec2 modify-instance-attribute --instance-id ${r.id()} --instance-type ${props.InstanceType}))
		}
	}

	doc Declarative primitive for deleting AWS Instance resources
	F delete(r:InstanceRes) {
		r.run('Terminate instance', %(aws ec2 terminate-instances --instance-ids ${r.id()}))
	}

	# TODO: Support EC2 classic?
	# TODO: Handle SGS in Anchor?
	F _sgs(rd:Instance, props:Hash) {
		rd.opt_prop('SecurityGroups', props).map(F(sgs) {
			normalize_presence_list(if sgs is Arr then sgs else [sgs]).map(F(sg) {
				# TODO: Converting Presence(Arr) to [Presence] should be in stdlib
				# XXX: [sg] is not right, not the same type!
				arr = if sg.val is ResDef then sg.val.expect().ids() else [sg]
				# arr = sg.filter(ResDef).map(ids + expect).get([sg])
				t = sg.typeof()
				arr.map(t)
			}).flatten()
		})
	}

	F _image_id(rd:Instance) {
		guard rd.anchor.ImageId is Image
		assert(rd.anchor.ImageId.resources.len() == 1, "Expecting exacty one image described by Image resource definition")
		rd.anchor.ImageId.ids()[0]
	}

	F _image_id(rd:Instance) {
		guard rd.anchor.ImageId is Str
		rd.anchor.ImageId
	}

	# TODO: handle _Region
	doc Declarative primitive for waiting for AWS Instance resource to reach given state
	doc state_name - typeically "running" or "stopped" (less common)
	doc %RET - r
	F wait_state(r:InstanceRes, state_name:Str) {
		retry(
			sleep = 5
			logger = debug("AWS", X)
			title = "[waiting intstance ${r.id()} to be in state $state_name]"
			body = {
				# When we enter wait_state, the instance might already by in
				# the desired state.
				r.props.State.Name == state_name returns true
				debug("AWS", "Instance ${r.id()} state is ${r.props.State.Name}")
				r.props = ``aws ec2 describe-instances --instance-ids ${r.id()}``[0]
				r.props.State.Name == state_name returns true
			}
		)
		r
	}

	# TODO: cache the results for example if add_to_known_hosts is run twice in a row
	#       once for PublicIpAddress and once for PrivateIpAddress
	doc Declarative primitive for getting console output of AWS Instance resource
	F get_console_output(r:InstanceRes) {
		retry(
			sleep = 5
			title = "[waiting intstance ${r.id()} to have console output]"
			logger = debug("AWS", X)
			title = "[waiting intstance ${r.id()} console output]"
			body = {
				``aws ec2 get-console-output --instance-id ${r.id()}``.Box('Output').map(lines).get(null)
			}
		)
	}

	# TODO: cache ssh key fingerprints somewhere in the cloud, maybe in tags
	#       so it will be available when they are not in the console anymore
	doc Declarative primitive for getting ssh host fingerprints of AWS Instance resource
	doc %RET - Array of Str. Each Str format "key-type base64key"
	F get_ssh_host_keys(r:InstanceRes) {
		# Observed bahviour, which might not always be true: when console output is ready, it already has the needed output
		r.get_console_output()["-----BEGIN SSH HOST KEY KEYS-----".."-----END SSH HOST KEY KEYS-----"].map({A.split(' ')[0..2].join(' ')})
	}

	doc Declarative primitive for adding ssh host fingerprints of AWS Instance resource to
	doc known hosts.
	doc %STATUS - experimental
	F add_to_known_hosts(r:Instance, prop_name:Str) {
		# TODO: consider making it in parallel
		for res in r {
			wait_state(res, 'running')
			add_to_known_hosts(res, res.props.(prop_name))
		}
	}

	# TODO: factor out parts that could work for other clouds/VMs
	doc Declarative primitive for adding ssh host fingerprints of AWS Instance resource to
	doc known hosts.
	doc %STATUS - experimental
	F add_to_known_hosts(r:InstanceRes, ip_or_hostname) {
		f = ENV.get('NGS_KNOWN_HOSTS', ENV.HOME / '.ssh' / 'known_hosts')
		keys_from_console = r.get_ssh_host_keys()
		for k in keys_from_console {
			debug("AWS", "SSH key from console of ${r.id()} - $k")
		}
		scanned_keys = $(ssh-keyscan -H $ip_or_hostname 2>/dev/null).lines()
		scanned_keys_parts_to_compare = scanned_keys.map({A.split(' ')[1..3].join(' ')})
		# echo("S $keys_from_console, $scanned_keys")
		if d = Diff(keys_from_console, scanned_keys_parts_to_compare) {
			# throw SecurtyFail(
			throw Exception("Scanned SSH keys and SSH keys from console did not match").set('diff', d)
		}
		# echo("SCANNED $scanned_keys")

		for k in scanned_keys {
			debug("AWS", "Scanned key of ${r.id()} at ${ip_or_hostname} - $k")
		}

		listed_keys = try {
			$(ssh-keygen -F $ip_or_hostname -f $f).lines().reject(/^#/)
		} catch(pf:ProcessFail) {
			guard pf.process.exit_code = 1
			[]
		}
		listed_keys_parts_to_compare = listed_keys.map({A.split(' ')[1..3].join(' ')})

		if not(Diff(listed_keys_parts_to_compare, scanned_keys_parts_to_compare)) {
			debug("AWS", "Scanned keys of ${r.id()} at ${ip_or_hostname} and keys in file are the same, no update needed")
			return
		}

		# debug("AWS", "Removing keys of ${ip_or_hostname} from file $f")
		if listed_keys {
			r.run("Removing keys of ${ip_or_hostname} from file $f", %(ssh-keygen -R $ip_or_hostname -f $f), do_decode=false)
		}

		for k in scanned_keys {
			r.run("Adding key ${k.limit(20, '...')} to file $f", %(echo $k >>$f), do_decode=false)
		}

	}

	doc EXPERIMENTAL! Do not use!
	doc Converts Instance resources to NGS code.
	doc Right now it works in the most primitive way.
	doc %STATUS - experimental
	F code(r:InstanceRes) {
		warn("You are using EXPERIMENTAL code(InstanceRes)")
		p = r.props
		anchor = {
			'ImageId': p.ImageId
			'InstanceType': p.InstanceType
			'KeyName': p.KeyName
		}
		# TODO: UserData
		# Maybe TODO: PrivateIpAddress
		# TODO: EIP p.NetworkInterfaces.PrivateIpAddresses.flatten().get('Association').Bool()
		props = {
			'SecurityGroups': p.SecurityGroups.GroupId
			'SubnetId': p.SubnetId
			'Tags': p.Tags
		}
		F _eq(h:Hash) h.map(F(k,v) "${k}=${code(v)}").join(', ')
		"AWS2::Instance(${_eq(anchor)}).create(${_eq(props)})"
	}

	# --------------------------------------------------
	# Elb
	# --------------------------------------------------

	# Should id() return "elb-..." ?
	# Get rid of synthetic "Name" property?
	doc Declarative primitive for referencing AWS Elastic Load Balancer resources.
	doc Supported anchor items: LoadBalancerName, Name (required for creation, synthetic, probably will be removed), Tags, ListenerDescriptions (can not be used for lookup but required for creation), Subnets (can not be used for lookup but required for creation), AvailabilityZones (not implemented yet).
	doc Supported properties: Tags, Instances, SecurityGroups, ListenerDescriptions
	type Elb(ResDef)
	doc Single declarative primitive resource describing AWS Elastic Load Balancer
	type ElbRes(Res)

	Elb.user = %{
		prefix              elb
		prefix_is_synthetic ${true}
		id                  LoadBalancerName
	}

	# TODO: Fix exception when describe-tags had no --load-balancer-names to work with
	doc Declarative primitive for finding AWS Elastic Load Balancer resources
	F find(rd:Elb) {
		debug("AWS", "Find ELB ${rd}")
		filters = Argv({
			'--load-balancer-names': rd.anchor.Box('LoadBalancerName')
		})
		resources = ``aws elb describe-load-balancers $*filters``
		if rd.anchor.get('Name') is Str {
			resources .= filter(F(desc) desc.LoadBalancerName == rd.anchor.Name)
		}
		# TODO: make tags fetching lazy
		tags = ``aws elb describe-tags --load-balancer-names $*{resources.map(X.LoadBalancerName)}``.Hash('LoadBalancerName', 'Tags')
		rd.resources = resources.map(F(props) {
			ret = props
			ret.Instances = props.Instances.InstanceId
			ret.Tags = tags.get(props.LoadBalancerName, {})
			ElbRes(rd, ret)
		})
		rd.resources .= reject(F(r) {
			not(rd.anchor.Tags.subset(r.props.Tags))
		})
		rd
	}

	doc Declarative primitive for creating AWS Elastic Load Balancer resources
	doc %STATUS - internal
	F create(rd:Elb, **props) {
		rd.log('create', "creating an ELB")
		rd.anchor.get('Name') is not Str throws InvalidArgument("ELB name and must be a string, not ${rd.anchor.get('Name')}")
		'ListenerDescriptions' not in props throws InvalidArgument("Elb must have 'ListenerDescriptions' property")

		('AvailabilityZones' not in props) and ('Subnets' not in props) throws InvalidArgument("Either 'AvailabilityZones' or 'Subnets' must be in Elb properties")
		'AvailabilityZones' in props throws NotImplemented("'AvailabilityZones' Elb property")
		argv = Argv({
			'--load-balancer-name': rd.anchor.Name
			'--listeners': props.ListenerDescriptions.encode_json()
			'--subnets': rd.opt_prop('Subnets', props).map(only(ResDef, ids))
		})
		rd.run('create ELB', %(aws elb create-load-balancer $*argv))
		# TODO: Use specific find, with the name
		if not(rd.dry_run) {
			rd.find()
			rd.resources % update(X, props)
		}
	}

	doc Declarative primitive for updating AWS Elastic Load Balancer resources
	doc %STATUS - internal
	F update(elb:ElbRes, props:Hash) {
		debug("AWS", "${elb} Update")
		elb.def.anchor.get('Name') is not Str throws InvalidArgument("Elb is the ELB name and must be a string, not ${elb.def.anchor.get('Name')}")

		# Tags
		if 'Tags' in props {
			diff = _diff_tags(elb.props.get('Tags', {}), props.Tags)

			if (tags = cli_tags(diff.add + diff.change)) {
				elb.run('add ELB tags', %(aws elb add-tags --load-balancer-names ${elb.def.anchor.Name} --tags $*tags))
			}

			if (tags = diff.remove) {
				elb.run('remove ELB tags', %(aws elb remove-tags --load-balancer-names ${elb.def.anchor.Name} --tags $*tags))
			}

			# Health check. Note: only updates given properties and keeps the rest as they were.
			if 'HealthCheck' in props {
				diff = Diff(elb.props['HealthCheck'], props['HealthCheck'])
				assert(not(diff.add), "Can't handle additional health check properties ${diff.add}")
				if diff.change {
					elb.log('update', "ELB health check change: ${diff.change}")
					t = elb.props['HealthCheck'] + diff.change
					elb.run(
						'update ELB health check',
						%(aws elb configure-health-check --load-balancer-name ${elb.def.anchor.Name} --health-check ${t.encode_json()})
					)
				}
			}
		}

		# Instances
		if 'Instances' in props {
			instances = props.Instances
			if instances is ResDef {
				instances .= ids()
			}
			diff = Diff(elb.props.Instances, instances)
			if diff.add {
				elb.run(
					'register instances with ELB',
					%(aws elb register-instances-with-load-balancer --load-balancer-name ${elb.def.anchor.Name} --instances $*{diff.add})
				)
			}
			if diff.remove {
				elb.run(
					'deregister instances from ELB',
					%(aws elb deregister-instances-from-load-balancer --load-balancer-name ${elb.def.anchor.Name} --instances $*{diff.remove})
				)
			}
		}

		# Security groups
		if 'SecurityGroups' in props {
			sgs = props.SecurityGroups
			if sgs is ResDef {
				if sgs.resources is Null {
					sgs.find()
				}
				sgs .= ids()
			}
			diff = Diff(elb.props.SecurityGroups, sgs)
			if diff.add or diff.remove {
				elb.run(
					'update ELB SGs',
					%(aws elb apply-security-groups-to-load-balancer --load-balancer-name ${elb.def.anchor.Name} --security-groups $*{sgs})
				)
			}
		}

		# TODO: listeners
		if 'ListenerDescriptions' in props {
			diff = Diff(elb.props.ListenerDescriptions, props.ListenerDescriptions)
		}
	}

	doc Declarative primitive for deleting AWS Elastic Load Balancer resources
	F delete(r:ElbRes) {
		r.run('Delete ELB', %(aws elb delete-load-balancer --load-balancer-name ${r.id()}))
	}

	# --------------------------------------------------
	# Zone
	# --------------------------------------------------

	# http://docs.aws.amazon.com/cli/latest/reference/route53/change-resource-record-sets.html

	# Anchor: [record_name, domain_name]. Most specific first to be unifrom with Subnet
	# Maybe support array or *-style wildcard for record_name?
	# Maybe support anchor hosted-zone-id in the future? Don't currently see how this could be useful.

	doc Declarative primitive for referencing AWS Route53 hosted zones resources.
	doc Supported anchor items: Name.
	doc %STATUS - experimental
	type Zone(ResDef)
	doc Single declarative primitive resource describing AWS Route53 hosted zones
	type ZoneRes(Res)

	# FIXME: zone-blah.com does not work, selects all zones

	# ${F(x) x.anchor.get('CallerReference', "${x.anchor.Name}-${Time().Int()}")}  --caller-reference
	Zone.user = %{
		prefix                zone
		prefix_is_synthetic   ${true}
		id                    Id

		find_command          %[aws route53 list-hosted-zones UNUSED]
		find_supports_tags    ${true}

		create_command        %[aws route53 create-hosted-zone]
		create_props_required %[Name]
		create_props_to_args  %{
			Name                   --name
			${F(x) "${x.anchor.Name}-${Time().Int()}"}  --caller-reference
		}


		display_name          "Route53 DNS zone"
		res_type              ${ZoneRes}
	}

	F init(rd:Zone, Name:Str) super(rd, Name=Name)

	F route53_resource_id(id:Str) id.split('/')[2]

	detect.zone_id = F(x) {
		not(x ~ /^Z[0-9A-Z]+$/) returns null
		Parameter(Zone, 'Id', "/hostedzone/${x}")
	}

	# TODO: Fix - selecting by --dns-name does *not* mean there will be at most
	#       one such zone!
	doc Declarative primitive for finding AWS Route53 hosted zones resources
	F find(rd:Zone) {
		debug("AWS", "Find Zone ${rd}")

		rd._assert_anchor_has_only_known_keys(*%[Name Id Tags])

		anchor = rd.anchor
		filters = []

		if 'Name' in anchor {
			filters += ['--dns-name', anchor.Name, '--max-items', 1]
		}

		zones = ``aws route53 list-hosted-zones-by-name $*filters``

		if 'Name' in anchor {
			zones .= filter(F(z) (z.Name == anchor.Name) or (z.Name == anchor.Name + '.'))
		}

		if 'Id' in anchor {
			zones .= filter(F(z) (z.Id == anchor.Id))
		}

		res_ids = zones.Id.map(route53_resource_id)
		tags = collector/{} res_ids.each_chunk(10, F(ids) {
			tags_chunk = ``aws route53 list-tags-for-resources --resource-type hostedzone --resource-ids $*{ids}``
			tags_chunk.each(F(t) collect("/hostedzone/${t.ResourceId}", t.Tags))
		})
		zones.each(F(z) z.Tags = tags.get(z.Id, {}))

		if 'Tags' in anchor {
			zones .= filter(F(z) anchor.Tags.subset(z.Tags))
		}

		rd.resources = zones.map(ZoneRes(rd, X))
		rd
	}

	F update(z:ZoneRes, props:Hash) {
		debug("AWS", "${z} Update")

		# Tags
		if 'Tags' in props {
			diff = _diff_tags(z.props.Tags, props.Tags)

			if (tags = cli_tags(diff.add + diff.change)) {
				z.run('add Zone tags', %(aws route53 change-tags-for-resource --resource-type hostedzone --resource-id ${z.id().split('/')[2]} --add-tags $*tags))
			}

			if (tags = diff.remove) {
				z.run('remove Zone tags', %(aws route53 change-tags-for-resource --resource-type hostedzone --resource-id ${z.id().split('/')[2]} --remove-tag-keys $*tags))
			}
		}
	}

	F delete(z:ZoneRes) {
		type_user_data = z.def.typeof().user
		z.run('Deleting ' + type_user_data.display_name, %(aws route53 delete-hosted-zone --id ${z.props.Id}))
	}

	# --------------------------------------------------
	# RecordSet
	# --------------------------------------------------

	# http://docs.aws.amazon.com/cli/latest/reference/route53/change-resource-record-sets.html

	# Anchor: [record_name, domain_name]. Most specific first to be unifrom with Subnet
	# Maybe support array or *-style wildcard for record_name?
	# Maybe support anchor hosted-zone-id in the future? Don't currently see how this could be useful.

	doc Declarative primitive for referencing AWS Route53 RecordSet resources.
	doc Supported anchor items: Name, ZoneName (in future _ZoneName), Type, SetIdentifier, Region.
	doc Supported properties (not sure): Type, SetIdentifier, Region.
	type RecordSet(ResDef)
	doc Single declarative primitive resource describing AWS Route53 RecordSet
	type RecordSetRes(Res)

	RecordSet.user = %{
		prefix rrset
		id     Name
	}

	doc Declarative primitive for finding AWS Route53 RecordSet
	F find(rd:RecordSet) {
		debug("AWS", "Find RecordSet ${rd}")
		anchor = rd.anchor

		zone_id = if 'ZoneName' in anchor {
			zones = ``aws route53 list-hosted-zones-by-name --dns-name ${anchor.ZoneName} --max-items 1``

			assert(zones.len() == 1 and zones[0].Name == anchor.ZoneName, "Zone ${anchor.ZoneName} not found when trying to manipulate a RecordSet in it")
			zones[0].Id
		} else {
			only(ResDef, ids)(anchor.ZoneId).the_one()
		}
		rd.zone_id = zone_id

		start_args = if 'Name' in anchor {
			Argv({
				'--start-record-name': anchor.Box('Name')
				'--start-record-type': anchor.Box('Type')
			})
		} else {
			[]
		}

		# XXX: getting 100 rrs. Overkill / underkill.
		rrs = ``aws route53 list-resource-record-sets --hosted-zone-id $zone_id $*start_args``

		for prop in %[Name Type SetIdentifier Region] {
			if prop in anchor {
				rrs .= filter({A.(prop) == anchor.(prop)})
			}
		}

		rd.resources = rrs.map(RecordSetRes(rd, X))
		rd
	}

	F _get_props(rd:RecordSet, props:Hash) {
		ret = {}
		ret.update(props)
		%[Name Type SetIdentifier].each(F(prop) {
			if prop in rd.anchor and prop not in ret {
				ret[prop] = rd.anchor[prop]
			}
		})
		ret
	}

	doc Declarative primitive for creating AWS Route53 RecordSet resources
	doc %STATUS - internal
	F create(rd:RecordSet, **props) {
		change_batch = {
			'Comment': props.get('Comment', "Added by AWS.ngs")
			'Changes': [{
				'Action': 'CREATE'
				'ResourceRecordSet': _get_props(rd, props)
			}]
		}
		echo("PROPS $props")
		rd.run('create RecordSet', %(aws route53 change-resource-record-sets --hosted-zone-id ${rd.zone_id} --change-batch ${change_batch.encode_json()}))
		if not(rd.dry_run) {
			# XXX use some id from run() above
			rd.find()
			rd.resources % update(X, props)
		}
	}

	doc Declarative primitive for updating AWS Route53 RecordSet resources
	doc %STATUS - internal
	F update(rrset:RecordSetRes, props:Hash) {
		props = _get_props(rrset.def, props)
		diff = Diff(rrset.props, props)
		# NOT DONE AND NOT SURE!
		if diff.add or diff.change or diff.remove {
			change_batch = {
				'Comment': props.get('Comment', "Updated by AWS.ngs")
				'Changes': [{
					'Action': 'UPSERT'
					'ResourceRecordSet': _get_props(rrset.def, props)
				}]
			}
			rrset.run('update RecordSet', %(aws route53 change-resource-record-sets --hosted-zone-id ${rrset.def.zone_id} --change-batch ${change_batch.encode_json()}))
		}
	}

	doc Declarative primitive for deleting AWS Route53 RecordSet resources
	F delete(r:RecordSetRes) {
		change_batch = {
			'Comment': "Deleted by AWS.ngs"
			'Changes': [{
				'Action': 'DELETE'
				'ResourceRecordSet': r.props
			}]
		}
		r.run('Delete RecordSet', %(aws route53 change-resource-record-sets --hosted-zone-id ${r.def.zone_id} --change-batch ${change_batch.encode_json()}))

	}

	# --------------------------------------------------
	# Az
	# --------------------------------------------------

	type Az(ResDef)
	type AzRes(Res)

	Az.user = %{
		id     ZoneName
		prefix az
		prefix_is_synthetic ${true}

		find_command          %[aws ec2 describe-availability-zones]
		find_props_to_filters %{
			RegionName region-name
			State      state
			ZoneName   zone-name
		}
		res_type ${AzRes}
	}

	# TODO

	# --------------------------------------------------
	# Volume (WIP)
	# --------------------------------------------------

	doc Declarative primitive for referencing AWS EC2 Volumes.
	doc Supported anchor items: VolumeId, _InstanceId, State, SnapshotId, Tags, AvailabilityZone, VolumeType, Size
	doc Supported properties: (converge is not implemented yet).
	doc Resources are listed in 'CreateTime' order.
	doc %STATUS - WIP
	type Volume(ResDef)
	type VolumeRes(Res)

	Volume.user = %{
		prefix vol
		id     VolumeId

		delete_command       %[aws ec2 delete-volume --volume-id]
	}

	doc Declarative primitive for finding AWS VPC resources
	F find(rd:Volume) {
		debug("AWS", "Find Volume ${rd}")
		rd._assert_anchor_has_only_known_keys(*%[VolumeId _InstanceId State SnapshotId Tags AvailabilityZone VolumeType Size])
		# filters = ['--filters'] +? (rd.anchor.Tags.cli_tags_filters() + cli_filters({'cidr': rd.anchor.get('CidrBlock'), 'isDefault': rd.anchor.get('IsDefault')}))
		filters = _make_filters_argv(rd, {
				'volume-id': 'VolumeId'
				'status': 'State'
				'snapshot-id': 'SnapshotId'
				'availability-zone': 'AvailabilityZone'
				'volume-type': 'VolumeType'
				'size': 'Size'
				'attachment.instance-id': '_InstanceId'
		}, transform={'_InstanceId': ids})
		resources = ``aws ec2 describe-volumes $*filters``
		rd.resources = resources / VolumeRes(rd, X)
		rd.resources .= sort({ A.props.CreateTime <= B.props.CreateTime })
		debug("AWS", "found ${resources.len()} ${rd.typeof().name} resources")
		rd
	}

	# --------------------------------------------------
	# Snapshot (WIP)
	# --------------------------------------------------

	# TODO: Are both OwnerId and OwnerIds needed?
	doc Declarative primitive for referencing AWS EC2 Snapshot resources.
	doc Supported anchor items: Tags, Description, OwnerId, OwnerIds, SnapshotId, State, VolumeId, VolumeSize, _AMI (extracted from Description "Created by CreateImage ...")
	doc Supported properties: (converge is not implemented yet).
	doc Warning: Owner ids starting with zero must be passed as strings.
	doc %STATUS - WIP
	type Snapshot(ResDef)
	doc Single declarative primitive resource describing AWS EC2 Snapshot resources
	type SnapshotRes(Res)

	Snapshot.user = %{
		prefix snap
		id     SnapshotId
	}

	doc Declarative primitive for finding AWS VPC resources.
	doc Warning: Owner ids starting with zero must be passed as strings.
	F find(rd:Snapshot) {
		debug("AWS", "Find Snapshot ${rd}")
		rd._assert_anchor_has_only_known_keys(*%[Tags Description OwnerId OwnerIds SnapshotId State VolumeId VolumeSize _AMI])
		# filters = ['--filters'] +? (rd.anchor.Tags.cli_tags_filters() + cli_filters({'cidr': rd.anchor.get('CidrBlock'), 'isDefault': rd.anchor.get('IsDefault')}))
		filters = _make_filters_argv(rd, %{
				description  Description
				owner-id     OwnerId
				snapshot-id  SnapshotId
				status       State
				volume-id    VolumeId
				volume-size  VolumeSize
		})
		filters2 = Argv({
			'--owner-ids': rd.anchor.Box('OwnerIds')
		})
		resources = ``aws ec2 describe-snapshots $*filters $*filters2``
		resources.each(F(r) {
			r._AMI = if m = (r.Description ~ _SNAPSHOT_AMI_RE) {
				m[1]
			} else {
				null
			}
		})
		rd.opt_prop('_AMI', rd.anchor, F(_AMI) {
			resources .= filter(F(r) r._AMI == _AMI)
		})
		rd.resources = resources / SnapshotRes(rd, X)
		debug("AWS", "found ${resources.len()} ${rd.typeof().name} resources")
		rd
	}

	# --------------------------------------------------
	# Elastic IP (WIP)
	# --------------------------------------------------

	type Eip(ResDef)
	type EipRes(Res)

	Eip.user = %{
		id     AllocationId
		prefix eip
		prefix_is_synthetic ${true}

		create_command %[aws ec2 allocate-address]
		delete_command %[aws ec2 release-address --allocation-id]
	}

	F find(rd:Eip) {
		debug("AWS", "Find Snapshot ${rd}")
		rd._assert_anchor_has_only_known_keys(*%[InstanceId Tags])
		filters = _make_filters_argv(rd, %{
				instance-id	InstanceId
		})
		resources = ``aws ec2 describe-addresses $*filters``
		rd.resources = resources / EipRes(rd, X)
		debug("AWS", "found ${resources.len()} ${rd.typeof().name} resources")
		rd
	}

	# --------------------------------------------------
	# AvailabilityZone
	# --------------------------------------------------

	type Bucket(ResDef)
	type BucketRes(Res)

	# TODO: unhardcode region
	Bucket.user = %{
		id                   Name
		prefix               bucket
		prefix_is_synthetic ${true}

		find_command          %[aws s3api list-buckets]
		find_props_to_filters %{
		}
		find_props_to_post_filters %{
			Name DUMMY
		}

		create_command        %[aws s3api create-bucket --region us-east-1]
		create_props_to_args  %{
			Name --bucket
		}

		delete_command        %[aws s3api delete-bucket --bucket]

		res_type ${BucketRes}
		display_name          "S3 bucket"
	}

	# --------------------------------------------------
	# Certificate
	# --------------------------------------------------

	type Certificate(ResDef)
	type CertificateRes(Res)

	detect.certificate_arn = F(x) {
		not(x ~ /^arn:aws:acm:eu-central-1:209483131680:certificate\//) returns null
		Parameter(Certificate, 'CertificateArn', x)
	}


	# aws acm request-certificate --domain-name test2.com --validation-method DNS
	# TODO: Support email validation?
	# TODO: after creation, describe should be used and not list (i think)
	Certificate.user = %{
		id                  CertificateArn
		prefix              cert
		prefix_is_synthetic ${true}

		find_command          %[aws acm list-certificates]
		find_props_to_args    %{
			Status         --certificate-statuses
		}
		find_props_to_post_filters %{
			DomainName     DUMMY
			CertificateArn DUMMY
		}

		find_describe_command %[aws acm describe-certificate --certificate-arn]
		find_describe_remove_top_level_hash ${true}

		create_command        %[aws acm request-certificate --validation-method DNS]
		create_props_to_args  %{
			DomainName  --domain-name

		}
		delete_command        %[aws acm delete-certificate --certificate-arn]

		res_type ${CertificateRes}
		display_name          "ACM certificate"
	}

	# --------------------------------------------------
	# Distribution
	# --------------------------------------------------

	type Distribution(ResDef)
	type DistributionRes(Res)

	# detect.certificate_arn = F(x) {
	# 	not(x ~ /^arn:aws:acm:eu-central-1:209483131680:certificate\//) returns null
	# 	Parameter(Distribution, 'DistributionArn', x)
	# }


	# aws cloudfront create-distribution --origin-domain-name www.yahoo.com
	# find_tags_command_1   %[aws cloudfront list-tags-for-resource --resource]
	Distribution.user = %{
		id                  Id
		prefix              dist
		prefix_is_synthetic ${true}

		find_command          %[aws cloudfront list-distributions]

		create_command        %[aws cloudfront create-distribution]
		create_props_to_args  %{
			Origins.DomainName  --origin-domain-name
		}

		update_methods        %{
			Enabled  ${
				F update_enabled(d:DistributionRes, v:Bool) {
					d.props.Enabled == v returns
					debug("AWS", "Will modify DistributionRes.props.Enabled from ${d.props.Enabled} to ${v}")
					conf = ``aws cloudfront get-distribution-config --id ${d.id()}``
					conf.DistributionConfig.Enabled = v
					d.run('Update Enabled', %(aws cloudfront update-distribution --id ${d.id()} --if-match ${conf.ETag} --distribution-config ${conf.DistributionConfig.encode_json()}))
				}
			}
		}

		res_type ${DistributionRes}
		display_name          "CloudFormation Distribution"
	}

	F delete(d:DistributionRes) {
		conf = ``aws cloudfront get-distribution-config --id ${d.id()}``
		d.run('Delete', %(aws cloudfront delete-distribution --id ${d.id()} --if-match ${conf.ETag}))
	}


	# ==================================================
	# Utilities
	# ==================================================

	util = ns {
		F world_open_port(port:Int, proto:Str='tcp') {
			{
				'IpProtocol': proto
				'FromPort': port
				'ToPort': port
				'IpRanges': [ { 'CidrIp': '0.0.0.0/0' } ]
			}
		}
		F world_open_port(port:Arr, proto:Str='tcp') port.map(world_open_port(X, proto))

		F world_open_ip_proto(proto) {
			{
				'IpProtocol': Str(proto)
				'IpRanges': [ { 'CidrIp': '0.0.0.0/0' } ]
			}

		}
		F world_open_ip_proto(proto:Arr) proto.map(world_open_ip_proto)

		F world_open_icmp() {
			{
				'IpProtocol': 'icmp'
				'FromPort': -1
				'ToPort': -1
			}
		}
	}

	# ==================================================
	# Backwards compatibility with bunch of global variables
	# ==================================================

	# "global x = y" is not exported as it's syntactically
	# different from "x = y" (which is exported)
	global AWS_AMI_OWNER_DEBIAN = AMI_OWNER_DEBIAN
	global AWS_AMI_OWNER_AMAZON = AMI_OWNER_AMAZON
	global AwsRes = Res, AwsResDef = ResDef
	global AwsVpc = Vpc, AwsVpcRes = VpcRes
	global AwsSecGroup = SecGroup, AwsSecGroupRes = SecGroupRes
	global AwsSubnet = Subnet, AwsSubnetRes = SubnetRes
	global AwsImage = Image, AwsImageRes = ImageRes
	global AwsInstance = Instance, AwsInstanceRes = InstanceRes
	global AwsElb = Elb, AwsElbRes = ElbRes
	global AwsRecordSet = RecordSet, AwsRecordSetRes = RecordSetRes

	# ==================================================
	# Quick and dirty - set global variables
	# ==================================================

	F pollute(do_warn=true) {

		vars =
			_exports.filterk(/^AMI_OWNER/) +
			_exports.filterv(Type).without('Res').without('ResDef') +
			{
				'regions': regions
				'zones': zones
			}

		if do_warn {
			warn("Polluting global namespace with AWS-specific variables: ${vars.keys().join(', ')}")
		}

		vars.mapk(ll_resolve_global_variable).each(ll_set_global_variable)
	}

	# ==================================================
	# Quick resolve of resource ids to ResDef (WIP)
	# ==================================================

	_rd_types = _exports.without('ResDef').values().filter(Type).filter(F(t) t.parents.has(ResDef))
	# echo(_exports.without('ResDef').values().map(typeof))
	_rd_types_with_prefixes = _rd_types.filter(F(t) t.user.has('prefix'))

	RESOURCE_CODE_TO_RESOURCE_TYPE = _rd_types_with_prefixes.map(F(t) {
		[t.user.prefix, t]
	}).Hash()

	detect.plain_prefix = F(x) {
		RESOURCE_CODE_TO_RESOURCE_TYPE.get(x)
	}

	detect.prefixed_resource = F(x) {
		m = x ~ /^([a-z]+)-[a-zA-Z0-9]+$/
		not(m) returns null
		t = RESOURCE_CODE_TO_RESOURCE_TYPE.get(m[1])
		t is Null returns null
		t.user.get('prefix_is_synthetic') returns null
		p = Parameter(t, t.user.id, x)
	}

	detect.synthetically_prefixed_resource = F(x) {
		m = x ~ /^([a-z]+)-(.+)$/
		not(m) returns null
		t = RESOURCE_CODE_TO_RESOURCE_TYPE.get(m[1])
		t is Null returns null
		t.user.get('prefix_is_synthetic').not() returns null
		p = Parameter(t, t.user.id, m[2])
	}

	# doc Work in progress, do not use!
	F q(s:Str, **kw) {
		detected = detect(s).values().reject(NoData).map(ensure_array).flatten()
		debug("AWS", "q() detected ${detected}")
		not(detected) throws InvalidArgument("Unkown resource").set('s', s)
		detected.len() > 1 throws Error("TODO")
		d = detected[0]
		d is Type returns d(**kw)
		(d.res_type)( **{ d.param_name: d.param_value } + kw )
	}

	F is_resource_code(s:Str) s in RESOURCE_CODE_TO_RESOURCE_TYPE

	# --------------------------------------------------
	# related_to
	# --------------------------------------------------
	Vpc.user.related_to = {
		SecGroup: 'VpcId'
	}
	Subnet.user.related_to = {
		Vpc: 'VpcId'
	}
	# TODO: SecGroup
	Instance.user.related_to = {
		Image: 'ImageId'
		Vpc: 'VpcId'
		Elb: '_Elb'
		Eip: '_Eip'
		Volume: '_VolumeId'
	}
	Igw.user.related_to = {
		Vpc: 'Attachments'
	}
	Volume.user.related_to = {
		Instance: '_InstanceId'
	}

	# Does not work yet
	RecordSet.user.related_to = {
		Zone: 'ZoneId'
	}

	SecGroup.user.related_to = {
		Vpc: 'VpcId'
	}

	# --------------------------------------------------
	# Any
	# --------------------------------------------------

	# Can't define Any because all unspecified types are "Any"
	doc EXPERIMENTAL! Do not use!
	type _Any(ResDef)
	_exports.Any = _Any

	# Could query every resource type but describe-tags makes
	# the process more efficient.
	# To think: resources' .rd should be changed to this rd?
	# TODO: parallel calls for each resource type
	doc EXPERIMENTAL! Do not use!
	F find(rd:_Any) {
		filters = _make_filters_argv(rd, {})
		if rd.anchor.Tags {
			codes = ``aws ec2 describe-tags $*filters``.ResourceId.map({ (A ~ /^(.*?)-/)[1] }).uniq()
			types = codes.map(RESOURCE_CODE_TO_RESOURCE_TYPE[X])
		} else {
			types = RESOURCE_CODE_TO_RESOURCE_TYPE.values()
		}
		rd.resources = types.map(X(Tags=rd.anchor.Tags)).map(find).resources.flatten()
		rd
	}

}

