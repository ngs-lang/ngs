# WARNING: This file is packaged into the ngs binary at build time
#          it is shipped for reference only.

section "Base" {
	doc No op.
	doc %RET - null
	F init(x) null
}

section "Syntactic sugar for basics" {

	doc Boolean negation for non-boolean values. Converts to boolean first.
	doc %RET - Bool
	F not(x) { guard (x is Bool) == false; x.Bool().not() }

	doc Inequality operator
	doc %EX - 1 !=2  # true, same as not(1==2)
	F !=(a,b) not(a==b)

	doc Non-sameness operator
	doc %EX - h1 = {"a": 1}
	doc %EX - h2 = {"a": 1}
	doc %EX - h1 !== h2  # true, same as not(h1===h2)
	doc %EX - h1 == h2   # true
	F !==(a,b) not(a===b)

	TEST 1 != 2
	TEST (1 != 1) == false

	TEST 1 !== 2
	TEST (1 !== 1) == false


	doc "not in" operator. Exactly same as "not(a in b)"
	doc %EX - 10 not in [1,2]  # true
	doc %EX - 1  not in [1,2]  # false
	F 'not in'(a,b) not(a in b)

	TEST (1 not in [1,2,3]) == false
	TEST 10 not in [1,2,3]

	doc "is not" operator. Exactly same as "not(a is b)".
	doc %EX - 1    is not Null  # true
	doc %EX - null is not Null  # false
	F 'is not'(a,b) not(a is b)

	TEST 1 is not Null
	TEST (null is not Null) == false

	doc Exactly same as "element in container". It's just more convenient in specific cases.
	doc %EX - [1,2,3].has(2)  # true
	doc %EX - [[1,2,3], [1,20,30], [100,200,300]].filter(X.has(1))  # [ [1,2,3], [1,20,30] ]
	doc %RET - Bool
	F has(container, element) element in container

	TEST [1,2,3].has(1)
	TEST [1,2,3].has(10).not()

	doc Exactly same as "element not in container". It's just more convenient in specific cases.
	doc %EX - [1,2,3].has_no(2)  # false
	doc %EX - [[1,2,3], [1,20,30], [100,200,300]].filter(X.has_no(1))  # [ [100,200,300] ]
	doc %RET - Bool
	F has_no(container, element) element not in container

	TEST [1,2,3].has_no(1).not()
	TEST [1,2,3].has_no(10)

}

section "inheritance" {
	doc Create a new type. Do not use directly.
	doc %AUTO - type MyType2(MyType1)
	F Type(t:Str, doc, ns, parent:Type) Type(t, doc, ns, [parent])

	doc Create a new type. Do not use directly.
	doc %AUTO - type MyType2([MyParent1, MyParent2, ...])
	F Type(t:Str, doc, ns, parents:Arr) {
		ret = Type(t, doc, ns)
		l = parents.len()
		for(i;l) {
			ret.inherit(parents[i])
		}
		ret
	}

	TEST type T1; type T2(T1); T2() is T1
}

section "Basic Methods for Exception type" {
	doc Initialize an Exception.
	doc %RET - Exception with .backtrace and .message
	doc message - Goes into .message
	F init(e:Exception, message:Str) {
		e.message = message
	}

	doc Initialize an Exception.
	doc %RET - Exception with .backtrace and .cause
	F init(e:Exception, cause:Exception) {
		e.cause = cause
	}

	doc Initialize an Exception.
	doc %RET - Exception with .backtrace, .message, and .cause
	F init(e:Exception, message:Str, cause:Exception) {
		e.message = message
		e.cause = cause
	}
}

section "Basic Error subtypes" {
	type NotImplemented(Error)
	type ReadFail(Error)
	type RequireFail(Error)
	type MainFail(Error)

	doc Represents error when converting program execution result to exit code
	type ExitCodeFail(Error)
}

section "Basic I/O" {
	doc Print given string and a newline to stdout.
	doc %RET - null
	doc %EX - echo("blah")  # Output: blah
	F echo(s:Str) echo(1, s)
}



section "Exit type and basic ExitCode pseudo-constructor methods" {

	doc Information about exiting, used by bootstrap and as argument to exit_hook.
	doc exit_code - the code to exit with
	doc exceptions - exceptions that occurred during exit procedure
	type Exit

	doc %RET - always 0
	F ExitCode(x) 0

	doc %RET - 0 for true, 1 for false
	F ExitCode(b:Bool) if b 0 1

	doc %RET - n
	F ExitCode(n:Int) n

	doc %RET - Always 240
	F ExitCode(e:Exception) 240
}

section "Block type and methods" ns {
	global Block, ReturnFromBlock, init, block, return

	doc The type of the NAME variable used in syntax: block NAME BODY
	doc %AUTO - block NAME BODY
	type Block

	doc %AUTO - block NAME { NAME.return(VAL) }
	type ReturnFromBlock(Exception)

	doc %STATUS - internal
	F init(rfb: ReturnFromBlock, block, val) init(args())

	doc %AUTO - block NAME BODY
	doc %EX - block b { calc(); if answer_found then b.return(42); more_calc(); another_answer }
	F block(body:Fun) {
		b = Block()
		F block_super_handler(*args, **kwargs) {
			throw NotImplemented("calling super() from within a block is not implemented")
		}
		mm = MultiMethod([block_super_handler, body])
		try {
			mm(b)
		} catch(rfb: ReturnFromBlock) {
			guard rfb.block === b
			rfb.val
		}
	}

	doc %STATUS - internal
	doc %AUTO - block NAME { NAME.return() }
	doc %AUTO - block NAME { NAME.return(VAL) }
	F return(b:Block, val=null) throw ReturnFromBlock(b, val)

	TEST block b { b.return(1); 2 } == 1
	TEST block b { "blah"; 2 } == 2
	TEST block b1 { [block b2 { b2.return(2); 0 }, 1] } == [2, 1]
}

STDLIB_EOL = "\n"
STDLIB_PATH_SEP = '/'
STDLIB_MAX_RAND_REAL = Real(RAND_MAX)

section "Document internal GC namespace" {
	GC.meta({'doc': {'': 'Control NGS garbage collection'}})
	GC['enable'].meta({'doc': {'': 'Enable garbage collection'}})
	GC['disable'].meta({'doc': {'': 'Disable garbage collection'}})
	GC['get_parallel'].meta({'doc': {'': 'Check parallel garbage collection. Please do not use!', '%STATUS': 'internal'}})
}

doc EXPERIMENTAL! Do not use!
F TODO(s:Str="TODO") {
	throw NotImplemented("Functionality not implemented. Info: ${s}")
}

doc Do nothing
doc %RET - null
F nop(*args, **kwargs) null


# === Trivial init() helper ===

doc Trivial initialization helper for init(o, ...)
doc Sets object fields from the supplied parameters
doc %EX - # sets t.a and t.b
doc %EX - F init(t:MyType, a, b) init(args())
F init(h:Hash) {
	dst_kv = ll_hash_head(h)
	dst = dst_kv.ll_hash_entry_val() # dst - value of first Hash entry
	e = dst_kv.ll_hash_entry_next()
	while e != null {
		dst.(e.ll_hash_entry_key()) = e.ll_hash_entry_val()
		e .= ll_hash_entry_next()
	}
	dst
}

# === Exceptions ===

doc Represents failed assertion, thrown by assert(). Should be used to catch programming errors.
doc %EXSYN - commands
doc %EX - F box_area(x:Int, y:Int) {
doc %EX - 	assert(x > 0)
doc %EX - 	assert(y > 0)
doc %EX - 	x * y
doc %EX - }
doc %EX - echo(box_area(5, 10))
doc %EX - # Output: 50
doc %EX - echo(box_area(-5, 10))
doc %EX - # ... Exception of type AssertFail ...
doc %EX - #
doc %EX - # Note that the following is better than using assert():
doc %EX - # not(x > 0) throws InvalidArgument('x must be greater than zero').set('x', x)
type AssertFail(Exception)

doc Represents an attempt to create an instance of an abstract type (not intended for instantiation).
type InstantiatingAbstractType(Error)

doc IndexNotFound exception constructor
doc %RET - IndexNotFound object with the given message, container and key fields
F init(e:IndexNotFound, message:Str, container, key) init(args())

doc Throws AssertFail with given message if expr does not match the pattern
doc %EX - my_template.get('concept', []).assert(Arr)
doc %EX - assert(loginResult, {'access_token': Str}, "access_token must be present in response")
doc %RET - val
F assert(val, pattern, msg:Str="Assertion failed") {
	not(val =~ pattern) throws AssertFail(msg).set(val=val, pattern=pattern)
	val
}

doc Throws AssertFail with given message if expr evaluates to false
doc expr - if evaluates to false, causes AssertFail exception
doc msg - message for the exception, defaults to "Assertion failed"
doc %RET - expr
doc %EX - my_array=[]
doc %EX - # ... Code that adds elements to my_array ...
doc %EX - assert(my_array.len() > 3, "my_array must have more than 3 elements")  # AssertFail exception, with the given message
F assert(expr, msg:Str="Assertion failed") {
	not(expr) throws AssertFail(msg).set(expr=expr)
	expr
}

doc Throws AssertFail with given function does not throw exception of the given type.
doc f - Fun
doc t - Subtype of Exception
doc %RET - The exception
doc %EX - assert({1/0}, DivisionByZero)
F assert(f:Fun, t:Type, msg:Str="Assertion failed") {
	guard t <= Exception
	r = Result(f)
	assert(r, Failure, msg)
	assert(r.val, t, msg)
	r.val
}

TEST assert({1/0}, DivisionByZero) is DivisionByZero

doc Initializes InstantiatingAbstractType.
F init(e:InstantiatingAbstractType, t:Type) init(args())

section "Namespaces" {

	doc Get NormalType object field. Useful when calling method stored in an field.
	doc %EX - myobj::method_in_field(arg)  # calls method stored in myobj.method_in_field
	doc %EX - (myobj.method_in_field)(arg) # calls method stored in myobj.method_in_field
	doc %EX - myobj.method_in_field(arg)   # calls global "method_in_field"
	F '::'(nti:NormalTypeInstance, k) nti.(k)

	# TODO: There is Namespace type now - do adjustment here
	doc Get Hash key. Useful when calling method stored in a Hash key.
	doc Useful for working with namespaces, which are implemented as Hash instances.
	doc %EX - elb = AWS::Elb(...).converge(...)
	F '::'(h:Hash, k) h[k]

	doc Set NormalType object field. It's implemented to complete the :: operator. There is no particular use case.
	F '::='(nti:NormalTypeInstance, k, v) nti.(k) = v
	doc Set Hash key. It's implemented to complete the :: operator. There is no particular use case.
	F '::='(h:Hash, k, v) h[k] = v

	doc Executes f(x)
	doc %RET - x
	F '::'(x, f:Fun) {
		f(x)
		x
	}
}

section "Meta convenience methods" {
	# TODO: Consider switching meta from Hash to Namespace
	doc Wraps native meta() and in case that if there is none, sets it to empty hash.
	F meta(o:Any) {
		ret = super(o)
		ret is not Null returns ret
		ret = {}
		super(o, ret)
		ret
	}

	doc %STATUS - deprecated
	doc Use meta() instead.
	F attrs(*args) {
		warn("Using deprecated method attrs(). Use meta() instead.")
		meta(*args)
	}
}

section "UserDefinedMethod" {
	doc %RET - true
	F Bool(udm:UserDefinedMethod) true
}

section "MultiMethod" {

	doc Create MultiMethod with no methods
	F MultiMethod() super([])

	doc Number of methods in MultiMethod
	F len(mm:MultiMethod) mm.Arr().len()

	doc Whether MultiMethod has any methods
	F Bool(mm:MultiMethod) mm.Arr().Bool()

	block _ {
		global each
		# Preventing execution of F Arr(Eachable1) defined below.
		# It causes infinite loop when tries to convert Eachable1 MultiMethod: it uses this each(), which uses Arr()
		basic_arr = MultiMethod(Arr.constructors.Arr())

		doc Call cb for each method of the MultiMethod
		doc %EX - echo.each(F(method) echo("${method.params().name.join(", ")}"))
		F each(mm:MultiMethod, cb:Fun) {
			mm.basic_arr().each(cb)
			mm
		}
	}

	F filtero(mm:MultiMethod, pred) mm.Arr().filter(pred).MultiMethod()

	F Str(mm:MultiMethod) "<MultiMethod with ${mm.Arr().len()} method(s)>"
}

section "Parent types for built-in types" {
	doc Parent type of all types that have each() method
	type Eachable

		doc Eachable which each() calls the callback with one argument
		type Eachable1(Eachable)

		doc Eachable which each() calls the callback with two arguments
		type Eachable2(Eachable)

	Int.inherit(Eachable1)
	Arr.inherit(Eachable1)
	Str.inherit(Eachable1)
	MultiMethod.inherit(Eachable1)
	# TODO: Consider Eachable2 subtype for Hash (as callback has 2 arguments)
	Hash.inherit(Eachable2)

	doc Absence of data
	type NoData
	Null.inherit(NoData)

	doc A number
	type Num
	Int.inherit(Num)
	Real.inherit(Num)
}

section "Default constructors for built-in types" {
	doc Make null
	doc %RET - null
	F Null() null
	doc Make false
	doc %RET - false
	F Bool() false
	doc Make empty array
	doc %RET - []
	F Arr()  { [] }
	doc Make empty hash
	doc %RET - {}
	F Hash() { {} }
	doc Make empty string
	doc %RET - ''
	F Str()  { '' }
	doc Get zero
	doc %RET - 0
	F Int()  { 0 }
	doc Get zero
	doc %RET - 0.0
	F Real() { 0.0 }
}

section "Inspect built-in types" block _ {
	global Str, inspect

	F StrParams(f:Fun) {
		guard f =~ AnyOf(UserDefinedMethod, NativeMethod)
		f.params().map(F(p) {
			d = if 'dflt' in p then '=...' else ''
			"${p.get('splat', '')}${p.name}:${p.type.name}${d}"
		}).join(', ') \ "($X)"
	}

	doc String representation of native method.
	doc %RET - "<NativeMethod NAME(PARAMS)>"
	doc %EX - (%).Arr()[0].Str().echo()  # Outputs: <NativeMethod %(a:Int, b:Int)>
	F Str(nm:NativeMethod) "<${nm.Type().name} ${nm.meta().name}${StrParams(nm)}>"

	# TODO: show arguments:
	#   "<UserDefinedMethod ${c.meta().name tor "<anonymous>"}(HERE) at ${location}>"
	doc String representation of a closure
	doc %RET - Str
	doc %EX - Real.constructors[-1].Str().echo()  # Outputs: <UserDefinedMethod Real at /usr/share/ngs/stdlib.ngs:350>
	F Str(c:UserDefinedMethod) {
		info = c.ip().resolve_instruction_pointer()
		location = "${info.file}:${info.first_line}" tor "<unknown location>"
		"<UserDefinedMethod ${c.meta().name tor "<anonymous>"}${StrParams(c)} at ${location}>"
	}

	global _inspect_path_to_str
	doc Internal method. Please do not use.
	F _inspect_path_to_str(path:Arr) {
		not(path) returns '(root)'
		F kern(x) "[<object of type ${x.Type().name}>]"
		F kern(l:Lit) l.val
		F kern(x:Int) "[$x]"
		F kern(x:Str) "['${SafeStr(x)}']"
		F kern(x:Str) {
			guard x =~ /^[a-zA-Z_][a-zA-Z0-9_]*$/
			".${x}"
		}
		path.map(kern).join('')
	}

	doc %STATUS - internal
	doc Internal method. Please do not use.
	doc Inspect any value.
	doc %RET - Arr with exactly one Str of the form <TYPE_NAME ...>
	F inspect(path:Arr, val) {
		# * Some types have Str() which is of the form <TYPE_NAME ...> and some don't
		# * Ensuring <TYPE_NAME ...> form
		# * I don't like this. There should be a way for Str() and SafeStr() to indicate
		#   that the output is acceptable as inspect() result (sans Lines()).
		# * It will also break if type name will include namespace for example.
		s = SafeStr(val)
		t = '<' + val.Type().name
		if s !~ Pfx(t) {
			s = "${t} $s>"
		}
		[_inspect_path_to_str(path) + " = " + s]
	}

	doc %STATUS - internal
	doc Internal method. Please do not use.
	doc Inspect Eachable1
	doc %RET - Arr of Str
	F inspect(path:Arr, e:Eachable1) {
		guard e !~ Int
		# TODO: Limit number of displayed items
		["${_inspect_path_to_str(path)} - ${e.Type().name} of size ${e.len() tor '(unknown size)'}"] + e.map_idx_val({
			inspect(path + [A], B)
		}).flatten()
	}

	doc %STATUS - internal
	doc Internal method. Please do not use.
	doc Inspect meta() of Type or Fun
	doc %RET - Arr of Str
	F inspect_meta(path:Arr, val) {
		keys_meanings = {
			'%EX': 'Example'
			'%RET': 'Returns'
		}
		p = _inspect_path_to_str(path)
		collector {
			a = try val.meta()
			not(a) returns []
			a.without('doc').each(F(k, v) {
				inspect(path + [k], v).each(collect)
			})
			# doc can be null
			# doc can be a string, example: "Partial application syntax" (ngs -pi 'X*2')
			if d = a.get('doc') {
				if d is Str {
					d = {'': d}
				}
				d.each(F(k, v) {
					k = cond {
						k in keys_meanings keys_meanings[k]
						not(k) k
						true "Parameter ${k}"
					}
					kk = '[' +? k +? ']'
					v.ensure(Arr).each(F(doc_line) {
						collect("${p}.doc<${kk}> = ${doc_line}")
					})
				})
			}
		}
	}

	doc %STATUS - internal
	doc Internal method. Please do not use.
	doc For Type, NativeMethod, UserDefinedMethod
	doc %RET - Arr of Str
	F inspect(path:Arr, x) {
		guard x =~ AnyOf(Type, NativeMethod, UserDefinedMethod)
		["${_inspect_path_to_str(path)} - ${x.Str()}"] + inspect_meta(path + [Lit('.meta()')], x)
	}

	doc %STATUS - internal
	doc Internal method. Please do not use.
	doc Inspect MultiMethod
	doc %RET - Arr of Str
	F inspect(path:Arr, mm:MultiMethod) {
		["${_inspect_path_to_str(path)} - MultiMethod"] + inspect(path + [Lit('.Arr()')], mm.Arr())
	}

	doc %STATUS - internal
	doc Internal method. Please do not use.
	doc Inspect Str
	doc %RET - Arr of Str
	F inspect(path:Arr, s:Str) ["${_inspect_path_to_str(path)} = String of length ${s.len()}: ${SafeStr(s)}"]

	doc %STATUS - internal
	doc Internal method. Please do not use.
	doc Inspect Hash and similar data structures
	doc %RET - Arr of Str
	F inspect(path:Arr, h) {
		guard h =~ AnyOf(Hash, HashLike, Namespace, NormalTypeInstance)
		guard h !~ ArrLike  # Handled as Eachable1
		hh = h.Hash()
		["${_inspect_path_to_str(path)} - ${h.Type().name} with ${hh.len()} key/value pair(s)"] + hh.map({
			inspect(path + [A], B)
		}).flatten()
	}

	doc %STATUS - internal
	doc Internal method. Please do not use.
	doc Inspect CommandsPipeline
	doc %RET - Arr of Str
	F inspect(path:Arr, cp:CommandsPipeline) {
		F p(idx:Int) {
			cp.pipes[idx] is Null returns []
			inspect(path + ['pipes', idx], cp.pipes[idx])
		}
		collector {
			collect("${_inspect_path_to_str(path)} - ${cp.Type().name}")
			if cp.options {
				inspect(path + ['options'], cp.options) % collect
			}
			p(0) % collect
			for(i;len(cp.commands)) {
				inspect(path + ['commands', i], cp.commands[i]) % collect
				p(i+1) % collect
			}
		}
	}

	doc Inspect any object
	doc %RET - Human readable representation of the object
	F inspect(x) inspect([], x).Lines()
}

section "Functional utilities" {
	doc The identity function.
	doc %RET - x
	F identity(x) x

	TEST identity(10) == 10


	# TODO: Add more info about the newly created function - useful for debugging
	#       See https://docs.python.org/2/library/functools.html#partial-objects
	doc Returns partially-applied function
	doc f - The base function
	doc Xunderscore_unsupportedXbind_args - The arguments to partial apply (bind the function to)
	doc %STATUS - deprecated
	F partial(f:Fun, *bind_args)
		F(*args) f(*bind_args, *args)

	TEST p = partial((-), 10); p(7) == 3


	doc Same as partial() but the bound arguments are last ones
	doc %STATUS - deprecated
	F partial_tail(f:Fun, *bind_args)
		F(*args) f(*args, *bind_args)

	TEST p = partial_tail((-), 10); p(7) == -3

	doc %STATUS - EXPERIMENTAL
	doc %RET - f(x)
	doc %AUTO - x.{ ... }
	F .(x, f:Fun) f(x)
}

section "Convenience methods" {
	doc Sets the given field to the given value
	doc %RET - The modified obj
	doc %EX - s.len() != 1 throws InvalidArgument("ord() argument must be of length 1 exactly").set('given', s)
	doc %EX - # Would else be written as
	doc %EX - if s.len() != 1 {
	doc %EX - 	e = InvalidArgument("ord() argument must be of length 1 exactly")
	doc %EX - 	e.given = s
	doc %EX - 	throw e
	doc %EX - }
	F set(obj, field:Str, val) {
		obj.(field) = val
		obj
	}

	doc Sets the given fields to the given values
	doc %RET - The modified obj
	doc %EX - my_cond throws InvalidArgument("Out of range").set(min=0, max=10, given=12)
	F set(obj, **kwargs) {
		kwargs.each(obj.set(X, Y))
		obj
	}

	TEST type T; t=T().set(a=1, b=2); t.a == 1 and t.b == 2
}

section "NormalTypeInstance" {
	doc String representation of normal type instance i
	doc Normal type is a user defined type. In addition some types defined by NGS are also normal types.
	doc %EX - {
	doc %EX -   type T
	doc %EX -   # nti - Normal type instance
	doc %EX -   nti = T()
	doc %EX -   nti.a = 1
	doc %EX -   nti.b = 2
	doc %EX -   echo(Str(nti)) # <T a=1 b=2>
	doc %EX - }
	doc %RET - "<TYPE_NAME field1=val1 field2=val2 ...>"
	F Str(i:NormalTypeInstance) {
		h = Hash(i)
		fields_dots = if len(h) > 10 {
			h .= limit(10)
			' ...'
		} else {
			''
		}
		# TODO limit key and value lengths
		fields = ' ' +? h.Strs().join(' ')
		"<${i.Type().name}${fields}${fields_dots}>"
	}

	TEST type T; t=T(); Str(t) == '<T>'
	TEST type T; t=T(); t.a=1; t.b=2; Str(t) == '<T a=1 b=2>'

	doc Set object field if it's not already set
	doc %EX - my_something.dflt(k, []).push(elt)
	doc %RET - Field value, the already-existed or new.
	F dflt(i:NormalTypeInstance, k, v) {
		if k not in i {
			i.(k) = v
		}
		i.(k)
	}

	TEST type T; t=T(); t.dflt("a", 1); t.a == 1
	TEST type T; t=T(); t.a = 2; t.dflt("a", 1); t.a == 2

	doc Make shallow copy of an object
	F copy(nti:NormalTypeInstance) {
		t = Type(nti)
		t()::{
			nti.Hash().each(A.set(X, Y))
		}
	}

	TEST type T; t=T(); t.x=1; t2=t.copy(); t2.x==1
}

section "Hash" {
	doc %RET - h
	F Hash(h:Hash) h
}

section "Result and friends - types" {
	doc Result of a computation
	doc val - computed value or exception
	type Result

		doc Successful computation
		doc val - computed value
		type Success(Result)

		doc Failed computation
		doc val - exception
		type Failure(Result)

}

section "Literal" {
	doc Convey that the value should be used literally, not as a pattern
	type Lit
	F init(l:Lit) throw MethodNotFound("Lit() must have an argument")
	F init(l:Lit, val) l.val = val
}



section "=~ Matching" {

	section "MatchResult and friends - types" {
		doc Successful or unsuccessful match result
		type MatchResult

			doc Successful match result
			doc matches - Successful matches
			type MatchSuccess([MatchResult, Success])

			doc Unsuccessful match result
			type MatchFailure([MatchResult, Failure])

		doc Successful match constructor
		doc %STATUS - deprecated
		F init(ms:MatchSuccess, matches:Arr) init(args())

		doc Successful match constructor
		F init(ms:MatchSuccess, matches:Arr, pattern) init(args())

		doc Unsuccessful constructor
		F init(mf:MatchFailure, data, pattern) init(args())

		doc Get the values of successful match
		F get(ms:MatchSuccess) ms

		doc Throws ResultFail
		F get(mf:MatchFailure) throw ResultFail("There was no match").set('failure', mf)


	}

	section "MatchContext" {
		doc %STATUS - experimental
		type MatchContext

		doc %STATUS - experimental
		F init(mc:MatchContext, root) {
			mc._root = root
			mc._positional = []  # Result - positional matches
			mc._named = {}       # Result - named matches
			mc._path = []        # Current path in _root
			mc._deeper_saved_fields = {}
			mc._result = EmptyBox()  # maybe use "block" instead?
		}

		F deeper(mc:MatchContext, cb:Fun) {
			mc._path.push(null)
			cb.finally({
				mc._path.pop()
			})
		}

		F deeper(mc:MatchContext, new_fields:Hash, cb:Fun) {
			new_fields.each(F(k, v) {
				mc._deeper_saved_fields.dflt(k, []).push(mc.(k))
				mc.(k) = v
			})
			cb.finally({
				new_fields.each(F(k, v) {
					mc.(k) = mc._deeper_saved_fields[k].pop()
				})
			})
		}

		F set_last_path_element(mc:MatchContext, x) {
			mc._path[mc._path.len() - 1] = x
			mc
		}

		F return(mc:MatchContext, x) {
			mc._result = FullBox(x)
			# Returning true to make "... -> Y.return(X)" work
			# Only needed if return() will be used in non "something -> HERE" context,
			# because "HERE" result is discarded
			true
		}
	}

	doc Negation. Intended use - in pattern matching.
	type Not
	F init(n:Not, val) { n.val = val }

	F =~(x, pattern) {
		mc = MatchContext(x)
		result = (=~)(x, pattern, mc)
		mc._result returns mc._result.get()
		if result is Bool {
			# TODO: Review MatchSuccess / MatchFailure construction (conversion from MatchContext)
			result returns MatchSuccess([x], pattern)
			return MatchFailure(x, pattern)
		}
		throw Error("=~ is expected to either set result or return a boolean").set(given=result)
	}

	doc A pair of pattern and an action to execute if the pattern matches.
	doc Currently, only callable actions are supported (Fun).
	doc %STATUS - experimental
	type PatternAction

	doc %STATUS - experimental
	F init(pa:PatternAction, pattern, action) {
		pa.pattern = pattern
		pa.action = action
	}

	doc %AUTO - pattern -> action
	doc %STATUS - experimental
	F '->'(pattern, action) PatternAction(pattern, action)

	doc %STATUS - experimental
	F =~(x, pa:PatternAction, mc:MatchContext) {
		result = (=~)(x, pa.pattern, mc)
		if result {
			pa::action(x, mc)
		}
		result
	}

	doc %STATUS - deprecated
	F Pred(pattern) {
		warn("Using deprecated Pred()")
		F deprecated_pred(x) x =~ pattern
	}

	# TODO: %RET - MatchResult
	doc %RET - not(a =~ b)
	F !~(x, pattern) not(x =~ pattern)

	F !~(x, pattern, mc:MatchContext) not((=~)(x, pattern, mc))

	doc %RET - x == bti
	F =~(x, bti:BasicTypeInstance, _mc:MatchContext) x == bti

	section "IfExists" {
		doc Pattern for optionally present fields.
		doc %EX - ({"a": 1}) =~ ({"a": Any, "b": IfExists(Int)})
		doc %EX - ({"a": 1, "b": 2}) =~ ({"a": Any, "b": IfExists(Int)})
		doc %EX - ({"a": 1, "b": "x"}) !~ ({"a": Any, "b": IfExists(Int)})
		type IfExists
		F init(ie:IfExists, pat) ie.pat = pat
		F =~(x, ie:IfExists, mc:MatchContext) (=~)(x, ie.pat, mc)
	}

	doc Checks whether object fields named after h hash keys match (=~) the corresponding hash values.
	doc Inspired by underscorejs' "matcher"
	F =~(x, h:Hash, mc:MatchContext) {
		# TODO: Maybe some better detection of x interface required (instead of Eachable2/NormalTypeInstance):
		# * must support "k in x"
		# * must support "x.(k)"
		(x is not Eachable2) and (x is not NormalTypeInstance) returns false
		x_keys = null

		mc.deeper({
			h.all(F(pat_k, pat_v) {
				if (=~)(pat_k, AnyOf(Str, Int, Real), mc) {
					if pat_k in x {
						(=~)(x.(pat_k), pat_v, mc.set_last_path_element(pat_k))
					} else {
						pat_v is IfExists
					}
				} else {
					assert(pat_v is not IfExists, 'IfExists value only works with keys of types: Str, Int, Real')
					if x_keys is Null {
						x_keys = x.Hash().keys()
					}
					x_keys.any(F(k) {
						(=~)(k, pat_k, mc) and (=~)(x.(k), pat_v, mc.set_last_path_element(k))
					})
				}
			})
		})
	}

	TEST ({"a": 1}) =~ ({"a": Any})
	TEST ({"a": 1}) !~ ({"a": Any, "b": Any})
	TEST ({"a": 1, "b": 2}) !~ ({"a": Any, "b": {false}})
	TEST ("zz") !~ ({"a": Any, "b": {false}})
	TEST ({"a": 1}) =~ ({"a": Any, "b": IfExists(Int)})
	TEST ({"a": 1, "b": 2}) =~ ({"a": Any, "b": IfExists(Int)})
	TEST ({"a": 1, "b": "x"}) !~ ({"a": Any, "b": IfExists(Int)})

	doc Checks that
	doc 1. The x is Eachable1 but not Str or Int
	doc 2. Each element of x matches (=~) corresponding element in a
	doc (If number of elements does not match - there is no match)
	F =~(x, a:Arr, mc:MatchContext) {
		x is Int or x is Str returns false
		x is not Eachable1 returns false
		l = x.len()
		l != a.len() returns false
		for(i;l) {
			(!~)(x[i], a[i], mc) returns false
		}
		true
	}

	TEST [1,2] =~ [Int, Any]
	TEST [1] !~ [Int, Any]

	# TODO: f(x, MatchContext) - when we know that f expects that
	doc %RET - f(x) 
	F =~(x, f:Fun, _mc:MatchContext) f(x).Bool()

	doc Check whether x is of type t
	doc %RET - x is t
	F =~(x, t:Type, _mc:MatchContext) x is t

	doc Check whether x is the literal value l (using ==)
	F =~(x, l:Lit, _mc:MatchContext) x == l.val
	TEST 1 !~ Lit(Int)
	TEST Int =~ Lit(Int)

	section "Repeat" {

		doc Represents repetition of a pattern (or potentially arbitrary data)
		type Repeat

		F init(r:Repeat, pattern, count:NumRange) {
			r.pattern = pattern
			r.count = count
		}

		F init(r:Repeat, pattern, count:Int) init(r, pattern, NumRange(count, count, include_start=1, include_end=1))

		F init(r:Repeat, pattern) init(r, pattern, 0..null)

		doc Check that x is a repetition of r.pattern and it occurs r.count times
		doc %RET - Bool
		F =~(x:Eachable1, r:Repeat, mc:MatchContext) block b {
			matched = 0
			# TODO: For speed, add "if" and define only one "over_max".
			F over_max(x:Int) { x >= r.count.end }
			F over_max(x:Int) { guard r.count.include_end; x > r.count.end }
			F over_max(x:Int) { guard r.count.end is Null; false }
			mc.deeper({
				x.each_idx_val(F(idx, item) {
					if (!~)(item, r.pattern, mc.set_last_path_element(idx)) {
						b.return(false)
					}
					matched += 1
					if over_max(matched) {
						b.return(false)
					}
				})
			})
			matched in r.count
		}

		TEST [1,2,3] =~ Repeat(Int, 3)
		TEST [1,2,3] !~ Repeat(Int, 2)
		TEST [1,2,3] =~ Repeat(Int)
		TEST [1,2,3] !~ Repeat(Str)
	}

	doc Negate the match
	doc %RET - Bool
	F =~(x, n:Not, mc:MatchContext) {
		(=~)(x, n.val, mc).not()
	}

	TEST 1 =~ Not(3)
	TEST not(1 =~ Not(1))

}

doc Map e to an Arr (array) of values using mapper.
doc e - Object of any type that has each(e, callback) implemented
doc %RET - Arr
doc %EX - [1,2,3].map(X*4)  # [4,8,12]
F map(e:Eachable, mapper:Fun)
	collector
		e.each(collect + mapper)

doc EXPERIMENTAL! Do not use!
doc Map e to same type. Mnemonics: "map original" / "MAP to Original type".
doc e - object of any type that has each(e, callback) implemented
doc e - Eachable1. WARNING: instances of same type as e must have empty constructor and push() method.
doc %RET - Of same type as e
doc %STATUS - experimental
doc %EX - Set([1,2]).mapo(X*2)  # Set([2,4])
F mapo(e:Eachable1, mapper:Fun) {
	t = Type(e)
	collector/t() {
		e.each(collect + mapper)
	}
}

TEST Set([1,2]).mapo(X*2) == Set([2,4])


doc Transform mapper to handle only items matching pattern. Non-matching items will be returned as is.
doc %EX - ["abc", 1, "def", 2].map(only(Int, X*2))  # ["abc", 2, "def", 4]
F only(pattern, mapper:Fun) {
	F wrapped_in_only(elt) {
		if elt =~ pattern {
			mapper(elt)
		} else {
			elt
		}
	}
}

TEST ["abc", 1, "def", 2].map(only(Int, X*2)) == ["abc", 2, "def", 4]

doc %STATUS - experimental
doc Same as only(pattern, mapper)(val)
F only(val, pattern, mapper:Fun) only(pattern, mapper)(val)

doc Filter e using pattern.
doc e - Eachable1. WARNING: instances of same type as e must have empty constructor and push() method.
doc pattern - When item =~ pattern returns true, the item will appear in the resulting array.
doc %EX - (1...10).filter(F(num) num % 2 == 0)  # Gives [2,4,6,8,10]
doc %EX - (1...10).filter(X<5)  # Gives [1,2,3,4]
doc %RET - Of same type as e
F filter(e:Eachable1, pattern=Bool.constructors) {
	t = Type(e)
	ret = t()
	e.each(F(elt) {
		if elt =~ pattern
			ret.push(elt)
	})
	ret
}

TEST [1,null,2,0].filter() == [1, 2]

doc Partition elements in something according to the pattern into two arrays.
doc First array contains all elements that match the pattern.
doc The second array contains all elements that do not match the pattern.
doc something - Eachable1
doc pattern - Test function or anything else acceptable by (=~), defaults to Bool.constructors
doc %RET - Array with two arrays in it
doc %EX - partition([1,10,2,20], X>=10)  # [[10, 20], [1, 2]]
F partition(something:Eachable1, pattern=Bool.constructors) {
	yes = []
	no = []
	something.each(F(elt) (if elt =~ pattern then yes else no).push(elt))
	[yes, no]
}

TEST partition([1,10,2,20], X>=10) == [[10, 20], [1, 2]]
TEST partition(["abc", "", "def", null]) == [["abc", "def"], ["", null]]

type ElementNotFound(LookupFail)

block u {
	global first, last
	doc Find first element in e that matches the pattern.
	doc pattern - Test function or anything else acceptable by =~, defaults to Bool.constructors
	doc %RET - Either the element or the provided default if element was not found.
	doc %EX - (10..20).first(F(x) x % 3 == 0)        # 12 - first item divisible by 3
	doc %EX - (10..20).first(F(x) x % 50 == 0, 1000) # 1000
	doc %EX - [false, 0, null, "xyz", 100].first()  # "xyz"
	doc %EX - [].first()                            # ElementNotFound exception
	F first(e:Eachable1, pattern=Bool.constructors, default=u) block b {
		e.each(F(i) {
			if i =~ pattern b.return(i)
		})
		default !== u returns default
		throw ElementNotFound("first() did not find the element").set('container', e).set('pattern', pattern)
	}

	TEST [1,2,3].first(X>1, 10) == 2
	TEST [1,2,3].first(X>5, 10) == 10
	TEST [1,2,3].first(X>1) == 2
	TEST {[1,2,3].first(X>5)}.assert(ElementNotFound)

	doc Find last element in e that matches the pattern.
	doc pattern - Test function or anything else acceptable by =~, defaults to Bool.constructors
	doc %RET - Either the element or the provided default if element was not found.
	doc %EX - [1,2,3].last(X>1, 10) == 3
	doc %EX - [].last()  # ElementNotFound exception
	F last(e:Eachable1, pattern=Bool.constructors, default=u) {
		result = Box()
		e.each(F(i){
			if i =~ pattern {
				result = FullBox(i)
			}
		})
		result returns result.get()
		default !== u returns default
		throw ElementNotFound("last() did not find the element").set('container', e).set('pattern', pattern)
	}

	TEST [1,2,3].last(X>1, 10) == 3
	TEST [1,2,3].last(X>5, 10) == 10
	TEST [1,2,3].last(X>1) == 3
	TEST {[1,2,3].last(X>5)}.assert(ElementNotFound)
}

doc Find the only element that matches the pattern and execute given code with the value
doc body - The code to execute when exactly one element that matches the pattern was found. Executed with the found value. It's value will be returned as result of the_one().
doc found_more - The code to execute when more than one element matches the pattern. It's value will be returned as result of the_one(). Defaults to throwing an exception.
doc found_none - The code to execute when none of the elements match the pattern. It's value will be returned as result of the_one(). Defaults to exception.
doc %RET - Result of running on of the following: body, found_more, found_none
doc %EX - F name(dn:MethodDocNode) {
doc %EX - 	dn.children.the_one(MethodNameDocNode).text[0]
doc %EX - }
F the_one(e:Eachable1, pattern=Any, body:Fun=identity, found_more:Fun=null, found_none:Fun=null) block b {
	ret = EmptyBox()
	e.each(F(elt) {
		if elt =~ pattern {
			if ret {
				not(found_more) throws ElementNotFound("the_one() had more than one match").set('container', e).set('pattern', pattern)
				b.return(found_more())
			}
			ret = FullBox(elt)
		}
	})
	if ret {
		body(ret.get())
	} else {
		not(found_none) throws ElementNotFound("the_one() had no matches").set('container', e).set('pattern', pattern)
		found_none()
	}
}

TEST ok = false; [1,2,11,3,4].the_one(X>10, F(the_value) { ok = the_value == 11 }); ok
TEST ok = false; [1,2,11,3,4].the_one(X>20, nop, found_none = { ok = true }); ok
TEST ok = false; [1,2,11,3,4].the_one(Int, nop, found_more = { ok = true }); ok
TEST [1,2,11,3,4].the_one(X>10) == 11
TEST { [1,2,11,12,4].the_one(X>10) }.assert(ElementNotFound)
TEST { [1,2,3,4].the_one(X>10) }.assert(ElementNotFound)
TEST [1, "a", "b"].the_one(Int) == 1
TEST [1].the_one() == 1
TEST { [1, "a", "b"].the_one(Str) }.assert(ElementNotFound)

doc Filter something to an Arr (array) of values matching the pattern
doc pattern - Decision function to be called with each item as first argument.
doc pattern - When item matches the pattern, the item will not appear in the resulting array
doc something - object of any type that has each(something, callback) implemented
doc %EX - (1...10).reject(F(num) num % 2 == 0)  # Gives [1,3,5,7,9]
doc %EX - (1...10).reject(X<5)  # Gives [5,6,7,8,9,10]
doc %RET - Arr
F reject(something:Eachable1, pattern=Bool.constructors) something.filter(Not(pattern))

doc EXPERIMENTAL! Do not use!
doc %STATUS - experimental
doc %EX - [1,2,3,1,2].take(X<3)  # [1,2]
F take(something:Eachable1, pattern) collector block b {
	something.each(F(elt) {
		if elt =~ pattern
			collect(elt)
		else
			b.return()
	})
}

TEST [1,2,3,1,2].take(X<3) == [1,2]

# Would look much better with an iterator of e.
doc EXPERIMENTAL! Do not use!
doc Filters out items that match the pattern at the beginning of e.
doc %STATUS - experimental
doc %EX - [1,2,3,1,2].drop(X<3)  # [3,1,2]
F drop(e:Eachable1, pattern) collector {
	do_collect = false
	e.each(F(elt) {
		do_collect = do_collect or elt !~ pattern
		if do_collect {
			collect(elt)
		}
	})
}

TEST [1,2,3,1,2].drop(X<3) == [3,1,2]

doc Replace all occurrences of src with dst
doc TODO: Return same type, not Arr
doc something - object of any type that has each(something, callback) implemented
doc %RET - Arr
doc %EX - ["ssh", "IP", "w"].replace("IP", "10.0.0.100")  # ['ssh','10.0.0.100','w']
F replace(e:Eachable1, src, dst) {
	guard (e is not Str) and (e is not Int)
	map(e, only(X == src, {dst}))
}

TEST ["ssh", "IP", "w"].replace("IP", "10.0.0.100") == ['ssh','10.0.0.100','w']

doc Combine items to a single value using the supplied binary function
doc First f is applied to start and the first element of something
doc then on each step f is applied to previous result and next element
doc of something.
doc start - First argument of f, for the first call of f
doc something - object of any type that has each(something, callback) implemented
doc f - The combining function
doc %EX - F sum(something) something.reduce(0, (+))
F reduce(something:Eachable1, start, f:Fun) {
	ret = start
	something.each(F(elt) ret = f(ret, elt))
	ret
}

TEST [1,2,3].reduce(0, (+)) == 6

type EmptyEachableFail(InvalidArgument)

doc Combine items to a single value using the supplied binary function
doc First f is applied to the first two elements of e
doc then on each step f is applied to previous result and next element
doc of e. Throws EmptyEachableFail if e has no elements. If e has only
doc one element, that element is returned.
doc e - object of any type that has each(e, callback) implemented
doc f - The combining function
doc %EX - F sum(e) e.reduce((+))
F reduce(e:Eachable1, f:Fun) {
	do_reduce = false
	ret = null
	e.each(F(elt) {
		if do_reduce {
			ret = f(ret, elt)
			return
		}
		ret = elt
		do_reduce = true
	})
	not(do_reduce) throws EmptyEachableFail("reduce(e:Eachable1, f:Fun): e must have at least one element").set('e', e)
	ret
}

TEST [10].reduce((+)) == 10
TEST [1,2,3].reduce((+)) == 6
TEST { [].reduce((+)) }.assert(EmptyEachableFail)

doc Deprecated.
doc Map when there is more than one element. If there is exactly one element, it's left as is
doc mapper - Will be called with zero based index and successive elements from arr
doc %STATUS - deprecated
doc %RET - Arr
F map_base_idx(base, n:Int, mapper:Fun) {
	warn("Using deprecated map_base_idx()")
	n == 1 returns [base]
	n.map(mapper(base, X))
}

doc Call cb with val
doc %RET - val
doc %EX - long_computation_part1().tap(F(x) echo("DEBUG: $x")).long_computation_part2()
F tap(val, cb:Fun) {
	cb(val)
	val
}

TEST ok=false; 7.tap({ok = A==7}) == 7 and ok

section "Functional operators" {
	doc Filter operator.
	doc Same as calling x.filter(pattern)
	doc %EX - [1,2,3,4] ? F(x) x > 2  # [3,4]
	F ?(x, pattern) x.filter(pattern)

	doc Map operator.
	doc Same as calling x.map(mapper)
	doc %EX - [1,2,3,4] / F(x) x * 10
	F /(x, mapper:Fun) x.map(mapper)

	doc Each operator.
	doc Same as calling x.each(cb)
	doc %EX - [1,2,3,4] % echo
	F %(x, cb:Fun) x.each(cb)

	doc Deprecated. Use expr.f() and expr.{ your_code }
	doc Call operator.
	doc Same as calling f(x)
	doc %EX - [1,2,3,4] \ echo
	doc %STATUS - deprecated
	F \(x, f:Fun) f(x)
}

doc Return a+b unless one of the arguments is falsy. In that case return that argument (a if both are falsy). Useful for building strings with optional parts.
doc %EX - status_detail = ' (' +? maybe_empty_array.join(',') +? ')'
doc %EX - echo("Status: ${main_status}${status_detail}")
doc %RET - a+b or a or b
F +?(a, b) {
	not(a) returns a
	not(b) returns b
	a + b
}

doc Checks whether element x is in Eachable1
doc x - Needle
doc e - Haystack
doc %EX -  1 in [1,2,3].Iter()  # true
doc %EX - 10 in [1,2,3].Iter()  # false
doc %RET - Bool
F in(x, e:Eachable1) e.any(X == x)

TEST ( 1 in [1,2,3].Iter()) == true
TEST (10 in [1,2,3].Iter()) == false

doc Push all elements of e into dst.
doc %RET - dst
F push_all(dst, e:Eachable1) {
	e.each(push(dst, X))
	dst
}

TEST a=[1,2]; a.push_all([3,4]); a==[1,2,3,4]


doc EXPERIMENTAL! Do not use! Especially don't count on returned value beyond obvious Bool(x) behaviour. Match anything.
doc %STATUS - deprecated
F ~(something, pattern) {
	warn("Using deprecated ~(something:Any, pattern:Any) with types something:${Type(something)} pattern:${Type(pattern)}")
	if something =~ pattern {
		MatchSuccess([something], pattern)
	} else {
		MatchFailure(something, pattern)
	}
}

section "Eachable1" {
	# Should be low priority (ordered before others) method
	F +(a:Eachable1, b:Eachable1) {
		guard Type(a) === Type(b)
		t = Type(a)
		guard t != Int
		guard t != Arr
		guard t != Str
		t().push_all(a).push_all(b)
	}

	TEST Lines(["ab", "cd"]) + Lines(["ef"]) == Lines(["ab", "cd", "ef"])

	doc EXPERIMENTAL! Do not use!
	doc Makes sure returned value is of type t. If x is already of type t, returns x.
	doc Otherwise, returns object of type t with single item x.
	doc t - a subtype of Eachable1
	doc %RET - Object of type t
	doc %STATUS - experimental
	F ensure(x, t:Type) {
		guard t <= Eachable1
		Type(x) === t returns x
		t().push(x)
	}

	doc Check whether Eachable1 has the given index: -len(e) <= i < len(e)
	doc %RET - Bool
	F has_index(e:Eachable1, i:Int) {
		l = len(e)
		i >= 0 returns i < l
		0 - i <= l
	}

	TEST [].has_index(0) == false
	TEST [].has_index(-1) == false
	TEST [100].has_index(0) == true
	TEST [100].has_index(1) == false
	TEST [100].has_index(-1) == true
	TEST [100].has_index(-2) == false

	doc Convert Eachable1 into JSON compatible data structure - array
	F JsonData(e:Eachable1) {
		guard e !~ AnyOf(Int, Str, Arr, MultiMethod)
		e.map(JsonData)
	}
}

section "ArrLike" {
	# TODO [doc]: examples in methods

	doc Parent type for user-defined types with array-like behaviour. Use in cases when you would like to inherit from built-in Arr. Inheriting from built-ins is not possible for now.
	doc items - default field for the underlying array
	doc %EX - type T(ArrLike)
	doc %EX - F Str(t:T) "<My array has ${len(t)} items totalling ${sum(t)}>"  # Override one of the Arr methods
	doc %EX - a = T()
	doc %EX - a.push(10)
	doc %EX - a.push(20)
	doc %EX - echo(a)  # <My array has 2 items totalling 30>
	doc %EX -
	doc %EX - # If you need init() you should have something like the following to allow ArrLike initialization:
	doc %EX - init(t:T) {
	doc %EX - 	super(t)
	doc %EX - 	...
	doc %EX - }
	type ArrLike(Eachable1)

	F init(al:ArrLike) al.meta().ArrLike = []

	doc ArrLike constructor.
	doc field - DEPRECATED name of the field that holds the underlying array.
	doc Throws NotImplemented if field is specified
	F init(al:ArrLike, field:Str=null) {
		field throws NotImplemented("ArrLike(Str) is deprecated")
		super(al)
	}

	F init(al:ArrLike, e:Eachable1) {
		super(al)
		al.push_all(e)
	}

	F init(al:ArrLike, arr:Arr) {
		super(al)
		al.meta().ArrLike = arr
	}

	doc Get length of the underlying array.
	F len(al:ArrLike)               al.meta().ArrLike.len()

	doc Set element in the underlying array.
	F '[]'(al:ArrLike, idx:Int)     al.meta().ArrLike[idx]

	doc Get element from the underlying array.
	F '[]='(al:ArrLike, idx:Int, x) al.meta().ArrLike[idx] = x

	doc Get element at the given index or return dflt if the index is out of range (element at the given index does not exist). See get(Arr).
	F get(al:ArrLike, idx:Int, dflt) al.meta().ArrLike.get(idx, dflt)

	doc Call cb for each element in the underlying array.
	doc %RET - al
	F each(al:ArrLike, cb:Fun) al::{ A.meta().ArrLike.each(cb) }

	doc Check whether al has any elements.
	F Bool(al:ArrLike) al.meta().ArrLike.Bool()

	# NOTE: Never run because of Arr(Eachable1)
	doc Get the underlying array
	F Arr(al:ArrLike) al.meta().ArrLike

	doc Push an element to the underlying array.
	F push(al:ArrLike, val) al::{ A.meta().ArrLike.push(val) }

	doc Join items to a single string using given separator s
	doc %RET - Str
	F join(al:ArrLike, s:Str) al.meta().ArrLike.join(s)

	doc Return array made of given field of each element of given array.
	doc Will throw KeyNotFound if any of the elements does not have the desired field.
	doc Use get() to handle missing field differently.
	F .(al:ArrLike, s:Str) al.meta().ArrLike.(s)

	doc Defines collector { ... collect(...) ... } behaviour for ArrLike.
	doc Very similar to collector for Arr. See collector(Arr,Fun).
	F collector(al:ArrLike, body:Fun) al::{ body(F(elt) A.push(elt)) }

    doc t - subtype of ArrLike
    doc %RET - of type t
	F ensure(x:Arr, t:Type) {
		guard t <= ArrLike
		t(x)
	}

	doc Convert ArrLike to a human-readable representation
	F Str(a:ArrLike) "<${a.Type().name} ${a.Arr().join(', ')}>"

    # TODO: When convenient from pattern matching perspective, also check instance type
    TEST type T(ArrLike); [1,2].ensure(T) =~ [1,2]
    TEST type T(ArrLike); "abc".ensure(T) =~ ["abc"]

}

section "AnyOf(ArrLike)" {
	doc Should probably inherit from Set, not ArrLike.
	type AnyOf(ArrLike)

	doc Initializes AnyOf with the given alternatives.
	F init(a:AnyOf, *alternatives) {
		guard alternatives.len() > 1
		super(a, alternatives)
	}

	doc Checks whether x matches (~) any of the alternatives.
	F ~(x, a:AnyOf) block b {
		a.each(F(alt) {
			if (m = x ~ alt) b.return(m)
		})
		MatchFailure(x, a)
	}

	TEST ("abc" ~ AnyOf(/x/, /a/)) is MatchSuccess
	TEST ("abc" ~ AnyOf(/x/, /y/)) is MatchFailure
	TEST ("abc" ~ AnyOf([Int, Str])) is MatchSuccess
	TEST ("abc" ~ AnyOf([Int, Num])) is MatchFailure

	doc Check whether one of the patterns (elements of AnyOf) matches
	doc %EX - {"k1": "v1", "k2": "v2", "k3": "v3"}.filterk(AnyOf("k1", "k3"))  # {"k1": "v1", "k3": "v3"}
	F =~(x, a:AnyOf, mc:MatchContext) a.any(F(pattern) (=~)(x, pattern, mc))

	TEST {"k1": "v1", "k2": "v2", "k3": "v3"}.filterk(AnyOf("k1", "k3")) == {"k1": "v1", "k3": "v3"}

	doc Checks whether any of the items are truthy.
	F Bool(a:AnyOf) a.any()

	TEST AnyOf([1, false]).Bool()
	TEST AnyOf([0, false]).Bool().not()

}

section "AllOf(ArrLike)" {
	doc Should probably inherit from Set, not ArrLike.
	type AllOf(ArrLike)

	doc Initializes AllOf with the given items.
	F init(a:AllOf, *items) {
		guard items.len() > 1
		super(a, items)
	}

	doc Checks whether one of the patterns (elements of AllOf) matches
	doc %EX - {"k1": "v1", "k2": "v2", "kk3": "vv3"}.filterk(AllOf(/^k/, {len(A) <= 2})) == %{k1 v1 k2 v2}
	F =~(x, a:AllOf, mc:MatchContext) a.all(F(pattern) (=~)(x, pattern, mc))

	TEST {"k1": "v1", "k2": "v2", "kk3": "vv3"}.filterk(AllOf(/^k/, {len(A) <= 2})) == %{k1 v1 k2 v2}

	doc Checks whether all items are truthy.
	F Bool(a:AllOf) a.all()

	TEST AllOf([1, 2]).Bool()
	TEST AllOf([1, 2, false]).Bool().not()
}

section "HashLike" {
	# TODO [doc]: examples in methods
	doc Base type for user-defined hash-like types. This is a workaround: it's not possible currently no inherit from the built-in Hash type.
	type HashLike(Eachable2)

	doc Check whether k is in the HashLike
	doc %RET - Bool
	F in(k, hl:HashLike)         k in hl.meta().HashLike

	doc Get number of key-value pairs in a HashLike
	doc %RET - Int
	F len(hl:HashLike)           hl.meta().HashLike.len()


	doc Get value by key. Throws KeyNotFound.
	doc %AUTO - your_hashlike[k]
	F '[]' (hl:HashLike, k)      hl.meta().HashLike[k]

	doc Set value.
	doc %AUTO - your_hashlike[k] = v
	F '[]='(hl:HashLike, k, v)   hl.meta().HashLike[k] = v

	doc Get value by key. Throws KeyNotFound.
	doc %AUTO - your_hashlike.literal_key
	doc %RET - Any
	F .(hl:HashLike, k)          hl.meta().HashLike[k]

	doc Set value.
	doc %AUTO - your_hashlike.literal_key = v
	doc %RET - v
	F .=(hl:HashLike, k, v)      hl.meta().HashLike[k] = v

	doc Get value by key or dflt if it does not exist
	doc %RET - Any
	F get(hl:HashLike, k, dflt)  hl.meta().HashLike.get(k, dflt)

	doc Get value by key or null if it does not exist
	doc %RET - Any
	F get(hl:HashLike, k)        hl.get(k, null)

	doc Iterate over keys and values.
	doc %EX - my_hashlike.each(F(k, v) echo("$k=$v"))
	doc %RET - hl
	F each(hl:HashLike, cb:Fun) hl::{ A.meta().HashLike.each(cb) }

	doc Get keys
	doc %RET - Arr
	F keys(hl:HashLike)          hl.meta().HashLike.keys()

	doc Get values
	doc %RET - Arr
	F values(hl:HashLike)        hl.meta().HashLike.values()

	doc Check whether hl has any elements.
	doc %RET - Bool
	F Bool(hl:HashLike)          hl.meta().HashLike.Bool()

	F map_idx_key_val(hl:HashLike, mapper:Fun) hl.meta().HashLike.map_idx_key_val(mapper)

	doc Filter hash. Build new HashLike with kev-value pairs selected by predicate.
	doc predicate - Test function to be called with one key and one value at a time.
	doc %EX - my_hashlike.filter(F(k, v) k == 'a')
	doc %RET - value of the same type as hl
	F filter(hl:HashLike, predicate:Fun) {
		t = Type(hl)
		t(hl.meta().HashLike.filter(predicate))
	}

	TEST HashLike({"a": 1, "b": 2}).filter(F(k, v) v==1) == HashLike({"a": 1})
	TEST HashLike({"a": 1}).filter(F(k, v) v==10) == HashLike()
	TEST type MyHashLike(HashLike); MyHashLike({"a": 1, "b": 2}).filter(F(k, v) v==1) == MyHashLike({"a": 1})

	doc Remove k from hl
	doc %RET - hl
	F del(hl:HashLike, k) hl::{ A.meta().HashLike.del(k) }

	TEST h=HashLike({"a": 1, "b": 2}); h.del("a"); h == HashLike({"b": 2})
	TEST { h=HashLike({"a": 1, "b": 2}); h.del("c") }.assert(KeyNotFound)

	doc Create a HashLike.
	doc h - If provided, used as initial value.
	doc %EX - HashLike(%{a aha b bee}) # <HashLike a=aha b=bee>
	F init(hl:HashLike, h:Hash=null) hl.meta().HashLike = h or {}

	doc Get the underlying Hash with all the keys/values of the HashLike.
	doc Note: the returned value is not a copy.
	doc %RET - Hash
	F Hash(hl:HashLike) hl.meta().HashLike

	doc Convert HashLike into JSON compatible data structure - object
	F JsonData(hl:HashLike) hl.map(F(k, v) [JsonData(k), JsonData(v)]).Hash()
}


section "Set" {

	doc Represents a set of items
	type Set(Eachable1)

	doc Initialize a set
	F init(s:Set) {
		s.val = {}
	}

	doc Convert array to set
	F init(s:Set, e:Eachable1) {
		super(s)
		e.each({ s.val[A] = true })
	}

	doc Add an element to the set
	doc %RET - s
	F push(s:Set, v) s::{ A.val[v] = true }

	doc Get number of items in the set
	doc %RET - Int
	F len(s:Set) s.val.len()

	doc Call cb for each value in the set
	doc %RET - s
	F each(s:Set, cb:Fun) s::{ A.val.keys().each(cb) }

	doc Check if the value is in the set
	doc %RET - Bool
	F in(x, s:Set) x in s.val

	doc Check whether the set is not empty
	F Bool(s:Set) Bool(s.val)

	doc Convert the set to a human-readable representation
	F Str(s:Set) "<${s.Type().name} ${s.val.keys().join(', ')}>"

	doc Set difference
	doc %RET - Set
	F -(a:Set, b:Set) a.filter(X not in b)

	TEST Set([1,2]) - Set([2]) == Set([1])

	doc Set union
	doc %RET - Set
	F +(a:Set, b:Set) Set().set('val', a.val + b.val)

	TEST Set([1,2]) + Set([3]) == Set([1,2,3])

	doc Check whether all values in a are also in b
	F '<='(a:Set, b:Set) {
		len(a) <= len(b) and a.all(X in b)
	}

	TEST Set([1,2]) + Set([3]) <= Set([1,2,3])
	TEST Set([1,2]) <= Set([1,2,3])
	TEST not(Set([1,2,4]) <= Set([1,2,3]))

	doc Check whether all values in b are also in a
	F '>='(a:Set, b:Set) b <= a

	doc Inspect Set
	doc %RET - Arr of Str
	F inspect(path:Arr, a:Set) {
		["${_inspect_path_to_str(path)} - Set of size ${a.len()}"] + a.map_idx_val({
			inspect(path + [A], B)
		}).flatten()
	}

	doc Defines collector { ... collect(...) ... } behaviour for Set.
	F collector(s:Set, body:Fun) {
		body(F(elt) s.push(elt))
		s
	}

	doc Make shallow copy of a Set
	F copy(s:Set) collector/Set() s.each(collect)
	TEST s1 = Set([1,2]); s2 = s1.copy(); s1.push(3); s2.Arr() == [1,2]

}


section "Named Instances" {
	doc "Named instances" are typically called enums or enumerated values in other languages.
	doc %EX - type Color(NamedInstances)
	doc %EX -
	doc %EX - F init(c:Color, numval:Int) c.numval = numval
	doc %EX -
	doc %EX - Color.NamedInstances = ns {
	doc %EX - 	RED = Color(4)
	doc %EX - 	GREEN = Color(2)
	doc %EX - 	BLUE = Color(1)
	doc %EX - }
	doc %EX -
	doc %EX - echo(Color.NamedInstances)  # {RED=<Color numval=4 name=RED>, ...}
	doc %EX - echo(2.decode(Color))       # <Color numval=2 name=GREEN>
	doc %EX - echo("RED".decode(Color))   # <Color numval=4 name=RED>
	type NamedInstances

	doc %AUTO - SUBTYPE_OF_NAMEDINSTANCES.NamedInstances
	doc %EX - echo(Color.NamedInstances is Namespace)  # true
	F .(t:Type, field:Str) {
		guard field == 'NamedInstances'
		guard t <= NamedInstances
		ret = t.meta().NamedInstances
	}

	doc %AUTO - SUBTYPE_OF_NAMEDINSTANCES.NamedInstances = ...
	F .=(t:Type, field:Str, ns:Namespace) {
		guard field == 'NamedInstances'
		guard t <= NamedInstances
		ns.each(F(k, v) {
			v is not t throws InvalidArgument("${t.name}.NamedInstances values must be of type ${t.name}").set(key=k, value=v)
			v.name = k
		})
		t.meta().NamedInstances = ns

		keys_to_instances = {}
		t.NamedInstances.each(F(name, instance) {
			instance.Hash().each(F(field, value) {
				keys_to_instances.dflt(value, []).push(instance)
			})
		})
		t.meta().NamedInstancesByAnyValue = keys_to_instances
	}

	doc %AUTO - SUBTYPE_OF_NAMEDINSTANCES.NamedInstances = ['SOME', 'NAMES', ...]
	F .=(t:Type, field:Str, a:Arr) {
		guard field == 'NamedInstances'
		guard t <= NamedInstances
		guard a.all(Str)
		instances = ns {}
		a.each(F(name) instances::(name) = t())
		t.NamedInstances = instances
	}

    TEST type T(NamedInstances); T.NamedInstances = %[RED GREEN BLUE]; i = [T::RED, T::GREEN, T::BLUE]; i.all(T) and T::RED.name == 'RED'

	doc %AUTO - SUBTYPE_OF_NAMEDINSTANCES::INSTANCE_NAME
	doc %EX - echo(Color::RED)   # <Color numval=4 name=RED>
	F '::'(t:Type, k:Str) {
		guard t <= NamedInstances
		t.NamedInstances[k]
	}

	doc Resolve named instance of t by uniquely-identifying value of any field
	doc %EX - echo("RED".decode(Color))   # <Color numval=4 name=RED>
	F decode(value, t:Type) {
		guard t <= NamedInstances

		F invalid_arg(s) throw InvalidArgument(s).set(value=value, type=t)

		t.meta().NamedInstancesByAnyValue.get(value, []).the_one(
			found_none = { invalid_arg("Value ${value} does not identify any named instance of ${t.name}") }
			found_more = { invalid_arg("Value ${value} is not a unique identifier of an instance of ${t.name}") }
		)
	}

	TEST global init; type Color(NamedInstances); F init(c:Color, numval:Int) c.numval = numval; Color.NamedInstances = ns { RED = Color(4); GREEN = Color(2); BLUE = Color(1) ; }; Color.NamedInstances is Namespace and 2.decode(Color) == Color::GREEN and "RED".decode(Color) == Color::RED
}

section "Hook" {
	doc Hook is a simple pub-sub
	type Hook(HashLike)

	doc Hook constructor.
	doc %RET - Hook
	F init(hook:Hook) {
		super(hook)
		hook.meta().idx = 0
	}

	doc Add unnamed handler.
	doc The hook is automatically named "pushed-N" where N is sequential integer.
	doc %RET - New hook name
	F push(hook:Hook, handler:UserDefinedMethod) {
		name = "pushed-${hook.meta().idx}"
		hook.meta().idx += 1
		hook[name] = handler
		name
	}

	# TODO: consider optional? try/catch isolation
	doc Runs all handlers passing all args.
	doc args - Arguments to pass to handlers
	doc %RET - Arr. Results from all the handlers
	F call(hook:Hook, *args) hook.meta().HashLike.mapv(X(*args))
}

section "Real" {
	# TODO: something more efficient
	doc Convert a string to real (floating) number, inefficiently
	doc %RET - Real
	doc %EX - Real("1.1")  # 1.1
	F Real(s:Str) {
		parts = s.split('.')
		parts.len() == 1 returns Real(Int(parts[0]))
		parts.len() != 2 throws InvalidArgument("Invalid argument ${s}")
		l = parts[1].len()
		frac = Real(Int(parts[1]))
		for(i;l) frac = frac / 10.0
		Real(Int(parts[0])) + frac
	}

	TEST Real('1.1') == 1.1

	doc Convert Real into JSON compatible data structure - number
	F JsonData(r:Real) r

	F Bool(r:Real) r != 0.0
}

# === NormalTypeConstructor ===============================

doc String representation of normal type constructor. NormalTypeConstructor
doc %RET - "<NormalTypeConstructor>"
doc %EX - Box.constructors.Arr()[0].Str().echo()  # Outputs: <NormalTypeConstructor>
F Str(ntc:NormalTypeConstructor) "<NormalTypeConstructor>"

section "Type" {

	doc String representation of a type
	doc %RET - "<Type NAME>"
	doc %EX - Real.Str().echo()  # Outputs: <Type Real>
	F Str(t:Type) "<Type ${t.name} with ${t.constructors.len()} constructor(s) and ${t.meta().len()} meta entries>"

	# TODO: Reorganize and move out of Type section
	doc Decode (parse) strings such as command line arguments or environment variables to result given type
	doc TODO: Consider renaming to UnArgv or decode_arg
	doc %STATUS - experimental
	F decode(s:Str, t:Type) {
		t == Any returns s # For ArgvMatcher
		F _fail(cause:Exception=null) {
			args = ["Failed to decode value. Could not convert given value to type ${t.name}", cause].reject(Null)
			throw DecodeFail(*args).set('value', s).set('target_type', t)
		}
		if t in [Int, Real, Str] {
			return try {
				t(s)
			} catch(e:InvalidArgument) {
				_fail(e)
			}
		}
		if t == Bool {
			s ~ /^(1|(y(es)?)|true|on)$/i returns true
			s ~ /^(0|(no?)|false|off)$/i returns false
			_fail()
		}
		guard false
	}

	TEST decode("no", Bool) == false
	TEST decode("0", Bool) == false
	TEST decode("yes", Bool) == true
	TEST { decode("ya", Bool) }.assert(DecodeFail)
	TEST decode("1", Bool) == true
	TEST decode("1", Int) == 1
	TEST decode("1", Real) == 1.0

	doc Check whether t is maybe_supertype or its subtype
	doc Note that if t and maybe_supertype are same type, this method also returns true.
	doc %RET - Bool
	doc %EX - Lines <= Eachable1  # true
	doc %EX - Eachable <= Lines  # false
	F '<='(t:Type, maybe_supertype:Type) {
		maybe_supertype === Any returns true
		F kern(t:Type) {
			t === maybe_supertype returns true
			t.parents.any(kern)
		}
		kern(t)
	}

	TEST Lines <= Eachable1
	TEST Lines <= Eachable
	TEST Int <= Any
	TEST Eachable <= Lines == false

	doc Similar to t <= maybe_supertype but returns false if t === maybe_supertype
	doc %RET - Bool
	F '<'(t:Type, maybe_supertype:Type) t !== maybe_supertype and t <= maybe_supertype

	doc %STATUS - deprecated
	doc Use t <= maybe_supertype
	F is_subtype(t:Type, maybe_supertype:Type) {
		warn("is_subtype(t:Type, maybe_supertype:Type) is deprecated, use t <= maybe_supertype")
		t <= maybe_supertype
	}

	doc %STATUS - deprecated
	doc Use Type(x)
	doc %RET - Type
	F typeof(x) {
		warn("typeof(Any) is deprecated")
		Type(x)
	}
}

doc Set a field on all elements if it's not already set
doc e - Eachable1
doc %EX - my_items.dflt("source", "(unknown)")
doc %RET - e
F dflt(e:Eachable1, k, v) e.each(X.dflt(k, v))

TEST [{}, {"x": 1}].dflt("x", 100) == [{"x": 100}, {"x": 1}]

doc Equality test for normal type instances: must be of same type and have same fields and their values
doc %RET - Bool
doc %EX - type T
doc %EX - t1 = T()
doc %EX - t1.a = 1
doc %EX - t2 = T()
doc %EX - t2.a = 1
doc %EX - echo(t1 == t2)  # Outputs: true
F ==(a:NormalTypeInstance, b:NormalTypeInstance) {
	Type(a) != Type(b) returns false
	# TODO: more efficient implementation:
	#       * Provide low level primitive to either access the fields (ll_nti_hash) or iterate them
	#       * Use it here
	Hash(a) == Hash(b)
}

# TODO: move to somewhere more appropriate, keep in mind - must be after dflt(NormalTypeInstance, ...)
doc Set a key if it's not already set
doc %EX - mysomething.dflt(k, []).push(elt)
doc %RET - Key value, the already-existed or new.
F dflt(hl:HashLike, k, v) hl.meta().HashLike.dflt(k, v)

doc Check whether x is of type t
doc %RET - MatchResult
F ~(x, t:Type) {
	if x is t {
		MatchSuccess([x], t)
	} else {
		MatchFailure(x, t)
	}
}

# === Exceptions =================================

# TODO: Investigate why type CError(Error) does not work at this point
doc Base type for exceptions arising from errors returned by calling C functions
type CError(Error)

doc CError constructor. In addition to storing message field, adds errno and errno_name fields.
F init(e:CError, errno:Int, message:Str) {
	super(e, message)
	e.errno = errno
	e.errno_name = c_strerror(e.errno)
}

doc CError constructor. In addition to storing message field, adds errno and errno_name fields.
F init(e:CError, message:Str) super(e, c_errno(), message)


doc Exception representing a failure to kill() a process
type KillFail(CError)

# === Lock =======================================

doc Synchronization lock.
type Lock

doc Re-entrant synchronization lock. Same thread can re-acquire the lock.
type ReentrantLock(Lock)

doc Failure to perform an operation on a lock.
type LockFail(Exception)

doc Initialize LockFail exception.
F init(e:LockFail, op:Str, code:Int, msg:Str) init(args())

doc Initialize Lock. Creates and initializes pthread_mutex.
F init(l:Lock) {
	l.lock = c_pthread_mutex_t()
	code = c_pthread_mutex_init(l.lock)
	code throws LockFail("c_pthread_mutex_init", code, "Call to underlying API failed")
}

doc Block till the lock is avaiable and then acquire the lock.
doc %EX - l = Lock()
doc %EX - ...
doc %EX - l.acquire()
doc %EX - modify_global_state_safely(...)
doc %EX - l.release()
F acquire(l:Lock) {
	c_pthread_mutex_lock(l.lock)
	l
}

doc Release the lock
doc %EX - l = Lock()
doc %EX - ...
doc %EX - l.acquire()
doc %EX - modify_global_state_safely(...)
doc %EX - l.release()
F release(l:Lock) {
	c_pthread_mutex_unlock(l.lock)
	l
}

doc Call cb with lock l held. Releases the lock after cb returns or throws.
doc %EX - l = Lock()
doc %EX - ...
doc %EX - l.acquire(F() {
doc %EX -   modify_global_state_safely(...)
doc %EX - })
F acquire(l:Lock, cb:Fun) {
	l.acquire()
	try cb()::{ l.release() }
	catch(e:Exception) {
		l.release()
		throw e
	}
}

TEST Lock().acquire(F() 1) == 1

doc Initialize Lock. Creates and initializes PTHREAD_MUTEX_RECURSIVE pthread_mutex.
F init(l:ReentrantLock) {
	l.lock_attr = c_pthread_mutexattr_t()
	code = c_pthread_mutexattr_init(l.lock_attr)
	code throws LockFail("c_pthread_mutexattr_init", code, "Call to underlying API failed")
	c_pthread_mutexattr_settype(l.lock_attr, C_PTHREAD_MUTEX_RECURSIVE)
	l.lock = c_pthread_mutex_t()
	code = c_pthread_mutex_init(l.lock, l.lock_attr)
	code throws LockFail("c_pthread_mutex_init", code, "Call to underlying API failed")
}

doc Convert c_pthread_mutex_t to Str for displaying to humans.
F Str(cpm:c_pthread_mutex_t) "<c_pthread_mutex_t>"

doc Convert c_pthread_mutexattr_t to Str for displaying to humans.
F Str(cpma:c_pthread_mutexattr_t) "<c_pthread_mutexattr_t>"

section "Range" {
	doc A range
	type Range
		NumRange.inherit(Range)
		NumRange.inherit(Eachable1)

	doc A range with start and end expressed as predicates.
	type PredRange(Range)

	doc Range constructor. Throws InstantiatingAbstractType if r is exactly of type Range (not a sub-type).
	F init(r:Range, start, end, include_start=true, include_end=false, step=1) {
		r.Type() == Range throws InstantiatingAbstractType(Range)
		init(args())
	}

	doc Constructs open-open predicate range
	doc %RET - PredRange
	doc %EX - [10,200,300,40,50][(X==10)..(X==40)]          # [200, 300]
	doc %EX - ["abc", "aaa", "bbb", "def"][/^abc/../^def/]  # ["aaa", "bbb"]
	F ..(start, end)  PredRange(start, end, false, false)

	doc Constructs closed-closed predicate range
	doc %RET - PredRange
	doc %EX - [10,200,300,40,50][(X==10)...(X==40)]          # [10,200,300,40]
	doc %EX - ["abc", "aaa", "bbb", "def"][/^abc/.../^bbb/]  # ["abc", "aaa", "bbb"]
	F ...(start, end) PredRange(start, end, true, true)

	doc Constructs closed-open numerical range
	doc start - numerical or null (at least one of start or end must be non-null)
	doc end - numerical or null (at least one of start or end must be non-null)
	doc %RET - NumRange
	doc %EX - (1..4).sum()  # 6
	F ..(start, end) {
		guard start is Num or end is Num
		guard start is Num or start is Null
		guard end is Num or end is Null
		NumRange(start, end, true, false)
	}

	doc Constructs closed-closed numerical range
	doc %RET - NumRange
	doc %EX - (1...4).sum()  # 10
	F ...(start, end) {
		guard start is Num or end is Num
		guard start is Num or start is Null
		guard end is Num or end is Null
		NumRange(start, end, true, true)
	}

	TEST 0..null is NumRange
	TEST null..null is PredRange
	TEST null.."xyz" is PredRange

	doc Iterates over the elements of r, passing each in turn to cb.
	doc cb - Function to be called with values from r
	doc args - Additional arguments for calling cb
	doc %RET - r
	doc %EX - s=0
	doc %EX - (1...10).each(F(i) { global s; s+=i })
	doc %EX - echo(s)  # Outputs: 55
	F each(r:NumRange, cb:Fun) r.Iter().each(cb)

	TEST (1..3).map(X*2) == [2, 4]
	TEST (1...3).map(X*2) == [2, 4, 6]

	TEST (10..20).first(F(x) x % 3 == 0) == 12

	doc Check whether the number is in range
	doc 10 in 10..20  # true
	doc 1 in 10..20   # false
	F in(n:Int, r:NumRange) {
		econd {
			r.include_start and n == r.start true
			r.start is not Null and n <= r.start false
			r.include_end and n == r.end true
			r.end is not Null and r.end <= n false
			true true
		}
	}

	# TODO: better coverage
	TEST not(1 in NumRange(1,2,false,true))
	TEST 2 in NumRange(1,2,false,true)
	TEST not(10 in NumRange(1,2,false,true))
	TEST 20 in NumRange(1,30,false,true)
	TEST 30 in NumRange(1,30,false,true)

	doc Convert range to human readable representation
	F Str(r:Range) "<${r.Type().name} ${r.start}..${r.end} include_start=${r.include_start} include_end=${r.include_end} step=${r.step}>"

	doc Length of a NumRange. Only defined for Int start and end.
	doc Equals to how many times cb will be invoked in each(r, cb).
	F len(r:NumRange) {
		guard [r.start, r.end].all(Int)
		r.end - r.start - 1 + r.include_start.Int() + r.include_end.Int()
	}

	TEST len(1..3) == 2
	TEST len(1...3) == 3
	TEST NumRange(1, 3, include_start=false, include_end=false).len() == 1

	doc Checks whether x is in the range.
	doc %EX - 1 =~ 0..5  # true
	F =~(x, nr:NumRange, _mc:MatchContext) {
		x is not Num returns false
		x in nr
	}

	TEST 1 =~ 0..5
	TEST 0 =~ 0..5
	TEST 5 !~ 0..5

	doc Checks that x is in the range.
	doc %EX - ensure(3, 3..10)  # 3
	F ensure(n:Int, r:NumRange) cond {
		n in r n
		n < r.start and r.include_start r.start
		n < r.start and not(r.include_start) r.start + r.step
		n > r.end and not(r.include_end) r.end - r.step
		n > r.end and r.include_end r.end
	}

	TEST ensure(1, 3..10)   == 3
	TEST ensure(20, 3...10) == 10
	TEST ensure(12, 3...null) == 12
	TEST ensure(40, 3..35) == 34
	TEST ensure(40, 3...35) == 35

}

# TODO: think about multi-valued results (say 10 hosts, 8 succeeded and 2 failed)
# TODO: think about Argv cooperation. Maybe Failure is NoData and Success is FullBox?
# === Syntactic sugar ============================

doc Defines collector { ... collect(...) ... } behaviour for arrays
doc a - Initial array
doc body - The body after collector keyword and possible initial value, wrapped in a function
doc body - "collector THIS_CODE" or "collector/my_init THIS_CODE"
doc %RET - Constructed array
doc %EX - items = collector {
doc %EX -   collect(10)
doc %EX -   for(i;2) collect(i)
doc %EX -   collect(20)
doc %EX - }
doc %EX - echo(items)  # Outputs: [10,0,1,20]
doc %EX -
doc %EX - # Or start with few items:
doc %EX - items = collector/[100,200] {
doc %EX -   collect(10)
doc %EX -   for(i;2) collect(i)
doc %EX -   collect(20)
doc %EX - }
doc %EX - echo(items)  # Outputs: [100,200,10,0,1,20]
F collector(a:Arr, body:Fun) {
	body(F(elt) a.push(elt))
	a
}

doc Defines collector { ... collect(...) ... } behaviour for hashes
doc h - Initial hash
doc body - The body after collector keyword and initial value, wrapped in a function
doc body - "collector/{'my': 'hash'} THIS_CODE"
doc %RET - Constructed array
doc %EX - arr = [{"Name": "n1", "Value": "v1"},{"Name": "n2", "Value": "v2"}]
doc %EX - my_hash = collector/{}
doc %EX - 	arr.each(F(elt) collect(elt.Name, elt.Value))
doc %EX - echo(my_hash)  # Outputs: {n1=v1, n2=v2}
F collector(h:Hash, body:Fun) {
	body(F(k, v) h[k] = v)
	h
}

doc Defines collector { ... collect(...) ... } behaviour for integers (summarizes collected items).
doc n - Initial number
doc body - The body after collector keyword and initial value, wrapped in a function
doc body - "collector/100 THIS_CODE"
doc %RET - Constructed array
doc %EX - collector/0 { (1...10).each(collect) }  # 55
F collector(n:Int, body:Fun) {
	body(F(incr) n=n+incr)
	n
}

block _ {
	global collector
	join_strings = join.Arr()[0]  # Performance hack: 18 sec -> 4.3 sec for 1M collectors

	doc EXPERIMENTAL! Do not use!
	F collector(s:Str, body:Fun) {
		ret = [s]
		body(ret.push(X))
		ret.join_strings('')
	}
}

TEST (collector/"a" collect("b")) == "ab"

doc Compare to null
doc %RET - false
F ==(a:Null, b) false

doc Compare to null
doc %RET - false
F ==(a, b:Null) false

doc Compare to null
doc %RET - true
F ==(a:Null, b:Null) true

doc Run cleanup after successful execution of body or exception in body
doc body - Main code to execute
doc cleanup - Cleanup code to execute
doc %RET - Whatever body call returns
doc %EX - finally(
doc %EX -   { while entry = c_readdir(d) { ... } },
doc %EX -   { ... c_closedir(d) ...}
doc %EX - )
doc %EX - # Alternative function call syntax:
doc %EX - finally(
doc %EX -   body = {
doc %EX -     while entry = c_readdir(d) {
doc %EX -       cb(Path(dirname / entry.d_name, subtype=subtype))
doc %EX -     }
doc %EX -   }
doc %EX -   cleanup = {
doc %EX -     r = c_closedir(d)
doc %EX -     r != 0 throws DirFail('Failed to close directory after listing').set('dirname', dirname)
doc %EX -   }
doc %EX - )
F finally(body:Fun, cleanup:Fun) {
	ret = Result(body)
	cleanup()
	ret is Failure throws ret.val
	ret.get()
}

TEST a=0; {1/1}.finally({a=10}) == 1 and a == 10
TEST a=0; (try finally({1/0}, {a=10}) catch(e:DivisionByZero) "OK") == "OK" and a == 10
TEST F f() block b { finally({ b.return(7) }, {8}) }; f() == 7

# --- Hash ---

doc Get hash key.
doc %EX - h = {"a": 1}
doc %EX - h.a  # 1, Same as h["a"]
F .(h:Hash, field:Str) h[field]

doc Set hash key.
doc %EX - h = {"a": 1}
doc %EX - h.a = 2  # 2, Same as h["a"] = 2
doc %RET - v
F .=(h:Hash, field:Str, v) h[field] = v

doc Get hash value by key or null if it does not exist
doc %EX - h = {"a": 1}
doc %EX - h.get("a")  # 1
doc %EX - h.get("b")  # null
F get(h:Hash, k) get(h, k, null)

# --- Arr ---

# TODO: generalize to Eachable1 ?
doc Return array made of given field of each element of given array.
doc Will throw KeyNotFound if any of the elements does not have the desired field.
doc Use get() to handle missing field differently.
doc %EX - [{"x": 1}, {"x": 2}].x               # [1, 2]
doc %EX - [{"x": 1}, {"y": 2}].x               # KeyNotFound exception
doc %EX - [{"x": 1}, {"y": 2}].get("x")        # [1] - skip
doc %EX - [{"x": 1}, {"y": 2}].get("x", null)  # [1, null] - use default value
doc %RET - Arr
F .(a:Arr, field:Str) a.map(X.(field))

TEST [{"x": 1}, {"x": 2}].x == [1, 2]

doc Set field of every element in array to corresponding item in e. Uses Iter(e) internally.
doc %EX - a=[{"x": 1}, {"x": 2}]
doc %EX - a.y = [10, 20]
doc %EX - # a == [{"x": 1, "y": 10}, {"x": 2, "y": 20}]
doc %RET - a
F .=(a:Arr, field:Str, e:Eachable1) {
	i = Iter(e)
	a.each(F(elt) elt.(field) = i.next())
	a
}

TEST a=[{"x": 1}, {"x": 2}]; a.y = [10, 20]; a == [{"x": 1, "y": 10}, {"x": 2, "y": 20}]

doc Return array made of given field of each element of given Eachable1 where present
doc %EX - [{"x": 1}, {"y": 2}].get("x")  # [1]
doc %EX - ``aws ec2 describe-instances``.Tags.get("role").uniq()
doc %EX - # Returns Arr of Str with roles. Does not crash if some machines do not have "role" tag.
doc %RET - Arr
F get(e:Eachable1, field:Str)
	collector
		e.each(F(item) {
			try collect(item.(field))
		})

doc Return array made of given field of each element of given Eachable1 where present or default value where the field is not present.
doc %EX - [{"x": 1}, {"y": 2}].get("x", null)  # [1, null]
doc %RET - Arr
F get(e:Eachable1, field:Str, dflt) e.map(X.get(field, dflt))

doc Concatenate strings
doc %EX - "ab" + "cd"  # "abcd"
doc %RET - New Str
F +(s1:Str, s2:Str) "${s1}${s2}"

TEST "ab" + "cd" == "abcd"

# === Arr ========================================

doc Get element at the given index or return dflt if the index is out of range (element at the given index does not exist)
doc %EX - [1,2,3].get(0, 10)    # 1
doc %EX - [1,2,3].get(5, 10)    # 10
doc %EX - [11].get(-1)          # 11
doc %EX - [10,20].get(-5, "X")  # "X"
doc %RET - Any
F get(a:Arr, idx:Int, dflt=null) if a.has_index(idx) then a[idx] else dflt

TEST [1].get(0) == 1
TEST [1].get(5) == null
TEST [1].get(0, 10) == 1
TEST [1].get(5, 10) == 10
TEST [10].get(-1) == 10
TEST [10].get(-1, "X") == 10
TEST [10,20].get(-5) == null
TEST [10,20].get(-5, "X") == "X"


doc Checks whether element x is in array arr
doc x - Needle
doc arr - Haystack
doc %EX -  1 in [1,2,3]  # true
doc %EX - 10 in [1,2,3]  # false
doc %RET - Bool
F in(x, arr:Arr) {
	l = arr.len()
	for(i;l) arr[i] == x returns true
	false
}

TEST 1 in [1,2]
TEST not(10 in [1,2])

doc Arrays equality test.
doc True if arrays are of the same length and all elements are equal (==)
doc %RET - Bool
F ==(a:Arr, b:Arr) {
	l = a.len()
	l != b.len() returns false
	for(i;l) a[i] != b[i] returns false
	true
}

TEST [1, 2] == [1, 2]
TEST [1, 3] != [1, 2]
TEST [1] != [1, 2]

doc Compare arrays, element-wise. If all elements are equal, the longest array considered to be the "big" one.
doc %RET - Bool
doc %EX -  [1, 2] <= [1, 3]  # true
doc %EX -  [1] <= [1, 2]     # true
F '<='(a:Arr, b:Arr) {
	l = min([a.len(), b.len()])
	for(i;l) {
		a[i] < b[i] returns true
		a[i] > b[i] returns false
	}
	a.len() <= b.len() returns true
	false
}

TEST [1, 2] <= [1, 3]
TEST not([1, 3] <= [1, 2])
TEST [1] <= [1, 2]
TEST not([1,2] <= [1])

doc Compare arrays, element-wise. If all elements are equal, the longest array considered to be the "big" one.
doc Exactly the same as b <= a.
doc %RET - Bool
F '>='(a:Arr, b:Arr) b <= a


# TODO: Make it work on anything with Eachable2 too.
doc Check whether there is any element in e that satisfies the given pattern.
doc e - The items to check
doc pattern - Test function or anything else acceptable by (=~), defaults to Bool.constructors
doc args - Additional arguments for calling the pattern.
doc %EX - [1,2,10].any(F(elt) elt > 5)   # true
doc %EX - [1,2,10].any(F(elt) elt > 15)  # false
doc %RET - Bool
F any(e:Eachable1, pattern=Bool.constructors) block b {
	e.each(F(x) {
		if x =~ pattern b.return(true)
	})
	false
}

TEST [1,2,10].any(F(elt) elt > 5)
TEST [1,2,3].any(F(elt) elt > 5).not()
TEST [0, 1, null].any()
TEST [0, null].any().not()

doc Check whether all elements in arr satisfy the given pattern.
doc e - The items to check
doc pattern - Test function or anything else acceptable by (=~), defaults to Bool.constructors
doc %RET - Bool
doc %EX - [1,2,3].all(X<10)   # true
doc %EX - [1,2,10].all(X>5)   # false
F all(e:Eachable1, pattern=Bool.constructors) block b {
	e.each(F(x) {
		if x !~ pattern b.return(false)
	})
	true
}

TEST [1,2,3].all(X<10)
TEST [1,2,10].all(X>5).not()
TEST [1, 1].all()
TEST [1, 1, false].all().not()


doc Check whether there is no element in e that satisfies the given pattern. Exactly same as not(any(e, pattern)) .
doc e - The items to check
doc pattern - Test function or anything else acceptable by (=~), defaults to Bool.constructors
doc %RET - Bool
doc %EX - [0,1,2].none(X>2)  # true
doc %EX - [0,1,2].none(X<2)  # false
F none(e:Eachable1, pattern=Bool.constructors) not(any(e, pattern))

TEST [0,1,2].none(X>2)
TEST [0,1,2].none(X<2).not()
TEST [0, 0, false].none()
TEST [0, 0, true].none().not()

TEST [1,2,3].map(X*4) == [4,8,12]

F subset(smaller:Arr, larger:Arr) {
	len(smaller) > len(larger) returns false
	h = larger.only({A.len() > 10}, Set)
	smaller.all(X in h)
}

TEST [1,2,3].subset([1,2,3,4])
TEST [1].subset([2]) == false

doc Iterates over the elements of arr, passing each in turn to cb along with args: cb(ITEM)
doc cb - Function to be called with values from arr
doc args - Additional arguments for calling cb
doc %RET - arr
doc %EX - s=0
doc %EX - [1,2,3].each(F(i) { global s; s+=i })
doc %EX - echo(s)  # Outputs: 6
F each(arr:Arr, cb:Fun) {
	l = arr.len()
	for(i;l) cb(arr[i])
	arr
}

# Tested by flatten() tests

doc Iterates over elements of e, passing each in turn to cb along with index and args: cb(INDEX, ITEM)
doc %RET - e
doc %EX - "abc".each_idx_val(F(idx, val) echo("Element #$idx equals to $val"))
F each_idx_val(e:Eachable1, cb:Fun) {
	idx = 0
	e.each(F(elt) {
		cb(idx, elt)
		idx += 1
	})
}

doc Iterates over the elements of arr, passing each in turn to cb along with index and args: cb(INDEX, ITEM)
doc %RET - arr
doc %EX - [10,20,30].each_idx_val(F(idx, val) echo("Element #$idx equals to $val"))
F each_idx_val(arr:Arr, cb:Fun) {
	l = arr.len()
	for(i;l) cb(i, arr[i])
	arr
}

doc Map an Eachable1 to an Arr (array) of values using mapper
doc mapper is called as mapper(INDEX, ITEM)
doc %RET - New Arr
doc %EX - echo("Array items: " + ArrLike().push(10).push(20).push(30).map_idx_val(F(idx, val) "[$idx]=$val").join(", "))
doc %EX - # Outputs: Array items: [0]=10, [1]=20, [2]=30
F map_idx_val(e:Eachable1, mapper:Fun) collector each_idx_val(e, collect + mapper)

TEST r=[]; ["a", "b"].each_idx_val(F(idx, val) r.push([idx, val])); r == [[0, "a"], [1, "b"]]


# TODO: make it work with anything that has each() method
# TODO: check if used anywhere
doc Process each N elements of an Array at a time.
doc Throws InvalidArgument if number of items in arr is not divisible by n.
doc cb is called as cb(eltI, ..., eltJ) where I is multiple of n and J is I+n-1
doc arr - Items to iterate in chunks of n
doc n - Number of items in chunk
doc cb - Function to be called with values from arr
doc args - Additional arguments for calling cb
doc %RET - arr
doc %EX - [1,2,3,4].each(2, F(a, b) echo("$a - $b"))  # Outputs: "1 - 2" and on the next line "3 - 4"
F each(arr:Arr, n:Int, cb:Fun) {
	arr.len() % n != 0 throws InvalidArgument("Can not iterate elements in groups of $n of array of size ${arr.len()}")
	chunks = arr.len() / n
	for(chunk_number; chunks) {
		cb(*arr[chunk_number*n..chunk_number*n+n])
	}
	arr
}

# Tested by map(arr:Arr, n:Int, cb:Fun)


doc Map each N elements of an Array at a time.
doc mapper is called as cb(eltI, ..., eltJ) where I is multiple of n and J is I+n-1
doc Throws InvalidArgument if number of items in arr is not divisible by n.
doc mapper is called as mapper(eltI, ..., eltJ) where I is multiple of n and J is I+n-1
doc arr - Items to iterate in chunks of n
doc n - Number of items in chunk
doc mapper - Function to be called with values from arr
doc args - Additional arguments for calling mapper
doc %RET - Arr
doc %EX - [1,2,3,4].map(2, F(a,b) "$a=$b").join("&")  # Outputs: 1=2&3=4
F map(arr:Arr, n:Int, mapper:Fun) collector arr.each(n, collect + mapper)

# Tested by ~(s:Str, r:RegExp)

doc Filter out all occurrences of specific value
doc Deprecated. Use reject().
doc e - items to filter
doc without_elt - The value to filter out
doc %RET - Arr
doc %EX - [1,2,3,2].without(2)  # [1,3]
doc %STATUS - deprecated
F without(e:Eachable1, without_elt) e.filter(X != without_elt)

TEST [1,2,3,2].without(2) == [1,3]

doc Filter out all values in a that are also in b
doc %RET - Arr
doc %EX - [1,2,3] - [5,6,1]  # [2,3]
F -(a:Arr, b:Arr) {
	h = b.only({A.len() > 10}, Set)
	a.filter(X not in h)
}

TEST [1,2,3] - [5,6,1] == [2,3]
TEST [1,2,3] - [5,6,1,1,1,1,1,1,1,1,1,1,1,2] == [3]

doc Count number of items that match the pattern.
doc e - Items to look at
doc pattern - Test function or anything else acceptable by (=~), defaults to Bool.constructors
doc args - Additional arguments for the pattern
doc %RET - Int
doc %EX - [1,2,3,11,12].count(X>10)  # 2
F count(e:Eachable1, pattern=Bool.constructors) {
	collector/0
		e.each(F(elt) {
			if elt =~ pattern
				collect(1)
		})
}

TEST [1,2,3,11,12].count(X>10) == 2
TEST [0,1,2,null,false].count() == 2

doc Flatten one level.
doc e - Eachable with each element also Eachable
doc %RET - Arr
doc %EX - [[1], [2,3]].flatten()  # [1,2,3]
F flatten(e:Eachable1) {
	guard not(e is Int)
	collector
		e.each(F(x) {
			assert(x is Eachable1 and x is not Int, 'flatten() elements must be Eachable1, excluding Int')
			x.each(collect)
		})
}

TEST [[1], [2,3]].flatten() == [1,2,3]

doc Return unique values.
doc Warning: uses Hash so comparison is not using == but a built-in hash keys comparison.
doc %RET - Of same type as e
doc %EX - [1,2,2,3,4,4].uniq()  # [1,2,3,4]
doc %EX - [{"a": 1, "z": 10}, {"a": 1, "z": 20}, {"a": 2, "z": 30}].uniq(X.a)  # [{"a": 1, "z": 10}, {"a": 2, "z": 30}]
F uniq(e:Eachable1, cb:Fun=identity) {
	unique_values = Set()
	t = Type(e)
	ret = t()
	e.each(F(elt) {
		val = cb(elt)
		val in unique_values returns
		ret.push(elt)
		unique_values.push(val)
	})
	ret
}

TEST [1,2,2,3,4,4].uniq() == [1,2,3,4]
TEST [{"a": 1, "z": 10}, {"a": 1, "z": 20}, {"a": 2, "z": 30}].uniq(X.a) == [{"a": 1, "z": 10}, {"a": 2, "z": 30}]

TEST [null, false, 10, 20].first() == 10

doc Return unique values.
doc Warning: uses Hash so comparison is not using == but a built-in hash keys comparison.
doc %RET - Of same type as e
doc %EX - [{"id": 100, "a": 1}, {"id": 200, "a": 2}, {"id": 300, "a": 2}].uniq("a")  # [{"id": 100, "a": 1}, {"id": 200, "a": 2}]
F uniq(e:Eachable1, field:Str) e.uniq(X.(field))
TEST [{"id": 100, "a": 1}, {"id": 200, "a": 2}, {"id": 300, "a": 2}].uniq("a") == [{"id": 100, "a": 1}, {"id": 200, "a": 2}]

block u {
	global index
	doc Find index of the first value that matches the pattern.
	doc TODO: Make it work on anything with each() method.
	doc In future, will throw exception if element is not found and default is not provided. Now returns null for backwards compatibility in this case.
	doc arr - Items to look at
	doc pattern - Test function or anything else acceptable by (=~), defaults to Bool.constructors
	doc start - Index to start search at
	doc dflt - default value to return when element is not found
	doc %RET - Int or dflt. Temporary also null, for backwards compatibility.
	doc %EX - [1,2,11,3,4].index(X>10)  # 2
	F index(arr:Arr, pattern=Bool.constructors, start:Int=0, dflt=u) {
		l = arr.len()
		for(i=start; i<l; i+=1)
			arr[i] =~ pattern returns i
		dflt !== u returns dflt
		warn("index() is returning null. In future, this will be an exception. You can change your call to index(..., dflt=null)")
		null
	}
}

TEST [null, null, 1].index() == 2

doc Find all indexes of values that match the pattern
doc arr - Items to look at
doc pattern - Test function or anything else acceptable by (=~), defaults to Bool.constructors
doc args - Additional arguments for the pattern
doc %RET - Arr of Int
doc %EX - [1,5,1,10].indexes(X>2)  # [1,3]
F indexes(e:Eachable1, pattern=Bool.constructors) {
	collector
		e.each_idx_val(F(idx, elt) {
			if elt =~ pattern {
				collect(idx)
			}
		})
}

TEST [1,5,1,10].indexes(X>2) == [1,3]
TEST [1,5,null,10].indexes() == [0,1,3]


TEST [5,10,15].first(X>7) == 10
TEST { [5,10,15].first(X>20) }.assert(ElementNotFound)
TEST { [0, false, null].first() }.assert(ElementNotFound)

doc Make new array which is a reversed given array
doc %RET - Arr
doc %EX - [1,2,3].reverse()  # [3,2,1]
F reverse(arr:Arr) {
	l = arr.len()
	l.map({ arr[l-A-1] })
	# TODO: maybe make this work: arr[NumRange(arr.len() - 1, 0, -1)]
}

TEST [1,2,3].reverse() == [3,2,1]

# Uses reduce method with start value as it is probably faster
doc Calculate sum of the elements
doc %EX - [1,2,3].sum()  # 6
F sum(something:Eachable1) something.reduce(0, (+))

doc Prepend one element to the given array
doc %RET - Modified arr
doc %EX - x=[1,2]
doc %EX - x.unshift(3)
doc %EX - echo(x)  # Outputs: [3,1,2]
F unshift(arr:Arr, elt) {
	arr[0..0] = [elt]
	arr
}

TEST x=[1,2]; x.unshift(3); x == [3, 1, 2]

doc EXPERIMENTAL! Do not use!
doc a - Array of arrays to join
doc sep - Separator elements
doc %EX - [[1,2], [3,4]].join([10,20])  # [1,2,10,20,3,4]
F join(a:Arr, sep:Arr) {
	warn("Using experimental join(Arr,Arr)")
	guard a.all(Arr)
	collector
		a.each_idx_val(F(idx, subarr) {
			subarr.each(collect)
			if idx < a.len() - 1 {
				sep.each(collect)
			}
		})
}

# --- Conversions ---

doc Make Arr from Hash. Each key/value pair becomes two-items array.
doc %RET - Arr of form [[k1, v1], [k2, v2], ...]
doc %EX - Arr({'x': 7, 'y': 8})  # [['x', 7], ['y', 8]]
F Arr(h:Hash)
	h.map(F(*pair) pair)

TEST Arr({'x': 7, 'y': 8}) == [['x', 7], ['y', 8]]

doc Make new array which aggregates elements from each of the args arrays
doc n-th element of the new array is an array that contains n-th element of each of the given arrays
doc If some of the arrays in args are shorter than others, they will be logically padded with null
doc %EX - zip([1,2,3], [4,5,6])  # [[1,4], [2,5], [3,6]]
doc %EX - zip([1,2,3], [4,5])    # [[1,4], [2,5], [3,null]]
doc %RET - Arr of form [[arg[0][0], arg[1][0], ... arg[i][0]], [arg[0][1], arg[1][1], ... arg[i][1]], ...]
F zip(*args) {
	arrays = args.map(Arr)
	arrays.map(len).max().map({ arrays.map(X.get(A, null)) })
}

TEST zip([1,2,3], [4,5,6]) == [[1,4], [2,5], [3,6]]
TEST zip([1,2,3], [4,5,6], [7,8,9,10]) == [[1,4,7], [2,5,8], [3,6,9], [null, null, 10]]

doc Convert Eachable1 (anything with "each" method that takes callback of one parameter) to an array
doc %EX - Arr(1..3)   # [1,2]
doc %EX - Arr(1...3)  # [1,2,3]
F Arr(something:Eachable1)
	collector
		something.each(collect)

TEST Arr(1..3) == [1,2]
TEST Arr(1...3) == [1,2,3]

doc Make Arr from Arr. A no-op.
doc %RET - arr
F Arr(arr:Arr) arr

doc Convert Arr into JSON compatible data structure - array
F JsonData(arr:Arr) arr.map(JsonData)

# --- Access elements ---

doc Get array element by index from the end (negative indexes handler). Throws IndexNotFound if abs(idx) > len(arr).
doc idx - Negative index
doc %EX - [10,20,30][-1]  # 30
F '[]'(arr:Arr, idx:Int) {
	guard idx < 0
	i = arr.len() + idx
	i < 0 throws IndexNotFound("[](Arr, Int): Index $idx is illegal for array of size ${arr.len()}", arr, idx)
	arr[i]
}

doc Set array element by index from the end (negative indexes handler). Throws IndexNotFound if abs(idx) > len(arr).
doc idx - Negative index
doc %EX - a = [1, 2, 3]; a[-1] = 99  # [1, 2, 99]
F '[]='(arr:Arr, idx:Int, val) {
	guard idx < 0
	i = arr.len() + idx
	i < 0 throws IndexNotFound("[]=(Arr, Int, Any): Index $idx is illegal for array of size ${arr.len()}", arr, idx)
	arr[i] = val
}

TEST a = [1, 2, 3]; a[-1] = 99; a == [1, 2, 99]

# TODO: Make "Indexable" and make this method work with Indexable
doc Get array elements at specified indexes. Indexes specified by NumRange.
doc r - NumRange with negative .end
doc %EX - [10,20,30,40][1..-1]  # [20,30]
doc %RET - Arr
F '[]'(arr:Arr, r:NumRange) {
	guard r.end is Int and r.end < 0
	r.step != 1 throws NotImplemented("r.step must be 1")
	r.end < 0 - arr.len() throws IndexNotFound("[](Arr, NumRange): Index ${r.end} (range end) is illegal for array of size ${arr.len()}", arr, r.end)
	arr[r.start..arr.len() + r.end]
}

TEST [10,20,30,40][1..-1] == [20,30]

block u {
	global indexes
	# TODO: something more effective
	doc Find the indexes of elements of the given PredRange.
	doc Throws IndexNotFound if there is no match between the elements of arr and r.
	doc %RET - NumRange with .include_start=true and .include_end=false
	doc %EX - %[a1 a2 b1 b2 c1].indexes(/^a/../^b/)   # <NumRange 1..2 include_start=true include_end=false step=1>
	doc %EX - %[a1 a2 b1 b2 c1].indexes(/^a/.../^b/)  # <NumRange 0..3 include_start=true include_end=false step=1>
	F indexes(arr:Arr, r:PredRange, dflt=u) {
		r.step != 1 throws NotImplemented("r.step must be 1")
		start = if r.start is Null {
			0
		} else {
			index(arr, r.start, dflt=null)
		}
		if start is Null {
			dflt !== u returns dflt
			throw IndexNotFound("Array did not match PredRange (start)", arr, r)
		}
		end = if r.end is Null {
			len(arr)
		} else {
			index(arr, r.end, start=start + Int(r.start is not Null and r.include_start.not()), dflt=null)
		}
		if end is Null {
			dflt !== u returns dflt
			throw IndexNotFound("Array did not match PredRange (end)", arr, r)
		}
		NumRange(start + Int(r.start is not Null and r.include_start.not()), end + Int(r.include_end))
	}
}

TEST { indexes([1,2,3,4], ((X==1)..(X==14))) }.assert(IndexNotFound)
TEST indexes([1,2,3,4], ((X==1)..(X==14)), []) == []

doc Extract array elements between the element that matches r.start and the element that matches r.end .
doc Starting and ending elements are optionally included, depending on r.include_start and r.include_end .
doc %EX - %[a1 a2 b1 b2][/^a/../^b/]   # ['a2']
doc %EX - %[a1 a2 b1 b2][/^a/.../^b/]  # ['a1', 'a2', 'b1']
doc %EX - %[a1 a2 b1 b2][/^a/.../^x/]  # IndexNotFound exception
F '[]'(arr:Arr, r:PredRange) arr[indexes(arr, r)]

TEST %[a1 a2 b1 b2][/^a/../^b/] == %[a2]
TEST %[a1 a2 b1 b2][null../^b/] == %[a1 a2]
TEST %[a1 a2 b1 b2][/^b/..null] == %[b2]
TEST %[a1 a2 b1 b2][/^a/.../^b/] == %[a1 a2 b1]
TEST { %[a1 a2 b1 b2][/^a/.../^x/] }.assert(IndexNotFound)
TEST { %[a1 a2 b1 b2][/^x/.../^b/] }.assert(IndexNotFound)

doc Replace array elements.
doc arr - Array to operate on.
doc r - Range of elements to replace.
doc replacement - New elements.
doc %EX - a = %[a1 a2 b1 b2]
doc %EX - a[/^a/.../^b/] = [7]  # a == [7, 'b2']
doc %EX - MARKERS = '# generated - start'..'# generated - end'
doc %EX - text[MARKERS] = newly_generated_content_lines
F '[]='(arr:Arr, r:PredRange, replacement:Arr) arr[indexes(arr, r)] = replacement
TEST a = %[a1 a2 b1 b2]; a[/^a/.../^b/] = [7]; a == [7, 'b2']

doc Check whether the array contains the given range. Finds first match.
doc %EX - a = %[a1 a2 b1 b2]
doc %EX - m = a ~ /^a/../^b/ # Exclusive range
doc %EX - # m.matches == [['a2']]
doc %EX - # m.before == ['a1']
doc %EX - # m.after == ['b1', 'b2']
doc %RET - MatchResult
F ~(arr:Arr, r:PredRange) {
	i = indexes(arr, r, dflt=null)
	i is Null returns MatchFailure(arr, r)
	ret = MatchSuccess([arr[i]], r)
	ret.named = {}
	ret.positions = [i]
	ret.whole = ret.matches[0]
	ret.before = arr[0..i.start]
	ret.after = arr[i.end..null]
	ret
}

TEST a = %[a1 a2 b1 b2]; m = a ~ /^a/../^b/; m.matches == [['a2']] and m.before == ['a1'] and m.after == ['b1', 'b2']
TEST a = %[a1 a2 b1 b2]; m = a ~ /^a/.../^b/; m.matches == [['a1','a2','b1']] and m.before == [] and m.after == ['b2']

doc Get array elements at specified indexes.
doc arr - Array to pick items from
doc indexes - Indexes of items to pick
doc %EX - [10,20,30,40][[0,3]]  # [10, 40]
doc %RET - Arr
F '[]'(arr:Arr, indexes:Arr) indexes.map(arr[X])

TEST [10,20,30,40][[0,3]] == [10, 40]

doc Truncate an array if necessary so it would have maximum l elements.
doc a - Array to (possibly) truncate.
doc l - Maximum elements
doc %RET - Either a or new Arr of length l
doc %EX - [10,11,12].limit(2)   # [10,11]
doc %EX - [10,11,12].limit(10)  # [10,11,12]
F limit(a:Arr, l:Int) {
	a.len() <= l returns a
	a[0..l]
}

TEST [10,11,12].limit(10) == [10,11,12]
TEST [10,11,12].limit(2) == [10,11]

# --- Misc ---

block _ {
	global min, max
	F most(e:Eachable1, f:Fun) {
		guard e
		ret = e[0]
		e.each(F(elt) if f(elt, ret) { ret = elt })
		ret
	}

	doc Find minimal element under (<)
	F min(e:Eachable1) most(e, (<))
	doc Find maximal element under (>)
	F max(e:Eachable1) most(e, (>))

	doc Find minimal element under (<)
	F min(a, b, *rest) [a, b, *rest].min()

	doc Find maximal element under (>)
	F max(a, b, *rest) [a, b, *rest].max()

}

doc Repeat all elements in arr n times
doc arr - Elements to repeat
doc n - Number of times to repeat the elements
doc %RET - Arr
doc %EX - [10,20] * 2  # [10,20,10,20]
F *(arr:Arr, n:Int)
	collector
		for(i;n)
			arr.each(collect)

TEST [10,20] * 2 == [10,20,10,20]

doc Cartesian product
doc %RET - Arr of Arr[2]
doc %EX - [10,20] * [30,40]  # [[10, 30], [10, 40], [20, 30], [20, 40]]
F *(a:Arr, b:Arr)
	collector
		a.each(F(elt_a) {
			b.each(F(elt_b) {
				collect([elt_a, elt_b])
			})
		})

TEST [10,20] * [30,40] == [[10, 30], [10, 40], [20, 30], [20, 40]]

doc Echo non-string. Converts x to string first, using Str()
doc x - Anything but Str
doc %RET - null
doc %EX - echo(1)
F echo(x) {
	guard x is not Str
	echo(Str(x))
}

# Built-in join() can only handle Str elements
doc Join non-strings. Converts a elements to string first, then uses built-in join().
doc Warning - behaviour subject to change!
doc a - Array to join
doc s - Delimiter
doc %RET - Str
doc %EX - [1,2,3].join("::")  # The string 1::2::3
F join(a:Arr, s:Str) {
	guard a.any(X is not Str)
	a.map(Str).join(s)
}

# Can be more efficient I guess
doc Merge sorted arrays.
doc lte - Less-then-or-equal function to use for comparison of items in a and b
doc %RET - Arr
doc %EX - merge_sorted([1,3,10], [0, 7], (<=))  # [0, 1, 3, 7, 10]
F merge_sorted(a:Arr, b:Arr, lte:Fun) {
	ai = Iter(a)
	bi = Iter(b)
	collector
		while ai or bi {
			if not(ai) {
				bi.each(collect)
				break
			}
			if not(bi) {
				ai.each(collect)
				break
			}
			(if lte(ai.peek(), bi.peek()) then ai else bi).next().collect()
		}
}

TEST merge_sorted([1,3,10], [0, 7], (<=)) == [0, 1, 3, 7, 10]
TEST merge_sorted([1,3,10], [0, 7, 12, 13, 14], (<=)) == [0, 1, 3, 7, 10, 12, 13, 14]
TEST merge_sorted([0, 1], [2, 3], (<=)) == [0, 1, 2, 3]
TEST merge_sorted([2, 3], [0, 1], (<=)) == [0, 1, 2, 3]

# Current implementation: https://en.wikipedia.org/wiki/Merge_sort
# TODO: replace with Timsort https://en.wikipedia.org/wiki/Timsort
doc Sort an array.
doc lte - Less-then-or-equal function to use for comparison of the items in a
doc %RET - Arr
doc %EX - sort([0,5,3,-1], (<=))  # [-1, 0, 3, 5]
F sort(a:Arr, lte:Fun=(<=)) {
	# XXX: Not copied!
	a.len() <= 1 returns a
	mid = a.len() / 2
	l = a[0..mid]
	r = a[mid..null]
	merge_sorted(sort(l, lte), sort(r, lte), lte)
}

TEST sort([0,5,3,-1], (<=)) == [-1, 0, 3, 5]

doc Sort an array based on field value
doc lte - Less-then-or-equal function to use for comparison of the items' fields
doc %RET - Arr
doc %EX - [{'x': 1}, {'x': 5}, {'x': 3}].sort('x')  # [{'x': 1}, {'x': 3}, {'x': 5}]
F sort(a:Arr, field:Str, lte:Fun=(<=)) a.sort(F(a, b) lte(a.(field), b.(field)))

TEST [{'x': 1}, {'x': 5}, {'x': 3}].sort('x') == [{'x': 1}, {'x': 3}, {'x': 5}]

# TODO: better documentation
doc Split e into arrays
doc %RET - Arr of Arr
doc %EX - [1, "a", 2, 3, "a", 4].split("a")  # [[1], [2, 3], [4]]
F split(e:Eachable1, delim) {
	collector {
		cur = []
		e.each(F(elt) {
			if elt == delim {
				collect(cur)
				cur = []
			} else {
				cur.push(elt)
			}
		})
		collect(cur)
	}
}

TEST [1, "a", 2, 3, "a", 4].split("a") == [[1], [2, 3], [4]]

doc Call cb with array of maximum length of n, repeatedly for all items of e.
doc TODO: better doc, rename to each() to be consistent with each(Arr, Int, Fun)?
doc %STATUS - experimental
F each_chunk(e:Eachable1, n:Int, cb:Fun) {
	cur = []
	e.each(F(x) {
		cur.push(x)
		if len(cur) == n {
			cb(cur)
			cur = []
		}
	})
	if cur {
		cb(cur)
	}
}

doc Insert delimiter element between each two elements in an array
doc %RET - Arr
doc %EX - [1,2,3].intersperse(0)  # [1,0,2,0,3]
F intersperse(a:Arr, delim) {
	not(a) returns []
	collector {
		a.each(F(elt) {
			collect(elt)
			collect(delim)
		})
	}[0..-1]
}

TEST [1,2,3].intersperse(0) == [1,0,2,0,3]

doc Optionally, wrap x in an array. Return x if it's already Arr.
doc Deprecated. Use ensure(x, Arr) instead.
doc %RET - Arr
doc %EX - ensure_array([1,2])  # [1,2]
doc %EX - ensure_array("aa")   # ["aa"]
doc %STATUS - deprecated
F ensure_array(x) x.ensure(Arr)

TEST ensure_array([1,2]) == [1,2]
TEST ensure_array("aa") == ["aa"]


doc Convert an array to NGS code that would produce the array when executed. Not fully functional yet.
doc %RET - Str
F code(a:Arr) "[" + a.map(code).join(', ') + "]"

# === Hash =======================================


# --- Comparisons ---

doc Compare two Hashes. Hashes must have same keys with same values in same order to return true.
doc Both hashes must not be modified during comparison. This was not tested.
doc %RET - Bool
F ==(a:Hash, b:Hash) {
	len(a) != len(b) returns false
	a === b returns true

	e1 = ll_hash_head(a)
	e2 = ll_hash_head(b)
	while e1 != null {
		e1.ll_hash_entry_key() != e2.ll_hash_entry_key() returns false
		e1.ll_hash_entry_val() != e2.ll_hash_entry_val() returns false
		e1 .= ll_hash_entry_next()
		e2 .= ll_hash_entry_next()
	}
	true
}

F subset(smaller:Hash, larger:Hash) {
	not(len(smaller) <= len(larger)) returns false
	smaller.all(F(k, v) k in larger and larger[k] == v)
}

TEST subset({}, {"a": 1})
TEST subset({"a": 1}, {"a": 1})
TEST subset({"a": 1, "b":2}, {"b": 3, "d": 4}) == false
TEST subset({"a": 1}, {"a": 10}) == false

# --- Functional ---

doc Compose functions
doc %RET - Fun f(g(...))
doc %EX - F reject(h:Hash, predicate:Fun) h.filter(not + predicate)
F +(f:Fun, g:Fun) {
	F composed_function(*args) {
		f(g(*args))
	}
}

# Make it built in for speed?
doc Iterate a Hash.
doc h - Hash to iterate
doc cb - Function to call with successive keys and values
doc %RET - h
doc %EX - {"a": 1, "b": 2}.each(F(k, v) echo("$k=$v"))  # Outputs: "a=1" and on the next line "b=2"
F each(h:Hash, cb:Fun) {
	for(entry = ll_hash_head(h); entry != null; entry = entry.ll_hash_entry_next()) {
		cb(entry.ll_hash_entry_key(), entry.ll_hash_entry_val())
	}
	h
}

doc Checks whether any of the key-value pairs satisfies the predicate: predicate(k, v)
doc %RET - Bool
F any(e:Eachable2, predicate:Fun) block b {
	e.each(F(k, v) {
		if predicate(k, v) {
			b.return(true)
		}
	})
	false
}

TEST {"x": 1, "y": 2}.any(F(k, v) v is Int)
TEST {"x": 1, "y": 2}.any(F(k, v) v is Str).not()


doc Checks whether all of the key-value pairs satisfies the predicate: predicate(k, v)
doc %RET - Bool
F all(e:Eachable2, predicate:Fun) block b {
	e.each(F(k, v) {
		if not(predicate(k, v)) b.return(false)
	})
	true
}

TEST {"x": 1, "y": 2}.all(F(k, v) v is Int)
TEST {"x": 1, "y": "zz"}.all(F(k, v) v is Int).not()

doc Iterate a Hash.
doc h - Hash to iterate
doc cb - Function to call with successive keys
doc %RET - h
F eachk(h:Hash, cb:Fun) h.each({cb(A)})

TEST ret = []; {"a": 1, "b": 2}.eachk(ret.push(X)); ret == %[a b]

doc Iterate a Hash.
doc h - Hash to iterate
doc cb - Function to call with successive values
doc %RET - h
F eachv(h:Hash, cb:Fun) h.each({cb(B)})

TEST ret = []; {"a": 1, "b": 2}.eachv(ret.push(X)); ret == %[1 2]


doc Iterate a Hash.
doc h - Hash to iterate
doc cb - Function to call with successive indexes, keys and values
doc args - Additional arguments for calling cb
doc %RET - h
doc %EX - {"a": 1, "b": 2}.each_idx_key_val(F(idx, k, v) echo("[$idx] $k=$v"))
doc %EX - # Outputs: "[0] a=1" and on the next line "[1] b=2"
F each_idx_key_val(h:Hash, cb:Fun) {
	for({idx=0; entry=ll_hash_head(h)}; entry != null; {idx+=1; entry = entry.ll_hash_entry_next()}) {
		cb(idx, entry.ll_hash_entry_key(), entry.ll_hash_entry_val())
	}
	h
}

doc Map a Hash
doc h - Hash with source keys and values
doc mapper - Function to be called with keys and values from h
doc %RET - Arr
doc %EX - {'a': 1, 'b': 2}.map(F(k, v) "${k}-$v")  # ['a-1', 'b-2']
F map(h:Hash, mapper:Fun)
	collector
		h.each(collect + mapper)

TEST {'a': 1, 'b': 2}.map(F(k, v) "${k}-$v") == ['a-1', 'b-2']

doc Map a Hash
doc h - Hash with source keys and values
doc mapper - Function to be called with sequential zero-based index, keys and values from h
doc %RET - Arr
doc %EX - {'a': 1, 'b': 2}.map_idx_key_val(F(i, k, v) "${i}-${k}-$v")  # ['0-a-1', '1-b-2']
F map_idx_key_val(h:Hash, mapper:Fun) collector h.each_idx_key_val(collect + mapper)

doc Map Hash keys. Build new Hash with same values as in h but keys mapped by mapper.
doc h - Source hash
doc mapper - Function to be called with keys
doc args - Additional arguments for calling mapper
doc %RET - Hash
doc %EX - mapk({"a": 1}, F(k) k+"z")  # {"az": 1}
F mapk(h:Hash, mapper:Fun)
	collector/{}
		h.each(F(k, v) collect(mapper(k), v))

TEST mapk({"a": 1}, X+"z") == {"az": 1}

doc Map Hash values. Build new Hash with same keys as in h but values mapped by mapper.
doc h - Source hash
doc mapper - Function to be called with values
doc args - Additional arguments for calling mapper
doc %RET - Hash
doc %EX - LEN = 3
doc %EX - lines_ = read("/usr/share/dict/words").lines()
doc %EX - long_lines = lines_.filter({A.len()>LEN})
doc %EX - prefix_to_lines = long_lines.group(F(line) line[0..LEN])  # {"pfx1": ["pfx1a", "pfx1b", ...], "pfx2": ["pfx2a", "pfx2b", ...], ...}
doc %EX - prefix_to_count = prefix_to_lines.mapv(len)  # {"pfx1": 30, "pfx2": 35, ...}
doc %EX - top = prefix_to_count.Arr().sort(F(a, b) b[1] <= a[1]).Hash()
doc %EX - top .= limit(10)
doc %EX - echo(top)  # Outputs: {con=1219, dis=1001, pro=808, pre=607, com=600, int=543, tra=498, ove=431, per=422, imp=421}
F mapv(h:Hash, mapper:Fun)
	collector/{}
		h.each(F(k, v) collect(k, mapper(v)))

TEST mapv({"a": 1}, X+1) == {"a": 2}


doc Map Hash keys and values. Build new Hash with keys and values mapped by mapper.
doc h - Source hash
doc mapper - Function to be called with keys and values
doc args - Additional arguments for calling mapper
doc %EX - mapkv({"a": 1}, {[A+"zz", B+10]})  # {"azz": 11}
F mapkv(h:Hash, mapper:Fun)
	collector/{}
		h.each(F(k, v) collect(*mapper(k, v)))

TEST mapkv({"a": 1}, {[A+"zz", B+10]}) == {"azz": 11}

# TODO: Move above HashLike and make it work with Eachable2
doc Filter a hash. Build new hash with kev-value pairs selected by the given predicate.
doc h - Source hash
doc predicate - Test function to be called with one key and one value at a time: predicate(k, v)
doc args - Additional arguments for calling the predicate
doc %EX - {'a': 1, 'b': 2}.filter(F(k, v) k == 'a')  # {'a': 1}
F filter(h:Hash, predicate:Fun) {
	collector/{}
		h.each(F(k, v) {
			if predicate(k, v)
				collect(k, v)
		})
}

TEST {'a': 1, 'b': 2}.filter(F(k, v) k == 'a') == {'a': 1}

doc h.filter(not + predicate)
F reject(h:Hash, predicate:Fun) h.filter(not + predicate)

doc Filter hash by keys, keeping matched
doc %EX - {"a": 1, "b": 2, "ccc": 3}.filterk(/^.$/)    # {a=1, b=2}
doc %EX - {"aa": 1, "ab": 2, "ba": 3}.filterk(/^a/)    # {aa=1, ab=2}
doc %EX - {"aa": 1, "ab": 2, 10: 3}.filterk(Int)       # {10=3}
doc %EX - {10: "a", 20: "b", 30: "c"}.filterk(X > 10)  # {20=b, 30=c}
F filterk(h:Eachable2, pattern=Bool.constructors) filter(h, X =~ pattern)

TEST {"a1": 1, "a2": 2, "b1": 10}.filterk(/^b/) == {"b1": 10}
TEST {0: "zero", 1: "one"}.filterk() == {1: "one"}

doc Filter hash by keys, removing matched. See filterk().
doc %EX - {"a1": 1, "a2": 2, "b1": 10}.rejectk(/^b/)  # {"a1": 1, "a2": 2}
F rejectk(h:Eachable2, pattern=Bool.constructors) h.filterk(Not(pattern))

TEST {"a1": 1, "a2": 2, "b1": 10}.rejectk(/^b/) == {"a1": 1, "a2": 2}
TEST {0: "zero", 1: "one"}.rejectk() == {0: "zero"}


doc Filter hash by values
doc %EX - {"a1": 1, "a2": 2, "b1": 10}.filterv(X>5)  # {"b1": 10}
F filterv(h:Eachable2, pattern=Bool.constructors) filter(h, Y =~ pattern)

TEST {"a1": 1, "a2": 2, "b1": 10}.filterv(X>5) == {"b1": 10}
TEST {"yes": true, "no": false}.filterv() == {"yes": true}

doc Filter hash by values
F rejectv(h:Eachable2, pattern=Bool.constructors) h.filterv(Not(pattern))

TEST {"a1": 1, "a2": 2, "b1": 10}.rejectv(X>5) == {"a1": 1, "a2": 2}
TEST {"yes": true, "no": false}.rejectv() == {"no": false}

doc Count number of key-value pairs in Hash that satisfy the predicate.
doc e - Something to check, typically a Hash
doc predicate - Test function to be called with one key and one value at a time: predicate(k, v)
doc args - Additional arguments for calling the predicate.
doc %RET - Int
doc %EX - {'a': 1, 'b': 2, 'c': 11}.count(F(k, v) v>10)  # 1
F count(e:Eachable2, predicate:Fun) {
	collector/0
		e.each(F(k, v) {
			if predicate(k, v)
				collect(1)
		})
}

TEST {'a': 1, 'b': 2, 'c': 11}.count(F(k, v) v>10) == 1

doc Sort Hash by keys
doc %RET - Hash
doc %EX - {'b': 2, 'c': 11, 'a': 1}.sortk()  # {'a': 1, 'b': 2, 'c': 11}
F sortk(h:Hash, lte:Fun=(<=)) h.keys().sort(lte).Hash(h[X])

TEST {'b': 2, 'c': 11, 'a': 1}.sortk() == {'a': 1, 'b': 2, 'c': 11}
TEST {'a': 1, 'b': 2, 'c': 11}.sortk() == {'a': 1, 'b': 2, 'c': 11}

doc %STATUS - experimental
F sortv(h:Hash, lte:Fun=(<=)) h.Arr().sort({ lte(A[1], B[1]) }).Hash()

TEST {"a": 1, "b": 10, "c": 5}.sortv() == {"a": 1, "c": 5, "b": 10}
TEST {"a": 1, "b": 10, "c": 5}.sortv() != {"a": 1, "b": 10, "c": 5}

# --- Conversions ---

doc Create a Hash from Arr of Arr[2]
doc arr - Array of Arrays. Each one of the sub-arrays must have exactly two elements.
doc %RET - Hash
doc %EX - Hash([['a', 1], ['c', 3]])  # {'a': 1, 'c': 3}
F Hash(arr:Arr) {
	guard arr.all(F(x) x is Arr and len(x) == 2)
	collector/{}
		arr.each(F(pair) {
			collect(*pair)
		})
}

TEST Hash([['a', 1], ['c', 3]]) == {'a': 1, 'c': 3}

doc Create Hash with keys being the given field of elements and the values being corresponding elements.
doc %RET - Hash
doc %EX - Hash([{'x': 1}, {'x': 2}], 'x')  # {1: {'x': 1}, 2: {'x': 2}}
F Hash(e:Eachable1, field:Str)
	collector/{}
		e.each(F(v) collect(v.(field), v))

TEST Hash([{'x': 1}, {'x': 2}], 'x') == {1: {'x': 1}, 2: {'x': 2}}

doc Create a Hash from keys in Eachable1 using cb for values calculation
doc e - Keys of the hash to build
doc cb - Function to be called with one key at a time. Should calculate a value for the given key.
doc %RET - Hash
doc %EX - Hash([1,2], F(x) x*2)  # {1: 2, 2: 4}
F Hash(e:Eachable1, cb:Fun)
	collector/{}
		e.each(F(elt) collect(elt, cb(elt)))

TEST Hash([1,2], F(x) x*2) == {1: 2, 2: 4}


doc Create a Hash from keys in "keys" and corresponding values in "values"
doc keys - Keys for the new Hash
doc values - Values for the new Hash
doc %RET - Hash
doc %EX - Hash(["a", "b", "c"], [1,2,3])  # {"a": 1, "b": 2, "c": 3}
F Hash(keys:Arr, values:Arr)
	collector/{}
		keys.len().each(F(idx) collect(keys[idx], values[idx]))

TEST Hash(["a", "b", "c"], [1,2,3]) == {"a": 1, "b": 2, "c": 3}

doc Create Hash from Arr of something that has key and value fields
doc e - Eachable1 with all the keys and values
doc key_field - Name of the field holding the keys of newly created Hash
doc val_field - Name of the field holding the values of newly created Hash
doc %RET - Hash
doc %EX - Hash([{"Name": "n1", "Value": "v1"},{"Name": "n2", "Value": "v2"}], "Name", "Value")  # {"n1": "v1", "n2": "v2"}
F Hash(e:Eachable1, key_field:Str, val_field:Str)
	collector/{}
		e.each(F(elt) collect(elt.(key_field), elt.(val_field)))

TEST Hash([{"Name": "n1", "Value": "v1"},{"Name": "n2", "Value": "v2"}], "Name", "Value") == {"n1": "v1", "n2": "v2"}

# TODO: Consider storing attributes if key/value keys names
#       for example for converting back to Eachable1:
doc %STATUS - experimental
F Hash(e:Eachable1) {
	not(e) returns {}
	guard e.all(F(x) x is Eachable2 and len(x) == 2)
	k = v = null
	pat = {
		AnyOf(%[Id id K k Key key Name name OutputKey ParameterKey]) -> {k=A}: Any
		AnyOf(%[V v Val val Value value OutputValue ParameterValue ]) -> {v=A}: Any
	}
	if not(e[0] =~ pat) {
		throw InvalidArgument("Hash(Eachable1) did not find key/value keys in first element").set(element=e[0], pattern=pat)
	}
	e.Hash(k, v)
}

TEST Hash([{"Name": "n1", "Value": "v1"},{"Name": "n2", "Value": "v2"}]) == {"n1": "v1", "n2": "v2"}


doc Convert Hash into JSON compatible data structure - object
F JsonData(h:Hash) h.map(F(k, v) [JsonData(k), JsonData(v)]).Hash()

# --- Misc ---

doc Filter out specific key.
doc Deprecated. Use rejectk().
doc e - Source
doc without_k - The key to filter out
doc %EX - {'a': 1, 'b': 2, 'c': 3}.without('a')  # {'b': 2, 'c': 3}
doc %STATUS - deprecated
F without(e:Eachable2, without_k) e.filter(X != without_k)

TEST {'a': 1, 'b': 2, 'c': 3}.without('a') == {'b': 2, 'c': 3}

doc Filter out specific key-value pair.
doc Deprecated. Use reject().
doc e - Source
doc without_k - The key to filter out
doc without_v - The value to filter out
doc %EX - {'a': 1, 'b': 2, 'c': 3}.without('a', 1).without('b', 22)  # {'b': 2, 'c': 3}
doc %STATUS - deprecated
F without(e:Eachable2, without_k, without_v)
	e.reject(F(k, v) (k == without_k) and (v == without_v))

TEST {'a': 1, 'b': 2, 'c': 3}.without('a', 1).without('b', 22) == {'b': 2, 'c': 3}

doc Add Hashes. Builds new hash with key-value pairs from both a and b. If same key is present in both a and b, the value from b is used.
doc %RET - Hash
doc %EX - {'a': 1, 'b': 2, 'c': 3} + {'b': 20, 'd': 40}  # {'a': 1, 'b': 20, 'c': 3, 'd': 40}
F +(a:Hash, b:Hash) {
	t = Type(a)
	t !== Type(b) throws InvalidArgument("+(a:Hash, b:Hash) requires a and b to be of the same type").set(a=a, b=b)
	t().update(a).update(b)
}

TEST {'a': 1, 'b': 2, 'c': 3} + {'b': 20, 'd': 40} == {'a': 1, 'b': 20, 'c': 3, 'd': 40}
TEST section "order matters" { ns { a=1; c=3; } + ns { a=10; b=2; } == ns { a=10; c=3; b=2; } }
TEST { {"a": 1} + ns { b = 2 } }.assert(InvalidArgument)

doc Build array of Str where each resulting string is of the form "KEY=VALUE"
doc h - Source hash
doc %RET - Arr of Str
doc %EX - {'a': 1, 'b': 2}.Strs()  # ['a=1', 'b=2']
F Strs(h:Hash) h / "$X=$Y"

TEST {'a': 1, 'b': 2}.Strs() == ['a=1', 'b=2']

doc Truncate a Hash if necessary so it would have maximum l key-value pairs.
doc h - Source hash
doc l - Maximum elements
doc %RET - Hash
doc %EX - {"a": 1, "b": 2}.limit(1)  # {"a": 1}
F limit(h:Hash, l:Int) h.keys().limit(l).Hash(h[X])

TEST {"a": 1, "b": 2}.limit(3) == {"a": 1, "b": 2}
TEST {"a": 1, "b": 2}.limit(1) == {"a": 1}

doc Group items from e by key returned by k
doc %RET - Hash with Arr values
doc %EX - ["ab", "ac", "ba", "bc", "bd"].group(F(x) x[0])  # {a=[ab,ac], b=[ba,bc,bd]}
doc %EX - [["a", 1], ["b", 2], ["a", 3]].group(X[0], X[1])  # {"a": [1,3], "b": [2]}
F group(e:Eachable1, k:Fun, v:Fun=identity)
	collector/ret={}
		e.each(F(elt) {
			ret.dflt(k(elt), []).push(v(elt))
		})

TEST [["a", 1], ["b", 2], ["a", 3]].group(X[0], X[1]) == {"a": [1,3], "b": [2]}

doc Group items from e by the given field
doc %RET - Hash with Arr values
doc %EX - [{"id": 100, "a": 1}, {"id": 200, "a": 2}, {"id": 300, "a": 2}].group("a")  # {1=[{id=100, a=1}], 2=[{id=200, a=2},{id=300, a=2}]}
F group(e:Eachable1, field:Str) e.group(X.(field))

doc Group the items from e and return groups of more than one element
doc %RET - Arr of Arr
F duplicates(e:Eachable1, field_or_callback) e.group(field_or_callback).values().filter({len(A) > 1})

TEST ["a1", "a2", "b1", "b2", "c1", "d1"].duplicates(F(x) x[0]) == [["a1", "a2"], ["b1", "b2"]]

doc Make shallow copy of a Hash
doc %RET - Hash
F copy(h:Hash) {
	{**h}
}

TEST h={"a": 1}; g=copy(h); h.b = 2; ("b" in h) and ("b" not in g)

doc Convert a Hash to NGS code that would produce the given Hash when executed. Not fully functional yet.
doc %RET - Str
F code(h:Hash) {
	'{' + h.map(F(k, v) "${k.code()}: ${v.code()}").join(', ') + '}'
}

doc Set a key in a Hash if it's not already set
doc %EX - my_hash.dflt(k, []).push(elt)
doc %RET - Hash value, the already-existed or new.
F dflt(h:Hash, k, v) {
	if k not in h {
		h[k] = v
	}
	h[k]
}

doc Sort a Hash.
doc lte - Less-then-or-equal function to use for comparison of the keys in h
doc %RET - Hash
doc %EX - {"b": 2, "c": 3, "a": 1}.sort()  # {"a": 1, "b": 2, "c": 3}
F sort(h:Hash, lte:Fun=(<=)) {
	collector/{}
		h.keys().sort(lte).each(F(k) collect(k, h[k]))
}

TEST {"b": 2, "c": 3, "a": 1}.sort() == {"a": 1, "b": 2, "c": 3}

doc Get the given key from a Hash and remove it from the Hash.
doc Underlying h[k] may throw KeyNotFound.
doc %EX - h = {"a": 1}
doc %EX - s = h.shift("a")  # h == {} and s == 1
F shift(h:Hash, k) h[k]::{ del(h, k) }

doc Get a key from a Hash and remove it from the Hash.
doc If they key is not in the Hash, return dflt
doc %EX - h = {}
doc %EX - h.shift("a", 7)  # 7
F shift(h:Hash, k, dflt) {
	k not in h returns dflt
	h[k]::{ del(h, k) }
}

TEST h={"a": 1}; s = h.shift("a"); h == {} and s == 1
TEST h={}; try h.shift("a") catch(e:KeyNotFound) true
TEST h={}; h.shift("a", 7) == 7
TEST h={"a": 1, "b": 2}; s = h.shift("a"); h == {"b": 2} and s == 1


# === Box ========================================

# Inspired by Option from Scala. http://www.scala-lang.org/api/2.12.x/scala/Option.html

doc Thrown when trying to get() a value from EmptyBox and no default value given.
type BoxFail(Error)

doc A box which might (FullBox) or might not (EmptyBox) contain a value.
doc Box is somewhat similar to Arr of zero (EmptyBox) or exactly one (FullBox) element.
doc This analogy helps understanding each() and filter() operation.
type Box(Eachable1)

	doc Represents presence of a value
	doc val - The value
	type FullBox(Box)

	doc Represents absence of a value
	type EmptyBox([Box, NoData])

doc Do not use directly!
doc Helper constructor that throws InvalidArgument when
doc FullBox is created with zero or more than one argument.
F init(b:FullBox, *args) throw InvalidArgument("FullBox must be initialized with exactly one value")

doc FullBox constructor. Saves val into .val
doc %EX - # Simplified code from the_one() method:
doc %EX - ret = EmptyBox()
doc %EX - something.each(F(elt) {
doc %EX - 	if elt =~ pattern {
doc %EX - 		ret throws ElementNotFound("the_one() had more than one match")
doc %EX - 	}
doc %EX - 	ret = FullBox(elt)
doc %EX - })
doc %EX - not(ret) throws ElementNotFound("the_one() had no matches")
doc %EX - ret.val # Has the value
F init(b:FullBox, val) b.val = val

doc Always true
F Bool(fb:FullBox) true

doc Always false
F Bool(eb:EmptyBox) false

doc Zero for FullBox and one for EmptyBox
F ExitCode(b:Box) b.Bool().ExitCode()

doc Map FullBox value
doc mapper - mapper to be called with the FullBox value
doc %RET - FullBox with value returned by mapper
doc %EX - Box(10).map(X*2)  # <FullBox val=20>
F map(fb:FullBox, mapper:Fun) FullBox(mapper(fb.val))

doc Do nothing
doc %RET - eb
doc %EX - EmptyBox().map(X*2)  # <EmptyBox>
F map(eb:EmptyBox, mapper:Fun) eb

doc Call cb with the value of the FullBox
doc %RET - fb
doc %EX - Box(10).each(echo)  # Output: 10
F each(fb:FullBox, cb:Fun) { cb(fb.val); fb }

doc Do nothing
doc %RET - eb
doc %EX - Box(null).each(echo)  # No output
F each(eb:EmptyBox, cb:Fun) eb

# each() allows any()
TEST Box(5).any(Int)
TEST EmptyBox().any(Str) == false
TEST EmptyBox().any(Int) == false

# each() allows none()
TEST Box(5).none(Int) == false
TEST Box(5).none(Str)
TEST EmptyBox().none(Int)

doc Conditionally convert FullBox to EmptyBox.
doc pattern - Test function or anything else acceptable by =~ to be called with the value in the FullBox, defaults to Bool.constructors
doc %RET - Box. fb if pattern succeeds, EmptyBox if not.
doc %EX - Box(10).filter(X>5)   # <FullBox val=10>
doc %EX - Box(10).filter(X>20)  # <EmptyBox>
F filter(fb:FullBox, pattern=Bool.constructors) {
	# Can not use "...super(fb, pattern) or EmptyBox()" because filter(Eachable1, ...) can't create FullBox
	# ("FullBox must be initialized with exactly one value") on order to push() into it
	fb.val =~ pattern returns fb
	EmptyBox()
}

TEST FullBox(null).filter() == EmptyBox()

# Done by filter(Eachable1)
TEST EmptyBox().filter() == EmptyBox()

doc Get FullBox value
doc %RET - Any
doc %EX - Box(10).get()  # 10
F get(fb:FullBox, dflt=null) fb.val

doc Get EmptyBox value. Always throws BoxFail.
F get(eb:EmptyBox) throw BoxFail("Can not get value from EmptyBox")

TEST { EmptyBox().get() }.assert(BoxFail)

doc Get EmptyBox value
doc %RET - dflt
F get(eb:EmptyBox, dflt) dflt

TEST EmptyBox().get(10) == 10

doc Length of FullBox
doc %RET - 1
F len(fb:FullBox) 1

doc Length of EmptyBox
doc %RET - 0
F len(eb:EmptyBox) 0

doc Convert anything to Box (always FullBox)
doc x - value to enclose in a box
doc %RET - FullBox with given value
doc %EX - Box(7).map(X*2).get()  # 14
F Box(x) FullBox(x)

doc Convert Box with no arg to EmptyBox
doc %RET - EmptyBox
doc %EX - Box() == EmptyBox()
doc %EX - Box().get(10)  # 10
doc %EX - Box().map(X*2).get()  # InvalidArgument exception (in "get()")
F Box() EmptyBox()

TEST Box().get(10) == 10
TEST Box() == EmptyBox()

doc Convert null to Box (always EmptyBox)
doc %RET - EmptyBox
doc %EX - Box(null) == EmptyBox()
doc %EX - Box(null).map(X*2).get()  # InvalidArgument exception (in "get()")
F Box(n:Null) EmptyBox()

TEST Box(null) == EmptyBox()

doc Convert array value indexed by the given index
doc idx - key to look in hash
doc %RET - Box. FullBox if the array has the element indexed by idx, EmptyBox otherwise.
doc %EX - my_array = [10, 20]
doc %EX - my_array.Box(1).map(X*2).each(echo)
doc %EX - # output: 40
doc %EX - my_array.Box(5).map(X*2).each(echo)
doc %EX - # no output
F Box(a:Arr, idx:Int) if a.has_index(idx) then FullBox(a[idx]) else EmptyBox()

doc Convert hash value indexed by the given key to a Box
doc k - key to look in hash
doc %RET - Box. FullBox if the hash has the element referenced by k, EmptyBox otherwise.
doc %EX - my_hash = {"a": 10, "b": 300}
doc %EX - my_hash.Box("a").map(X*2).each(echo)
doc %EX - # output: 20
doc %EX - my_hash.Box("nope").map(X*2).each(echo)
doc %EX - # no output
F Box(h:Hash, k) {
	k not in h returns EmptyBox()
	FullBox(h[k])
}

doc Do nothing
doc %RET - fb
doc %EX - my_array = [10, 20]
doc %EX - # dflt on FullBox has no effect
doc %EX - my_array.Box(1).dflt(100).map(X*2).each(echo) # HERE
doc %EX - # output: 40
doc %EX - # dflt on EmptyBox creates FullBox with the given value
doc %EX - my_array.Box(5).dflt(100).map(X*2).each(echo)
doc %EX - # output: 200
F dflt(fb: FullBox, x) fb

doc Wrap x in a Box
doc %RET - FullBox with the value x
doc %EX - my_array = [10, 20]
doc %EX - # dflt on FullBox has no effect
doc %EX - my_array.Box(1).dflt(100).map(X*2).each(echo)
doc %EX - # output: 40
doc %EX - # dflt on EmptyBox creates FullBox with the given value
doc %EX - my_array.Box(5).dflt(100).map(X*2).each(echo) # HERE
doc %EX - # output: 200
F dflt(eb: EmptyBox, x) FullBox(x)

doc Compare boxes. Empty boxes and boxes with same content are considered to be equal.
doc %RET - Bool
doc %EX - EmptyBox() == EmptyBox()
doc %EX - EmptyBox() != FullBox(1)
doc %EX - FullBox(1) == FullBox(1)
doc %EX - FullBox(1) != FullBox(2)
F ==(b1:Box, b2:Box) {
	# Boxes comparison stolen from
	# http://learnyouahaskell.com/making-our-own-types-and-typeclasses
	# "instance Eq (Maybe m) where"
	b1 is EmptyBox and b2 is EmptyBox returns true
	b1 is FullBox and b2 is FullBox and b1.val == b2.val returns true
	false
}

TEST EmptyBox() == EmptyBox()
TEST EmptyBox() != FullBox(1)
TEST FullBox(1) == FullBox(1)
TEST FullBox(1) != FullBox(2)

doc Convert EmptyBox into JSON compatible data structure - null
F JsonData(eb:EmptyBox) null

doc Convert FullBox into JSON compatible data structure - the contents of the box
F JsonData(fb:FullBox) fb.get().JsonData()

# === Result =====================================

doc Thrown by get(Failure) as it has no value to get
type ResultFail(Error)



doc Results, an array-like of Result elements
type Results(ArrLike)

	F Str(r:Results) "<${r.Type().name} ${r.group(F(x) x.Type().name).mapv(len).map("$X:$Y").join(" ")}>"

type ResultsException(Error)
	doc ResultsException where only failures are stored
	type FailuresException(ResultsException)

F init(re:ResultsException, msg:Str, results:Results) {
	super(re, msg)
	re.set('results', results)
}

doc Runs the computation and wraps the result: a value is wrapped in Success and an exception is wrapped in Failure.
doc %RET - Success or Failure
F Result(fun:Fun) {
	try {
		Success(fun())
	} catch(e) {
		Failure(e)
	}
}

doc Initialize Success with the given value.
F init(s:Success, v=null) s.val = v

doc Initialize Failure with the given value.
F init(f:Failure, e:Exception) f.val = e

doc Gets wrapped value
doc %RET - Any
doc %EX - { 1 / 10 }.Result().get()  # 0
F get(s:Success) s.val

doc Throws ResultFail
doc %EX - { 1 / 0 }.Result().get()  # ResultFail exception
F get(f:Failure) {
	throw ResultFail("Can not get value of Failure", f.val)
}

doc Gets wrapped value
doc %RET - Any
doc %EX - { 1 / 10 }.Result().get(100)  # 0
F get(s:Success, dflt) s.val

doc Returns dflt
doc %EX - { 1 / 0 }.Result().get(100)  # 100
F get(f:Failure, dflt) dflt

doc Run fun with wrapped value.
F each(s:Success, fun:Fun) {
	fun(s.get())
	s
}

doc Run fun with wrapped value. If exception is thrown, Failure is returned; otherwise Success with new value is returned.
doc %RET - Result
F map(s:Success, fun:Fun) Result({ fun(s.get()) })

doc No-op, returns f
doc %RET - f
F each(f:Failure, fun:Fun) f

doc No-op, returns f
doc %RET - f
F map(f:Failure, fun:Fun) f

doc Check whether wrapped value matches the pattern.
doc %RET - s or Failure
doc %EX - Success(10).filter(X>5)   # <Success val=10>
doc %EX - Success(10).filter(X>15)  # <Failure val=<ResultFail ...>>
F filter(s:Success, pattern=Bool.constructors) {
	s.val =~ pattern returns s
	Failure(ResultFail("Success filtered out, resulting Failure").set('pattern', pattern))
}

TEST Result({100}).filter() == Success(100)

doc No-op, returns f
doc %RET - f
doc %EX - Failure("blah").filter(X>5)  # <Failure val=blah>
F filter(f:Failure, pattern=Bool.constructors) f

TEST Result({1/0}).filter() is Failure

doc Convert Success to Bool (true)
doc %RET - true
F Bool(s:Success) true

doc Convert Failure to Bool (false)
doc %RET - false
F Bool(f:Failure) false

doc EXPERIMENTAL! Do not use!
F ExitCode(r:Result) r.Bool().ExitCode()

TEST {read("/etc/passwd")}.Result() is Success
TEST {read("NO-SUCH-FILE")}.Result() is Failure
TEST Success(10).map(X*2).get() == 20
TEST { { throw Error("xx") }.Result().map(X*2).get() }.assert(ResultFail)

doc Convert Success into JSON compatible data structure - the value of the computation
F JsonData(s:Success) s.get().JsonData()

# === Diff =======================================

doc Represents desired target configuration list item presence
type Presence

	type PartialPresence([FullBox, Presence])

		doc Represents a target configuration list item that must be present
		type Present([FullBox, PartialPresence])

		doc Represents a target configuration list item that must be absent
		type Absent([FullBox, PartialPresence])

	doc Represents a target configuration list item in a list
	type ExactPresence([FullBox, Presence])

	doc Checks element presence.
	doc %RET - Bool
	doc %EX - [1,2,3] =~ Present(3)  # MatchSuccess
	F =~(x, p:Present, mc:MatchContext) block b {
		x is Int or x is Str returns false
		x is not Eachable1 returns false
		mc.deeper({
			x.each_idx_val(F(idx, item) {
				if (=~)(item, p.val, mc.set_last_path_element(idx)) {
					b.return(true)
				}
			})
		})
		false
	}

	TEST [1,2,3] =~ Present(3)

	doc Checks element absence.
	doc %RET - Bool
	doc %EX - [1,2,3] =~ Absent(0)  # MatchSuccess
	F =~(x, a:Absent, mc:MatchContext) not((=~)(x, Present(a.val), mc))

	TEST [1,2,3] =~ Absent(0)


doc Internal method. Please do not use.
doc Converts Presence or Arr[something] to Arr[Presence]. Used by Res and friends.
F normalize_presence_list(x) {
	econd {
		x is Presence   { [x] }
		x.all(Presence) x
		x is Eachable1  {
			x.any(Presence) throws InvalidArgument("Mixing Presence and non-Presence items in a list is not supported").set('value', x)
			x.map(ExactPresence)
		}
	}
}


doc Represents difference
type Diff
doc Represents difference of elements between two arrays (order unimportant)
type ArrDiff(Diff)
doc Represents difference of elements between two hashes (order unimportant)
type HashDiff(Diff)

doc Compare arrays. Warning: by default Hash is used so internal Hash keys comparison is used, not ==
doc full - Do not use Hash, work slower but use == comparison.
doc %EX - Diff([1,2], [2,3])  # .add = [3] .remove = [1]
F Diff(a:Arr, b:Arr, full:Bool=false) {
	d = ArrDiff()
	if full {
		d.add    = b.filter(X not in a)
		d.remove = a.filter(X not in b)
	} else {
		ah = Hash(a, {true})
		bh = Hash(b, {true})
		d.add    = bh.reject(X in ah).keys()
		d.remove = ah.reject(X in bh).keys()
	}
	d
}

TEST Diff([1,2], [2,3]) =~ {'add': [3], 'remove': [1]}

doc EXPERIMENTAL! Do not use!
doc Compare arrays using eq as equality test. 2*n*m comparisons
doc %RET - ArrDiff
doc %STATUS - experimental
F Diff(a:Arr, b:Arr, eq:Fun) {
	d = ArrDiff()
	d.add    = b.filter(F(x) a.none(eq(x, X)))
	d.remove = a.filter(F(x) b.none(eq(x, X)))
	d
}

doc Compare arrays. Warning: by default Hash is used so internal Hash keys comparison is used, not ==
doc full - Do not use Hash, work slower but use == comparison.
doc b - Arr[PartialPresence]
doc %RET - ArrDiff
doc %EX - Diff([1,2,3], [Present(1)])  # <ArrDiff add=[] remove=[]>
doc %EX - Diff([1,2,3], [Present(5)])  # <ArrDiff add=[5] remove=[]>
doc %EX - Diff([1,2,3], [Absent(1)])   # <ArrDiff add=[] remove=[1]>
doc %EX - Diff([1,2,3], [Absent(5)])   # <ArrDiff add=[] remove=[]>
doc %EX - Diff(["a", "b"], [Present("a"), Present("c"), Absent("b"), Absent("d")])  # <ArrDiff add=[c] remove=[b]>
F Diff(a:Arr, b:Arr, full:Bool=false) {
	guard b and b.all(PartialPresence)

	d = ArrDiff()
	if full {
		d.add    = b.filter(Present).map(get).filter(X not in a)
		d.remove = a.filter(X in b.filter(Absent).map(get))
	} else {
		ah = Hash(a, {true})
		d.add    = Hash(b.filter(Present).map(get), b).reject(X in ah).keys()
		d.remove = ah.filter(X in Hash(b.filter(Absent).map(get), b)).keys()
	}
	d
}

TEST Diff(["a", "b"], [Present("a"), Present("c"), Absent("b"), Absent("d")], false) =~ {"add": ["c"], "remove": ["b"]}
TEST Diff(["a", "b"], [Present("a"), Present("c"), Absent("b"), Absent("d")], true) =~ {"add": ["c"], "remove": ["b"]}

doc Compare arrays. Warning: by default Hash is used so internal Hash keys comparison is used, not ==.
doc Calls Diff(a, b.map(get), full)
doc full - Do not use Hash, work slower but use == comparison.
doc b - Arr[ExactPresence]
doc %RET - Diff
F Diff(a:Arr, b:Arr, full:Bool=false) {
	guard b and b.all(ExactPresence)
	Diff(a, b.map(get), full)
}

doc Check whether there is a difference
doc %RET - Bool
doc %EX - arr_diff = Diff(current, desired)
doc %EX - # Implicit Bool() when using in "if": if arr_diff -> if Bool(arr_diff)
doc %EX - if arr_diff {
doc %EX -   echo("Will make modifications to the resource")
doc %EX -   if arr_diff.add {
doc %EX -     ...
doc %EX -   }
doc %EX -   if arr_diff.remove {
doc %EX -     ...
doc %EX -   }
doc %EX - }
F Bool(d:ArrDiff) Bool(d.add or d.remove)

doc Compare hashes
doc %EX - diff = Diff(current_tags, target_tags)
doc %EX - if (tags = AWS::cli_tags(diff.add + diff.change)) {
doc %EX - 	r.run('update_tags/add', %(aws ec2 create-tags --resources ${r.id()} --tags $*tags))
doc %EX - }
doc %EX - if (tags = diff.remove / "Key=$X") {
doc %EX - 	r.run('update_tags/remove', %(aws ec2 delete-tags --resources ${r.id()} --tags $*tags))
doc %EX - }
F Diff(a:Hash, b:Hash) {
	HashDiff().set(
		add    = b.reject(X in a)
		change = b.filter(X in a).filter(F(k, v) a[k] != v)
		remove = a.reject(X in b).keys()
	)
}

TEST Diff({"a": 1, "b":2}, {"b": 3, "d": 4}) =~ {"add":{"d":4}, "change":{"b":3}, "remove":["a"]}

doc Whether there is a difference
doc %RET - Bool
doc %EX - hash_diff = Diff(current_properties, desired_properties)
doc %EX - # Implicit Bool() when using in "if": if hash_diff -> if Bool(hash_diff)
doc %EX - if hash_diff {
doc %EX -   echo("Will make modifications to the resource")
doc %EX -   if hash_diff.add {
doc %EX -     ...
doc %EX -   }
doc %EX -   if hash_diff.remove {
doc %EX -     ...
doc %EX -   }
doc %EX -   if hash_diff.change {
doc %EX -     ...
doc %EX -   }
doc %EX - }
F Bool(d:HashDiff) Bool(d.add or d.remove or d.change)

doc Convert Diff into JSON compatible data structure - object with "add" and "remove" fields.
doc For HashDiff, additional "change" field will be present.
F JsonData(d:Diff) d.Hash().JsonData()

# === Bool =======================================

doc Convert a Bool to NGS code that would produce the given Bool when executed. Not fully functional yet.
doc %RET - Str
F code(b:Bool) Str(b)

doc Convert Bool into JSON compatible data structure - boolean
F JsonData(b:Bool) b

# === Int ========================================

doc Absolute value of a number
doc %EX - abs(5)   # 5
doc %EX - abs(-5)  # 5
F abs(i:Int) {
	i >= 0 returns i
	0-i
}

doc Useful for knowing how much times each() callback would be invoked.
doc Alternatively, how many elements map() result would have.
doc %RET - i
F len(i:Int) i

# --- Functional ---

doc Iterate from zero up to but not including n
doc cb - Function to call with current number
doc args - Additional arguments for calling cb
doc %EX - 10.each(echo)  # Outputs numbers from 0 to 9 inclusive, one on each line
doc %RET - n
F each(n:Int, cb:Fun) {
	for(i;n) cb(i)
	n
}

TEST 3.map(identity) == [0, 1, 2]
TEST 3.map(X*3) == [0, 3, 6]

doc Call cb n times without arguments.
doc cb - Function to call
doc args - Arguments for calling cb
doc %EX - r=0; 5.times(F() r=r+2);  # r is now 10
F times(n:Int, cb:Fun) n::{ for(i;A) cb() }

TEST r=0; 5.times(F() r=r+2); r==10

doc Convert Int to Int, a no-op
doc %RET - i
F Int(i:Int) i

doc Convert to Int.
doc Throws InvalidArgument if the number in s is not well-formatted.
doc %RET - Int
doc %EX - Int(" 100 ")  # 100
F Int(s:Str, base=10) {
    base not in 0...36 throws InvalidArgument("Base must be between 0 and 36").set(s=s, base=base)
    try {
        super(s, base)
    } catch(i: InvalidArgument) {
        # Augment exception with more information
        throw i.set(s=s, base=base)
    }
}

TEST Int("100") == 100
TEST { Int("100x") }.assert(InvalidArgument)
TEST { Int(" XX") }.assert(InvalidArgument)
TEST Int(" XX", 36) == 1221
TEST { Int("9" * 1000) }.assert(InvalidArgument)

doc Convert Bool to int.
doc %RET - Int
doc %EX - true.Int()   # 1
doc %EX - false.Int()  # 0
F Int(b:Bool) if b 1 0

TEST true.Int() == 1
TEST false.Int() == 0

doc Convert an Int to NGS code that would produce the integer when executed. Not fully functional yet.
doc %RET - Str
F code(n:Int) Str(n)

doc Convert Int into JSON compatible data structure - number
F JsonData(n:Int) n

section "Strings and characters" {

	# https://docs.python.org/2/library/string.html
	CHARS = ns {
		ascii_lowercase = 'abcdefghijklmnopqrstuvwxyz'
		ascii_uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
		ascii_letters = ascii_lowercase + ascii_uppercase
		digits = '0123456789'
		hexdigits_uppercase = '0123456789ABCDEF'
		hexdigits_lowercase = '0123456789abcdef'
		octdigits = '01234567'
		base64 = ascii_uppercase + ascii_lowercase + digits + '+/'
		base64url = ascii_uppercase + ascii_lowercase + digits + '-_'
		html_escape = {'&': '&amp;', '<': '&lt;', '>': '&gt;'}
		html_attr_escape = html_escape + {'"': '&quot;', "'": '&#39;'}

		section "Unused by stdlib" {
			# Unused by stdlib. Previously was used by escape_bash().
			shell_escape = {'\\': '\\\\', '"': '\\"', "'": "\\'", '&': '\\&'}
			shell_escape_with_eq = shell_escape + {'=': '\\='}
		}

	}

	section "Str constructors" {
		doc No-op constructor
		doc %RET - s
		F Str(s:Str) s

		doc Convert Null to string
		doc %RET - the string "null"
		F Str(n:Null) "null"
		F Str(b:Bool) if b "true" "false"

		doc Convert Arr to string
		doc %RET - Str
		F Str(a:Arr) "[${a.map(Str).join(',')}]"

		doc Convert Hash to string
		doc %RET - Str
		F Str(h:Hash) "{" + h.map(F(k, v) "${k}=${v}").join(", ") + "}"
	}

	# --- Functional ---

	doc Iterates over all string characters (currently bytes).
	doc cb - Function to be called with each character from s
	doc args - Additional arguments for calling cb
	doc %RET - s
	doc %EX - "abc".each(echo)
	doc %EX - # Output:
	doc %EX - # a
	doc %EX - # b
	doc %EX - # c
	F each(s:Str, cb:Fun) {
		s.len().each(F(idx) {
			cb(s[idx])
		})
		s
	}

	# --- Sugar ---

	doc Find substring in a string.
	doc haystack - The string to search in
	doc needle - The string to find
	doc %RET - Int or null
	doc %EX - pos("abc", "cd")     # null
	doc %EX - pos("abcdef", "cd")  # 2
	F pos(haystack:Str, needle:Str) pos(haystack, needle, 0)

	TEST pos("abc", "cd") == null
	TEST pos("abcdef", "cd") == 2

	TEST pos("a:b:c", ":") == 1
	TEST pos("a:b:c", ":", 2) == 3

	doc Determine if needle substring occurs at least once in haystack
	doc haystack - The string to search in
	doc needle - The string to find
	doc %RET - Bool
	doc %EX - "bc" in "abcd"
	doc %EX - "x" not in "abcd"
	F in(needle:Str, haystack:Str) pos(haystack, needle) is not Null

	TEST "bc" in "abcd"
	TEST "x" not in "abcd"

	doc Get given character (currently byte) of the string
	doc s - Original string
	doc i - Index of the character to return
	doc %EX - "abc"[0]  # "a"
	F '[]'(s:Str, i:Int) s[i..i+1]

	TEST ("abc"[0] == "a") and ("abc"[2] == "c")
	TEST { "abc"[3] == "x" }.assert(IndexNotFound)

	doc Get given character (currently byte) of the string (negative indexes handler). Throws IndexNotFound if abs(i) > len(s).
	doc s - Original string.
	doc i - Negative index of the character to return
	doc %EX - "abc"[-1]  # "c"
	F '[]'(s:Str, i:Int) {
		guard i < 0
		i < 0-s.len() throws IndexNotFound("Negative index into string is (abs) larger than the string")
		s[s.len()+i]
	}

	TEST ("abc"[-1] == "c") and ("abc"[-3] == "a")
	TEST { "abc"[-4] == "x" }.assert(IndexNotFound)

	doc Get a substring. Indexes in s are specified by NumRange.
	doc s - Original string
	doc r - NumRange with negatve .end
	doc %EX - "(Look ma, no parens)"[1..-1]  # "Look ma, no parens"
	doc %RET - Str
	F '[]'(s:Str, r:NumRange) {
		guard r.end is Int and r.end < 0
		r.end < 0 - s.len() throws InvalidArgument("Negative index (range end) into string is (abs) larger than the string")
		s[r.start..s.len() + r.end]
	}

	# --- Misc utilities ---

	doc Split string by substring
	doc s - String to split
	doc delim - Delimiter to split by
	doc max_parts - Maximum number of resulting parts, 0 - unlimited
	doc %RET - Arr of Str
	doc %EX - ":a:bc:d:".split(":")   # ["", "a", "bc", "d", ""]
	doc %EX - "bucket_name/dir/file".split("/", 2)  # ["bucket_name", "dir/file"]
	doc %EX - ":a:bc:d:".split("bc")  # [":a:", ":d:"]
	F split(s:Str, delim:Str, max_parts:Int=0) {
		l = delim.len()
		guard l > 0
		start = 0
		parts = 0
		collector {
			while (p = pos(s, delim, start)) is not Null {
				collect(s[start..p])
				start = p + l
				parts += 1
				parts == max_parts - 1 breaks
			}
			collect(s[start..null])
		}
	}

	TEST ":a:bc:d:".split(":") == ["", "a", "bc", "d", ""]
	TEST "bucket_name/dir/file".split("/", 2) == ["bucket_name", "dir/file"]
	TEST ":a:bc:d:".split("bc") == [":a:", ":d:"]

	# Candidate to move out of stdlib
	doc Split the string by delimiter and return the last part
	doc %RET - Str
	F before_first(s:Str, delim:Str) {
		p = s.pos(delim)
		p is Null throws InvalidArgument("Delimiter not found in before_first()").set(val=s, delim=delim)
		s[0..p]
	}

	TEST "a:b".before_first(":") == "a"
	TEST {"a:b".before_first("*")}.assert(InvalidArgument)

	doc Split the string by delimiter and return the last part
	doc %RET - Str
	F after_last(s:Str, delim:Str) {
		# s.split(delim)[-1]
		p = s.pos(delim)
		p is Null throws InvalidArgument("Delimiter not found in after_last()").set(val=s, delim=delim)
		s[(p+len(delim))..null]
	}

	TEST "a:b".after_last(":") == "b"
	TEST {"a:b".after_last("*")}.assert(InvalidArgument)

	doc Trim whitespace
	F trim(s:Str) s - /^[[:space:]]*/ - /[[:space:]]*$/

	doc Repeat string n times
	doc %EX - "abc" * 3  # "abcabcabc"
	F *(s:Str, n:Int) ([s]*n).join('')

	# Tested with Str(Str,Int)

	doc Convert anything to Str of a given width
	F Str(x, target_width:Int, ch:Str=' ') x.Str().Str(target_width, ch)

	doc Pad a string to given width with spaces
	doc target_width - Positive pads on right, negative pads on left
	doc %EX - Str("x", 3)  # 'x  '
	doc %EX - Str("x",-3)  # '  x'
	F Str(s:Str, target_width:Int, ch:Str=' ') {
		assert(len(ch) == 1)
		l = s.len()
		pad_on_left = target_width < 0
		if pad_on_left {
			target_width = 0 - target_width
		}

		l >= target_width returns s

		padding = ch * (target_width - l)
		if pad_on_left {
			padding + s
		} else {
			s + padding
		}
	}

	# Not sure about this, might be confusing behaviour
	doc Convert a number to a string and pad it
	doc target_width - Positive pads on left, negative pads on right
	doc %EX - Str(10,  4)  # '  10'
	doc %EX - Str(10, -4)  # '10  '
	F Str(n:Int, target_width:Int, ch:Str=' ') n.Str().Str(0-target_width, ch)

	TEST Str(10,  4) == '  10'
	TEST Str(10,  4, '0') == '0010'
	TEST Str(10, -4) == '10  '
	TEST Str('x', 3) == 'x  '
	TEST Str('x',-3) == '  x'
	TEST Str('x',-3, '.') == '..x'

	doc Check whether a string starts with another string
	doc %RET - Bool
	doc %EX - "abcd".starts_with("ab")  # true
	doc %EX - "ab".starts_with("abcd")  # false
	F starts_with(haystack:Str, needle:Str) {
		needle.len() > haystack.len() returns false
		haystack[0..needle.len()] == needle
	}

	TEST "abcd".starts_with("ab")
	TEST "ab".starts_with("abcd") == false

	doc Check whether a string ends with another string
	doc %RET - Bool
	doc %EX - "abcd".ends_with("cd")  # true
	doc %EX - "ab".ends_with("cdab")  # false
	F ends_with(haystack:Str, needle:Str) {
		needle.len() > haystack.len() returns false
		l = haystack.len()
		haystack[l - needle.len()..l] == needle
	}

	TEST "abcd".ends_with("cd")
	TEST "ab".ends_with("cdab") == false


	doc Case-insensitive LessThan or Equal comparison for strings
	doc %RET - Bool
	F lte(a:Str, b:Str)
		c_strcasecmp(a, b) <= 0

	doc Case sensitive LessThan or Equal comparison for strings
	doc %RET - Bool
	F '<='(a:Str, b:Str)
		c_strcmp(a, b) <= 0

	doc Case sensitive GreaterThan or Equal comparison for strings
	doc %RET - Bool
	F '>='(a:Str, b:Str)
		c_strcmp(a, b) >= 0

	doc Case sensitive LessThan comparison for strings
	doc %RET - Bool
	F '<'(a:Str, b:Str)
		c_strcmp(a, b) < 0

	doc Case sensitive GreaterThan comparison for strings
	doc %RET - Bool
	F '>'(a:Str, b:Str)
		c_strcmp(a, b) > 0

	doc Split s to strings using end-of-line separators.
	doc Same as Lines(s).Arr()
	doc %RET - Arr
	F lines(s:Str) Lines(s).Arr()

	doc Split s to strings using end-of-line separators and call cb for each one of the lines.
	doc TODO: More efficient implementation, which would not have temporary array of all lines.
	doc cb - Function to be called with each line
	doc args - Additional arguments for calling cb
	F lines(s:Str, cb:Fun) {
		lines(s).each(cb)
	}

	TEST "xx\nyy".lines() == %[xx yy]

	doc Read all data from a file referenced by file descriptor 0 (stdin) and split into lines
	doc %RET - Arr
	F lines() read().lines()

	# Inspired by https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#v:words
	doc Split string to words. Word is any non-whitespace.
	doc %RET - Arr of Str
	F words(s:Str) (s ~~ /\S+/m).matches.map(X[0])

	TEST "ab cd\nef".words() == %[ab cd ef]
	TEST " x y  ".words() == %[x y]

	doc Prepend each line in a with s
	doc %EX - "a " + ["1", "2"]  # ["a 1", "a 2"]
	doc %RET - Type of ret is same as type of a
	F +(s:Str, a:Eachable1) {
		guard a is not Str
		guard a.all(Str)
		a.mapo(s+X)
	}
	TEST "a " + ["1", "2"] == ["a 1", "a 2"]

	doc Append s to each line in a
	doc %EX - ["1", "2"] + " a"  # ["1 a", "2 a"]
	doc %RET - Type of ret is same as type of a
	F +(a:Eachable1, s:Str) {
		guard a is not Str
		guard a.all(Str)
		a.mapo(X+s)
	}
	TEST ["1", "2"] + " a" == ["1 a", "2 a"]

	doc Map a string, character by character.
	doc %EX - "abcd".mapo(F(x) if x == "b" then "X" else x)  # "aXcd"
	doc %RET - Str
	F mapo(s:Str, mapper:Fun) s.map(mapper).join('')

	TEST "abcd".mapo(F(x) if x == "b" then "X" else x) == "aXcd"

	doc Truncate a string if necessary so it would have maximum n characters (currently bytes).
	doc s - The string to (possibly) truncate.
	doc n - Maximum characters
	doc marker - The truncation marker
	doc %RET - Either s or new Str of length n
	doc %EX - "abc".limit(5, "...")     # "abc"
	doc %EX - "abcdef".limit(5, "...")  # "ab..."
	doc %EX - "abcdef".limit(2)         # "ab"
	F limit(s:Str, n:Int, marker:Str='') {
		s.len() <= n returns s
		if marker {
			lim = n - len(marker)
			s[0..lim] + marker
		} else {
			s[0..n]
		}
	}

	TEST "abc".limit(5, "...") == "abc"
	TEST "abcdef".limit(5, "...") == "ab..."
	TEST "abcdef".limit(2) == "ab"

	doc Get character (currently byte) code. Throws InvalidArgument if s is not of length 1.
	doc %EX - ord("A")  # 65 on my machine
	F ord(s:Str) {
		s.len() != 1 throws InvalidArgument("ord() argument must be of length 1 exactly").set('given', s)
		ord(s, 0)
	}

	doc Find substring in string. Uses pos().
	doc %RET - MatchResult
	doc %EX - "abc" ~ "bc"  # <MatchSuccess ...>
	doc %EX - "abc" ~ "X"   # <MatchFailure>
	F ~(haystack:Str, needle:Str, offset:Int=0) {
		p = pos(haystack, needle, offset)
		p is Null returns MatchFailure(haystack, needle)
		l = needle.len()
		ret = MatchSuccess([needle], needle)
		ret.named = {}
		ret.positions = [p..p+l]
		ret.whole = ret.matches[0]
		ret.before = haystack[0..p]
		ret.after = haystack[p+l..null]
		ret
	}

	doc Find all non-overlapping matches of a substring in a string.
	doc %RET - if collect_unmatched - Arr with each element being MatchSuccess or Str, if not collect_unmatched - Arr of MatchSuccess
	F ~~(haystack:Str, needle:Str, collect_unmatched:Bool=false) {
		collector {
			m = (~)(haystack, needle, 0)
			if not(m) {
				if collect_unmatched collect(haystack)
				return null
			}
			start_offset = m.positions[0].start
			next_offset = m.positions[0].end
			if collect_unmatched and start_offset then collect(haystack[0..start_offset])
			collect(m)
			while true {
				if start_offset == next_offset {
					next_offset == len(haystack) breaks
				}
				m = (~)(haystack, needle, next_offset)
				if m {
					if collect_unmatched {
						if next_offset != m.positions[0].start {
							collect(haystack[next_offset..(m.positions[0].start)])
						}
					}
					start_offset = m.positions[0].start
					next_offset = m.positions[0].end
					collect(m)
					continue
				}
				break
			}
			if collect_unmatched and (next_offset < len(haystack)) {
				collect(haystack[next_offset..null])
			}
		}
	}

	TEST m = (~~)("abcbe", "b", true); m.len() == 5 and m[[0,2,4]] == %[a c e] and m[[1,3]].all(MatchSuccess)

	doc Replace all occurrences of src with dst in s
	F replace(s:Str, src:Str, dst:Str) (~~)(s, src, true).map(only(MatchSuccess, {dst})).join('')

	TEST "x10ab20c30y".replace("0", "X") == "x1Xab2Xc3Xy"

	doc Convert a Str to NGS code that would produce the string when executed. Not fully functional yet.
	doc BUG: Does not do escaping.
	doc %RET - Str
	F code(s:Str) {
		# XXX TODO: escaping
		"'${s}'"
	}

	doc String expansion handler. Called automatically for every double-quoted string that has $* components.
	doc %EX - "$*{ENV.PATH.split(":")}/od".filter(File(X))  # Find out where in PATH is the "od" binary
	doc %AUTO - "abc$*{something}def"
	F '"$*"'(components:Arr) {
		components.len() == 0 throws InvalidArgument("Must be one or more component")
		c = components
		c_len = c.len()
		cached_str = c.map(F(elt:NgsStrComp) {
			elt is not NgsStrCompSplatExp returns Str(elt.val)
		})
		collector {
			F kern(acc:Arr, i:Int) {
				if i == c_len {
					collect(acc.join(''))
					return
				}
				if c[i] is NgsStrCompSplatExp {
					c[i].val.each(F(v) kern(acc + [v], i+1))
				} else {
					kern(acc + [cached_str[i]], i+1)
				}
			}
			kern([], 0)
		}
	}

	TEST "a$*{[1,2]}b$*{10..12}c" == ["a1b10c", "a1b11c", "a2b10c", "a2b11c"]

	doc Convert Str into JSON compatible data structure - string
	F JsonData(s:Str) s
}

section "Stats" {
	doc A group of named counters
	doc h - The underlying Hash
	doc %EX - s = Stats().push('a').push('a').push('b')
	doc %EX - s["a"]  # 2
	doc %EX - s["b"]  # 1
	doc %EX -
	doc %EX - a = ["x", "y", "y"]
	doc %EX - s = Stats(a)
	doc %EX - s["x"]  # 1
	doc %EX - s["y"]  # 2
	type Stats(HashLike)

	doc Makes Stats, with each element in the array counted as if push()ed
	doc %EX - Stats(['a', 'a', 'b']).Hash()  # {'a': 2, 'b': 1}
	doc %EX - Stats("AABC").Hash()  # {A=2, B=1, C=1}
	F init(s:Stats, e:Eachable1) {
		init(s)
		e.each(push(s, X))
	}

	doc Increment the named counter
	doc k - the name of the counter to increment
	doc %EX - Stats().push("a").push("a").push("b")["a"]  # 2
	F push(s:Stats, k) {
		h = s.meta().HashLike
		h[k] = h.get(k, 0) + 1
		s
	}

	TEST Stats().push('a').push('a').push('b').Hash() == {'a': 2, 'b': 1}
	TEST Stats(['a', 'a', 'b']).Hash() == {'a': 2, 'b': 1}
	TEST Stats(['a', 'a', 'b'])['a'] == 2
	TEST Stats(['a', 'a', 'b']).a == 2

	doc Convert Stats into JSON compatible data structure - object
	F JsonData(s:Stats) s.Hash().JsonData()

	F collector(s:Stats, body:Fun) {
		body(push(s, X))
		s
	}

	TEST (collector/Stats() { collect("a"); collect("a"); collect("b")}).Hash() == {"a": 2, "b": 1}
	TEST Stats().collector(F(c) {c("a"); c("a"); c("b")}).Hash() == {"a": 2, "b": 1}
}

section "Thread" block _ {
	global Thread, Threads, ThreadFail, init, join, pmap, pfilter, ptimes, Str, (.)
	# TODO: consider *args for consistency with other parts of the language

	doc Execution thread. Currently a POSIX thread.
	type Thread

	doc Threads
	type Threads(ArrLike)

	# TODO: expose. Not called automatically because some names are
	#       already unique.
	_threads_names_lock = Lock()
	_threads_names_counters = Stats()
	F _make_thread_name(s:Str) {
		_threads_names_lock.acquire({
			_threads_names_counters.push(s)
			"${s}-${_threads_names_counters[s]}"
		})
	}

	doc Parent type of various thread exceptions
	type ThreadFail(Exception)

		doc Thrown when creating a thread (currently - c_pthread_create()) fails
		type ThreadCreateFail(ThreadFail)

		doc Thrown when joining a thread (currently - c_pthread_join()) fails
		type ThreadJoinFail(ThreadFail)

		doc Thrown where join()ing another thread that threw an exception
		doc %EX - Thread(F() 1/0).join()  # OtherThreadFail with .cause DivisionByZero
		type OtherThreadFail(ThreadFail)

	doc Creates and runs a thread. The code that the created thread runs is f, which is passed arg.
	F init(t:Thread, name:Str, f:Fun, arg) {
		t.id = name
		debug("process", "Creating thread ${t.id}")
		thread_attr = c_pthread_attr_t()
		c_pthread_attr_init(thread_attr)
		thread_setup_wrapper = F(t_arg) {
			# Not sure I can reference t here because the call frame
			# might have been removed already, so passing t via the argument
			Thread.local.thread = t_arg[0]
			debug("process", "Thread set up done, will run thread code")
			f(t_arg[1])
		}
		create_result = c_pthread_create(thread_attr, thread_setup_wrapper, [t, arg])
		code = create_result[0]
		if code {
			throw ThreadCreateFail("Failed to c_pthread_create").set('code', code)
		}
		t.thread = create_result[1]
	}

	doc Creates and runs a thread. The code that the created thread runs is f, which is passed arg.
	F init(t:Thread, f:Fun, arg) {
		super(t, 'unnamed', f, arg)
	}

	doc Creates and runs a thread. The code that the created thread runs is f without arguments.
	F init(t:Thread, f:Fun) {
		init(t, F thread_arg_discard_wrapper(discard) f(), null)
	}

	doc Creates and runs a thread. The code that the created thread runs is f without arguments.
	F init(t:Thread, name:Str, f:Fun) {
		init(t, name, F thread_arg_discard_wrapper(discard) f(), null)
	}

	# Not sure yet: %STATUS - deprecated
	doc Joins threads.
	doc threads - Arr of Thread.
	doc %RET - Arr, the results from threads, in order.
	F join(threads:Arr) {
		guard threads and threads.all(Thread)
		warn("Using deprecated join(threads:Arr)")
		threads.Threads().join()
	}

	doc Joins threads.
	doc %RET - Arr, the results from threads, in order.
	F join(threads:Threads) {
		results = threads.map(F(thread) {
			Result({thread.join()})
		})
		results.all(Success) returns results.map(get)
		throw ResultsException("Exception(s) in threads", Results(results))
	}

	doc Joins on thread. Waits for the thread to finish and returns the result from the thread.
	doc Currently, if a thread throwed an exception, it will be returned as the value.
	doc In future it might re-throw the exception, probably wrapped in ThreadExeption.
	doc %RET - Any
	F join(t:Thread) {
		debug("process", "Joining thread ${t}")
		join_result = c_pthread_join(t.thread)
		# join_result: [ join_status, [ result_is_exception:Bool, result ] ]
		if join_result[0] {
			throw ThreadJoinFail("Failed to c_pthread_join").set('code', join_result[0])
		}
		if join_result[1][0] {
			throw OtherThreadFail("Joined thread threw exception", join_result[1][1]).set('thread', t)
		}
		join_result[1][1]
	}

	doc Parallel map. Runs mapper in threads.
	doc Each thread processes one element from the array but this might change in future (preserving the total number of calls to mapper and the order of results).
	doc Number of threads is limited to the lower of the two: processors * 100 or 1000.
	doc %RET - Arr, result of applying mapper to elements of e, preserving the order.
	doc %EX - pages_texts = abs_pages_urls.pmap(F(url)  `lynx -dump $url`)
	F pmap(e:Eachable1, mapper:Fun) {
		threads = len(e)
		processors = sysconf(C_DEFS::_SC_NPROCESSORS_ONLN)
		lim = min(processors * 100, 1000)
		if threads > lim {
			warn("pmap(Eachable1, Fun) limited the threads to ${lim}. Use pmap(Eachable1, Int, Fun) to avoid this message.")
			threads = lim
		}
		pmap(e, threads, mapper)
	}

	TEST try pmap(3, F(x) 100+x) == [100, 101, 102]
	TEST try pmap(3, F(x) 100/x) catch(e:ResultsException) (e.results[0] is Failure)
    TEST try pmap(3, F(x) 100/x) catch(e:ResultsException) (e.results[2] is Success) and (e.results[2].get() == 50)

	doc Parallel map. Runs mapper in "threads" total threads.
	doc e - Eachable1 to be mapped
	doc threads - number of threads to use
	doc mapper - called with elements from e
	doc %RET - Arr, result of applying mapper to elements of e, preserving the order.
	doc %EX - pages_texts = abs_pages_urls.pmap(F(url)  `lynx -dump $url`)
	F pmap(e:Eachable1, threads:Int, mapper:Fun) {
		ex = Executor(threads)
		debug("conc", "pmap uses executor ${ex}")
		ret = [null] * len(e)
		e.each_idx_val(F(idx, val) {
			ex.push({
				ret[idx] = Result({ mapper(val) })::{
				    if A is Failure {
				        A.val.input = {
				            'idx': idx
				            'val': val
				        }
				    }
				}
			})
		})
		ex.wait()
		ret.any(Failure) throws ResultsException("pmap had failures", Results(ret))
		ret.map(get)
    }

    TEST e=100; e.pmap(2, X*2) == e.map(X*2)
    # TEST try { [1,0,2].pmap(10 / X) } catch(e:ResultsException) { (e.results =~ [Success, Failure, Success]) and e.results[1].has("input") } # To investigate: stack overflow when dealing with e.results

	doc Run cb in n parallel threads. Each thread runs one cb but this might change in future (preserving the total n calls to cb).
	F ptimes(n:Int, cb:Fun) {
		e = Executor(n)
		for(i;n) {
			e.push(cb)
		}
		e.wait()
	}

	TEST (1..3).Arr().pmap(X*10) == [10, 20]
	TEST 3.pmap(X*10) == [0, 10, 20]

	doc Parallel filter. Typcally should be used with "heavy" pattern such as SSH.
	doc %EX - Set(1..10).pfilter(X>3)  # <Set 4, 5, 6, 7, 8, 9>
	doc %RET - Of same type as e
	F pfilter(e:Eachable1, pattern) pfilter(e, len(e), pattern)

	TEST Set(1..10).pfilter(X>3) == Set(1..10).filter(X>3)

	doc Parallel filter. Typcally should be used with "heavy" pattern such as SSH.
	doc %EX - Set(1..10).pfilter(2, X>3)  # <Set 4, 5, 6, 7, 8, 9>
	doc %RET - Of same type as e
	F pfilter(e:Eachable1, threads:Int, pattern) {
		t = Type(e)
		ret = t()
		a = Arr(e)  # e might not be indexable
		results = pmap(a, threads, pattern)
		results.each_idx_val(F(i, val) {
			if val {
				ret.push(a[i])
			}
		})
		ret
	}

	TEST Set(1..10).pfilter(2, X>3) == Set(1..10).filter(X>3)

	F Str(t:c_pthread_t) "<c_pthread_t ${id(t)}>"
	F Str(t:Thread) "<Thread ${t.id}>"

	F .(t:Type, field:Str) {
		guard t === Thread and field == 'local'
		ll_thread_local()
	}

	# ASSUMPTION: Thread is loaded in main thread
	assert('thread' not in Thread.local)

	Thread.local.thread = Thread().set('id', 'main').set('thread', 'MAIN THREAD REFERENCE IS NOT IMPLEMENTED YET')

}

section "Logging and status reporting" {
	doc Represents an exception that should cause exit from the program
	doc exit_code - Contains the exit code to be used by ExitCode
	type ExitException(Exception)
		doc Represents a fatal error condition that causes the program to exit.
		doc %EX - throw ExitException("Input file not found")
		type FatalError(ExitException)
		type NormalExit(ExitException)

	doc Initializes ExitException.
	F init(ee:ExitException, message:Str, exit_code:Int=1) {
		super(ee, message)
		ee.exit_code = exit_code
	}

	F init(ee:ExitException, exit_code:Int=1) ee.exit_code = exit_code

	doc Convert ExitException to an exit code.
	doc %RET - ee.exit_code
	F ExitCode(ee:ExitException) ee.exit_code

	# TODO: timestamps

	# TODO: allow control by facility and severity
	#       and maybe source component or file.

	# Not sure such flexibility is needed (NGS_ERR_FD)
	stdlib_error_fd = ENV.NGS_ERR_FD.Int() tor 2

	block _ {
		global maybe_print_stacktrace

		# Set is not available at this point yet so using Hash as Set
		seen_backtraces = {}

		doc Do not use directly!
		doc %STATUS - internal
		F maybe_print_stacktrace(env_var:Str, pfx:Str) {
			ENV.get(env_var, '0').decode(Bool).not() returns
			bt = Exception("maybe_print_stacktrace").backtrace
			k = bt.frames.ip.map(Str).join(':')
			k in seen_backtraces returns
			seen_backtraces[k] = true
			msg = Lines(["(Showing backtrace because ${env_var} environment variable is set)"]) + Lines(bt)
			echo(stdlib_error_fd, (pfx +? ' ') + msg)
		}
	}

	doc Log to standard error. Later log output will be treated specially by the shell. It will have suitable representation in the UI. Use log() when it's semantically a log.
	F log(s:Str) {
		echo(stdlib_error_fd, "[LOG ${Time()}] $s")
	}

	section "Debug" {

		DEBUG = ENV.get('DEBUG', '').split(',').filter().Set()

		doc Same as debug('default', str_or_producer)
		F debug(str_or_producer) debug('default', str_or_producer)

		doc Debug to standard error.
		doc "DEBUG" environment variable must be non-empty string to activate. Otherwise nothing is outputted.
		doc TODO: Exclude thread ID if there is only one thread.
		doc TODO: Timestamps? Timestamps acquiring might not be safe after fork before exec.
		F debug(facility:Str, str_or_producer) {
			if facility in DEBUG or '*' in DEBUG {
				s = if str_or_producer is Fun {
					str_or_producer()
				} else {
					str_or_producer
				}
				echo(stdlib_error_fd, "[DEBUG $facility ${c_getpid()} ${Thread.local.thread.id tor c_pthread_self().id()}] $s")
			}
		}

	}

	doc Write error message to standard error.
	doc %EX - error("Failed to read configuration file. Will clean up and exit now.")
	doc %EX - # Approximate output on stderr:
	doc %EX - # [ERROR 2018-01-01 00:00:00 YOUR_TZ] Failed to read configuration file. Will clean up and exit now.
	F error(s:Str) {
		echo(stdlib_error_fd, "[ERROR ${Time()}] $s")
		maybe_print_stacktrace('NGS_ERROR_BACKTRACE', '[ERROR BACKTRACE]')
	}

	doc Write warning message to standard error. Prints backtrace if NGS_TRACE_WARNINGS environment variable is not an empty string.
	doc %EX - warn("Could not open input file $my_file , skipping it.")
	doc %EX - # Approximate output on stderr:
	doc %EX - # [WARNING 2018-01-01 00:00:00 YOUR_TZ] Could not open input file ./my_file , skipping it.
	F warn(s:Str) {
		echo(stdlib_error_fd, "[WARNING ${Time()}] $s")
		maybe_print_stacktrace('NGS_WARN_BACKTRACE', '[WARNING BACKTRACE]')
	}

	block _ {
		global status

		status_terminal = null

		doc %RET - s
		F status(s:Str) {
			if status_terminal is Null {
				status_terminal = Terminal(stdlib_error_fd, stdlib_error_fd)
			}
			status_terminal.status(s)
			s
		}
	}

	doc %STATUS - experimental
	F progress(cur:Num, total:Num) {
		status("Progress: ${cur}/${total}")
		null
	}
}

section "Exiting" {
	doc Write message in s to standard error and exit, printing backtrace
	doc status - converted to exit code using ExitCode()
	F die(s:Str, status=1) throw FatalError(s, status.ExitCode())

	doc Exit with given status
	doc status - converted to exit code using ExitCode()
	F exit(status=1) throw NormalExit(status.ExitCode())

	doc Write message in s to standard error and exit
	doc status - converted to exit code using ExitCode()
	F exit(s:Str, status=1) throw NormalExit(s, status.ExitCode())
}

section "Path" {
	# Maybe TODO: F ==(Path,Path) --> https://stackoverflow.com/questions/12502552/can-i-check-if-two-file-or-file-descriptor-numbers-refer-to-the-same-file

	type TmpFsObj

	doc Represents file system path such as a file, a block device, etc
	type Path
		doc Represents a socket file in a file system (S_IFSOCK)
		type SocketFile(Path)  # S_IFSOCK
		doc Represents a link in a file system (S_IFLNK)
		type Symlink(Path)     # S_IFLNK
		doc Represents a file in a file system (S_IFREG)
		type File(Path)        # S_IFREG
			doc Represents a temporary file. Automatically removed when the script exits.
			type TmpFile([File, TmpFsObj])
		doc Represents a block device in a file system (S_IFBLK)
		type BlockDevice(Path) # S_IFBLK
		doc Represents a directory in a file system (S_IFDIR)
		type Dir(Path)         # S_IFDIR
			doc Represents a temporary directory. Automatically removed when the script exits.
			type TmpDir([Dir, TmpFsObj])
		doc Represents a character device in a file system (S_IFCHR)
		type CharDevice(Path)  # S_IFCHR
		doc Represents a fifo file in a file system (S_IFIFO)
		type FifoFile(Path)    # S_IFIFO

	doc Human readable type name for the Path type and its subtypes. TODO: find better name.
	doc %STATUS - experimental
	F human_type_name(p) {
		guard p <= Path
		if m = p.meta().doc[''][0] ~ /Represents a (.+) in a file system/ {
			m[1]
		} else {
			"(failed to extract human readable type description of ${p})"
		}
	}

	doc Represents a failure in stat() system call.
	type StatFail(CError)

	# TODO: reconsider naming
	STDLIB_FILE_TYPE = {
		C_S_IFSOCK: SocketFile
		C_S_IFLNK:  Symlink
		C_S_IFREG:  File
		C_S_IFBLK:  BlockDevice
		C_S_IFDIR:  Dir
		C_S_IFCHR:  CharDevice
		C_S_IFIFO:  FifoFile
	}
	{ STDLIB_FILE_TYPE.meta({'doc': {'': 'Mapping between S_IFMT bits of st_mode returned by stat()/lstat() and NGS types. All types in this Namespace are subtypes of Path.'}}) }

	doc Issue stat() system call. Throws StatFail if the call fails.
	doc %RET - Stat
	doc %EX - stat("/tmp")  # <Stat st_dev=51714 st_ino=25 st_mode=17407 ...>
	F stat(pathname:Str) {
		c_stat(pathname)::{
			A is Null throws StatFail("Failed to c_stat()").set('pathname', pathname)
		}
	}

	doc Issue stat() system call. Throws StatFail if the call fails.
	doc %RET - Stat
	F stat(p:Path) super(p.path)

	doc Issue lstat() system call. Throws StatFail if the call fails.
	doc %RET - Stat
	doc %EX - stat("/usr/bin/cal").st_mode   # 33261
	doc %EX - lstat("/usr/bin/cal").st_mode  # 41471
	F lstat(pathname:Str) {
		c_lstat(pathname)::{
			A is Null throws StatFail("Failed to c_lstat()").set('pathname', pathname)
		}
	}

	doc Issue lstat() system call. Throws StatFail if the call fails.
	doc %RET - Stat
	F lstat(p:Path) super(p.path)

	# TODO: better name
	doc EXPERIMENTAL, do not use outside of stdlib!
	doc Instantiates Path sub-type, depending on what p is
	F specific(p:Path) {
		s = lstat(p)
		file_type = s.st_mode.band(C_S_IFMT)
		STDLIB_FILE_TYPE[file_type](p.path).set('stat', s)
	}

	doc Path constructor
	doc s - path
	doc subtype - Return Path sub-type, depending on lstat() call
	doc %RET - Path or sub-type of Path
	doc %EX - Path(".")  # <Path path=.>
	doc %EX - Path(".", true)  # <Dir path=.>
	doc %EX - ``find tmp/v8``.map(Path(X, true)).map(Type).name.Stats()  # <Stats: {Dir=287, File=9220}>
	F Path(s:Str, subtype=false) Path().set('path', s).only({subtype}, specific)

	doc Path constructor
	doc s - path
	F init(p:Path, s:Str) {
		p.path = s
	}

	doc Path constructor. Duplicates other Path.
	doc other - Path to duplicate
	F init(p:Path, other:Path) {
		p.path = other.path
	}

	doc Checks whether the path is accessible using access(2) and F_OK.
	doc %RET - Bool
	F Bool(p:Path) c_access(p.path, ACCESS::F_OK) == 0

	TEST Path('/').Bool()
	TEST Path('/no-such-file').Bool() == false
	TEST Path('/', true) is Dir

	doc Check whether file system object at given path
	doc is of the given type.
	doc %EX - if File("myfile.txt") ...
	doc %EX - if Dir("my_tmp_dir") ...
	doc %STATUS - experimental
	F Bool(p:Path) {
		# Only subclasses
		guard Type(p) != Path
		ok = super(p)
		not(ok) returns false
		s = lstat(p)
		file_type = s.st_mode.band(C_S_IFMT)
		p is STDLIB_FILE_TYPE[file_type]
	}

	# TODO: better exceptions (use correct type, not string, maybe use errno)
	# TODO: support platforms with non ":" path delimiter?
	doc Finds given binary and returns it's full path.
	doc Throws ProgramNotFound if the binary was not found.
	doc Search strategy: "/" in the name of the binary means that given executable_name is a path so it's returned as-is (wrapped in Path).
	doc If PATH environment variable exists, the given directories are searched.
	doc If PATH is not set built-in value for PATH is used to search: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
	doc %RET - Path
	doc %EX - find_in_path("ls")  # <Path path=/bin/ls>
	F find_in_path(executable_name:Str) {
		debug("process", "[find_in_path] got ${executable_name}")
		if "/" in executable_name {
			debug("process", "[find_in_path] leaving unprocessed ${executable_name}")
			return Path(executable_name)
		}
		# TODO: rethink default PATH
		path = ENV.get('PATH', '/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin').split(':')
		debug("process", '[find_in_path] will search')
		ret = path.map(F(dir) Path(dir / executable_name)).first(identity, null)
		debug("process", "[find_in_path] ${executable_name} found at ${ret}")
		ret is Null throws ProgramNotFound().set('path', path).set('name', executable_name)
		ret
	}

	doc String representation of a Path (or it's sub-type)
	doc %RET - Str
	doc %EX - find_in_path("ls").Str()  # The string: /bin/ls
	F Str(p:Path) p.path

	doc Concatenate two path parts using STDLIB_PATH_SEP (currently "/") but should be platform-specific later.
	doc %RET - Str
	doc %EX - mydir="tmp"
	doc %EX - mydir / "myfile"  # "tmp/myfile"
	F /(a:Str, b:Str) "$a$STDLIB_PATH_SEP$b"

	doc Concatenate two path parts using STDLIB_PATH_SEP (currently "/") but should be platform-specific later.
	doc %RET - Str
	doc %EX - mydir="tmp/"
	doc %EX - mydir / "myfile"  # "tmp/myfile"
	F /(a:Str, b:Str) {
		guard a.ends_with(STDLIB_PATH_SEP)
		"$a$b"
	}

	doc Concatenate two path parts using STDLIB_PATH_SEP (currently "/") but should be platform-specific later.
	doc %RET - Str
	doc %EX - mydir="./"
	doc %EX - mydir / "myfile"  # "myfile"
	F /(a:Str, b:Str) {
		guard (a == '.') or (a == './')
		b
	}

	doc Concatenate two Path-s using /(a:Str, b:Str)
	doc %RET - Path
	doc %EX - Path("tmp") / Path("v8")  # <Path path=tmp/v8>
	F /(a:Path, b:Path) Path(a.path / b.path)

	doc Concatenate two Path-s using /(a:Str, b:Str)
	doc %RET - Path
	doc %EX - Path("tmp") / "v8"  # <Path path=tmp/v8>
	F /(a:Path, b:Str) Path(a.path / b)

	type DirFail(CError)

	# TODO: recode after https://github.com/ngs-lang/ngs/issues/45 is solved
	doc List directory contents. Warning: "." and ".." are included.
	doc Throws DirFail when directory can not be listed.
	doc subtype - Select type of returned items: true for Path sub-type, false for Path type
	doc %RET - Arr of Path or it's sub-type
	doc %EX - dir("tmp/v8", true).filter(File)  # [ ..., <File path=tmp/v8/README.md fd=null>, <File path=tmp/v8/LICENSE.valgrind fd=null>, ... ]
	doc %EX - dir("tmp/v8", true).filter(Dir)   # [ ..., <Dir path=tmp/v8/tools>, <Dir path=tmp/v8/infra>, ... ]
	F dir(dirname:Str, subtype=false, **kwargs) collector dir(dirname, collect, subtype, **(kwargs.without('subtype')))

	# TODO: recurse ?
	# TODO: filter out "." and ".." ?
	doc List directory contents and call cb with Path() of each found item. "." and ".." are excluded.
	doc %RET - unspecified at this time, do not count on it
	doc %EX - 's=Stats(); dir("tmp/v8", {s.push(A.Type().name)}, true); s  # <Stats: {File=23, Dir=16}>'
	F dir(dirname:Str, cb:Fun, subtype=false, raw=false) {
		d = c_opendir(dirname)
		d is Null throws DirFail('Failed to list directory contents').set('dirname', dirname)
		SKIP_DIRS = ['.', '..']
		finally(
			body = {
				while entry = c_readdir(d) {
					entry.d_name in SKIP_DIRS continues
					if raw {
						cb(entry.d_name)
					} else {
						cb(Path(dirname / entry.d_name, subtype=subtype))
					}
				}
			}
			cleanup = {
				r = c_closedir(d)
				r != 0 throws DirFail('Failed to close directory after listing').set('dirname', dirname)
			}
		)
	}

	# XXX: might not be correct on all platforms
	TEST dir("/").path.any(AnyOf("/var", "/etc", "/bin"))
	TEST dir("/").all({A.Type().name == 'Path'})
	TEST dir("/", subtype=true).all({ (A is Path) and (A.Type().name != 'Path') })

	doc List directory contents and call cb with Path() of each found item. "." and ".." are excluded.
	doc Same as dir(dirname.path, *args)
	F dir(dirname:Path, *args, **kwargs) dir(dirname.path, *args, **kwargs)

	doc Same as a.path > b.path
	F '>'(a:Path, b:Path) a.path > b.path

	doc Work in progress, do not use!
	F glob(pattern:Str, start_dir='.') {
		throw NotImplemented("glob() is not implemented yet")
	}

	doc Convert to string, appropriate for using as argument to external process.
	doc %AUTO - $(mycommand $mypath) # mypath is Path
	doc %EX - conf_files = [Path("/usr/local/etc/some.conf"), Path("/etc/some.conf")].filter(Bool(X))
	doc %EX - $(ls -l $*conf_files)
	F Arg(p:Path) p.path

	doc Represents a failure in chdir() system call.
	type CdFail(CError)

	# TODO p must be either Path or a Dir, not any subtype of Path
	doc Change directory. Uses CHDIR(2).
	doc p - Directory to cd to.
	doc %RET - null
	F chdir(p:Path) chdir(p.path)

	doc Change directory. Uses CHDIR(2).
	doc s - Directory to cd to.
	doc %RET - null
	F chdir(s:Str) {
		t = c_chdir(s)
		t throws CdFail("Failed to chdir to '${s}'").set('dir', s)
		null
	}

	doc How a resource cleanup should be handled. See subtypes.
	type CleanupPolicy

		doc The resource should be kept
		type KeepCleanupPolicy(CleanupPolicy)

		doc The resource sohuld be removed
		type RemoveCleanupPolicy(CleanupPolicy)

		doc The resource should be kept if an error occurred, otherwise removed
		type KeepOnErrorCleanupPolicy(CleanupPolicy)

	doc Creates temporary file using `mktemp` and arranges deletion of the file upon exit from the NGS script.
	F init(t:TmpFsObj, cleanup_policy:CleanupPolicy=RemoveCleanupPolicy()) {
		assert(t, {'path': Str}, 'init(TmpFsObj, ...) expects path to be set and to be a string')
		assert(t.path, 'init(TmpFsObj, ...) expects path to be non-empty string')
		t.fd = null
		t.cleanup_policy = cleanup_policy
		debug("file", "Created ${t.Type().name} at ${t.path}")
		exit_hook["${t.Type().name}:${t}"] = F cleanup(e:Exit) {
			debug("file", "Will do cleanup for ${t.Type().name} at ${t}")
			# Exit is not a subtype of Exception. If anybody complains, this can be fixed and a "real" Exception can be sent.
			b = if e.exceptions then FullBox(e) else EmptyBox()
			del(t, t.cleanup_policy, b)
		}
	}

	F init(t:TmpFile, cleanup_policy:CleanupPolicy=RemoveCleanupPolicy()) {
		t.path = `line: mktemp`
		super(t, cleanup_policy)
	}

	F init(t:TmpDir, cleanup_policy:CleanupPolicy=RemoveCleanupPolicy()) {
		t.path = `line: mktemp -d`
		super(t, cleanup_policy)
	}

	F del(t:TmpFsObj, kcp:KeepCleanupPolicy, e:Box) {
		log("Keeping ${t.Type().name} at ${t}")
		t
	}

	F del(t:TmpFsObj, rcp:RemoveCleanupPolicy, e:Box) {
		try {
			$(rm -rf ${t})
			debug("file", "Removed ${t.Type().name} at ${t}")
		} catch(e) {
			warn("Failed to remove ${t.Type().name} at ${t}")
			print_exception(e, echo=warn)
		}
	}

	F del(t:TmpFsObj, koecp:KeepOnErrorCleanupPolicy, e:Box) {
		not(e) returns t.del(RemoveCleanupPolicy(), e)
		log("Keeping ${t.Type().name} at ${t} because exception occurred: ${e.get()}")
		t
	}

	doc Convert Path into JSON compatible data structure - string
	F JsonData(p:Path) p.path

	doc Convert CleanupPolicy to code
	F code(p:CleanupPolicy) "${p.Type().name}()"

	doc Decode Path and its subtypes
	doc %RET - instance of Path or a subtype.
	F decode(s:Str, p) {
		guard p <= Path
		p(s)
	}

	doc Checks that the given path exists. Throws AssertFail otherwise.
	doc %RET - p
	F assert(p:Path) {
		assert(p, "${p} must exist and be a ${p.Type().human_type_name()}")
	}

	doc Replace in a file. Wrapper around replace(Str, Any, Any).
	doc %RET - f
	F replace(f:File, src, dst) {
		debug("file", "Replacing in ${f}: '${src}' with '${dst}'")
		data = f.read().replace(src, dst)
		write(f, data)
		f
	}
}

# === Commands and processes (WIP) ===============

doc %EX - for p in %[ls base64 dd] assert(Program(p))
type Program
type ProcessesPipeline
type ProcessRedir

doc External Program
F init(p:Program, name:Str) init(args())

# TODO: Check whether the file is executable?
# TODO: For absolute path - check that the program exists?
doc Checks whether the given program is found in path.
doc %RET - Bool. The program is found in path or program name is absolute
F Bool(p:Program) Result({ find_in_path(p.name) }).Bool()

doc Checks that given program is found in path. Throws AssertFail otherwise.
doc %RET - p
F assert(p:Program) {
	r = Result({ find_in_path(p.name) })
	not(r) throws AssertFail("Program ${p.name} not found in path", r.val)
	p
}

TEST try assert(Program('no_such_prog')) catch(e) e is AssertFail
TEST assert(Program('ls')) == Program('ls')

doc EXPERIMENTAL!
F Arg(p:Program) p.name

F init(pp:ProcessesPipeline, cp:CommandsPipeline) pp.set(
	cp = cp
	processes = []
	pipe_in = null
	pipe_out = null
	stdout = null
	stderr = null
)

F init(pr:ProcessRedir, cr:CommandRedir) init(pr, cr.fd, cr.marker, cr.datum)

F init(pr:ProcessRedir, fd, marker, datum) init(args())

F init(pr:ProcessRedir, fd, marker, datum:File) init(pr, fd, marker, datum.path)

doc Duplicate a file descriptor. Uses DUP2(2). Handles EINTR.
F dup2(oldfd:Int, newfd:Int) {
	while true {
		status = c_dup2(oldfd, newfd)
		status != -1 returns newfd
		c_errno() != C_EINTR throws FileIOFail("Failed to c_dup2()").set('oldfd', oldfd).set('newfd', newfd)
	}
}

# TODO: Use some thread-local copy of the environment?
#       This would allow simple handling of modifications
#       for exec'ed processes.

doc Read all data from a file referenced by file descriptor without parsing it.
doc fd - File descriptor to read from
doc %RET - Str
doc %EX - read(0)  # All data from stdin
F read(fd:Int, count=null) {
	guard count is Int or count is Null
	count == 0 throws InvalidArgument("read(fd, count) - count can't be 0").set('fd', fd)
	ret = []
	to_read = count
	while true {
		debug("file", "[FD $fd] Will c_read()")
		result = c_read(fd, to_read or 4096)
		debug("file", "[FD $fd] Read ${result[0]} bytes")
		result[0] == 0 returns ret.join('')
		if result[0] > 0 {
			ret.push(result[1])
			if count is not Null {
				to_read -= len(result[1])
				to_read <= 0 returns ret.join('')
			}
		} else {
			e = c_errno()
			if e != C_EINTR {
				debug("file", "[FD $fd] read failed, errno $e")
				# TODO: Better exception
				throw ReadFail("Failed to read()").set('fd', fd).set('cause', CError("Failed to c_read()"))
			}
		}
	}
}

doc Read all data from a file referenced by file descriptor 0 (stdin) without parsing it. Same as read(0)
F read() read(0)

doc DEPRECATED! Do not use!
doc %STATUS - deprecated
F write(s:Str, fd:Int) {
	warn("Using deprecated write() arguments order")
	write(fd, s)
}

doc Write a string to stdout. Does not add a newline character, while echo() does.
doc %RET - 1, the standard output file descriptor
F write(s:Str) {
	write(1, s)
}

type WriteFail(CError)

doc Write data to a file referenced by file descriptor.
doc fd - File descriptor to write to
doc Throws WriteFail on failure.
doc s - String of bytes to write
doc %RET - fd
F write(fd:Int, s:Str) {
	out = s
	while true {
		bytes_written = fd.c_write(out)
		if bytes_written == -1 {
			if c_errno() == C_EINTR {
				# Untested
				continue
			}
			throw WriteFail("Failed to write to file descriptor ${fd}").set(fd=fd, s=s)
		}
		if bytes_written == len(out) {
			break
		}
		out = out[bytes_written..null]
	}
	fd
}

TEST write(1, "W1") == 1
TEST { write(10, "W10") }.assert(WriteFail)

doc Write a string followed by newline character to a file descriptor.
doc Throws WriteFail on failure.
doc %RET - null
doc %EX - echo(2, "blah")  # Output on stderr: blah"
F echo(fd:Int, s:Str) {
	write(fd, "${s}${STDLIB_EOL}")
	null
}

type TtyCheckFail(CError)

doc Check whether given fd represents a TTY. Uses ISATTY(3).
doc Throws TtyCheckFail.
doc %RET - Bool
F isatty(fd:Int) {
	ret = c_isatty(fd)
	errno = c_errno()

	ret == 1 returns true
	ret != 0 throws TtyCheckFail("c_isatty($fd) - unknown response code $ret").set('fd', fd).set('isatty_returned', ret)

	errno in [C_EINVAL, C_ENOTTY] returns false
	throw TtyCheckFail("c_isatty() - failed").set('fd', fd)
}

# --- Pipe ---

# http://www.microhowto.info/howto/capture_the_output_of_a_child_process_in_c.html

doc Wrapper around file descriptors returned by PIPE(2)
type Pipe
	type PipeToChildProcess(Pipe)
		type PipeFromParentToChildProcess(PipeToChildProcess)
		type ReadingPipeBetweenChildren(PipeToChildProcess)
	type PipeFromChildProcess(Pipe)
		type PipeFromChildToParentProcess(PipeFromChildProcess)
			type CollectingPipeFromChildToParentProcess(PipeFromChildProcess)
		type WritingPipeBetweenChildren(PipeFromChildProcess)
doc Represents failure of creating a Pipe when calling PIPE(2)
type PipeCreateFail(CError)

# TODO: better exceptions (use correct type, not string, maybe use errno)
doc Pipe constructor. Create UNIX pipe using PIPE(2). Throws PipeCreateFail if pipe can not be created.
doc %EX - p = Pipe()
F init(pipe:Pipe) {
	result = c_pipe()
	# result: [result_code, read_end, write_end]
	result[0] != 0 throws PipeCreateFail("Failed to create Pipe")
	pipe.read_fd = result[1]
	pipe.write_fd = result[2]
	debug("file", "${pipe.Type().name} created pipe with read_fd=${pipe.read_fd} and write_fd=${pipe.write_fd}")
}

doc Initializes Pipe, copying read_fd and write_fd from another Pipe.
doc %EX - my_pipe = ...
doc %EX - second_pipe = Pipe(my_pipe)
F init(pipe:Pipe, other:Pipe) {
	pipe.read_fd = other.read_fd
	pipe.write_fd = other.write_fd
}

doc Get child process end file descriptor of Pipe.
F child_fd(pipe:PipeToChildProcess) pipe.read_fd

doc Get child process end file descriptor of Pipe.
F child_fd(pipe:PipeFromChildProcess) pipe.write_fd

doc Get parent process end file descriptor of Pipe.
F parent_fd(pipe:PipeToChildProcess) pipe.write_fd

doc Get parent process end file descriptor of Pipe.
F parent_fd(pipe:PipeFromChildProcess) pipe.read_fd

F Str(p:Pipe) "<${p.Type().name} read_fd=${p.read_fd} write_fd=${p.write_fd}>"

# TODO: exception on fail, maybe close() wrapper for c_close()

doc Close writing end of the Pipe
F close_writing_end(p:Pipe) p.write_fd.c_close()

doc Close reading end of the Pipe
F close_reading_end(p:Pipe) p.read_fd.c_close()

doc DEPRECATED! Do not use!
doc %STATUS - deprecated
F write(s:Str, p:Pipe) {
	warn("Using deprecated write() arguments order")
	write(p, s)
}

doc Write to Pipe. TODO: document if it throws.
doc %RET - unspecified at this time, do not count on it
F write(p:Pipe, s:Str) p.write_fd.c_write(s)

doc Read from Pipe without parsing. TODO: document if it throws.
doc %RET - read data
doc %EX - data = read(myipe)
F read(p:Pipe, count=null) {
	guard count is Int or count is Null
	p.read_fd.read(count)
}

doc DUP2(2) writing file descriptor
F dup2_writing_end(p:Pipe, newfd:Int) dup2(p.write_fd, newfd)

doc DUP2(2) reading file descriptor
F dup2_reading_end(p:Pipe, newfd:Int) dup2(p.read_fd, newfd)

# --- File ---

type FileIOFail(CError)

doc Create File object from the given path. The file is not open.
doc %EX - f = File('/tmp/myfile')
F init(f:File, path:Str) {
	f.path = path
	f.fd = null
}

doc Create File object from the given file descriptor.
F init(f:File, fd:Int) {
	f.path = null
	f.fd = fd
}

F init(f:File, path:Path) super(f, path.path)

doc Open a file and set the "fd" field to the file descriptor. Uses OPEN(2).
doc Throws InvalidArgument if file is already open.
doc Throws FileIOFail if an underlying error occurs.
doc flags - Currently "r", "w" or "a" for read/write/append
doc %RET - f
F open(f:File, flags:Str) {
	f.fd is not Null throws InvalidArgument("open(f:File, flags:Str): file is already open").set('file', f)
	fd = c_open(f.path, flags)
	fd <= 0 throws FileIOFail("Failed to open the file ${f.path}").set('file', f)
	f.fd = fd
	f
}

# XXX: might not be correct on all platforms
TEST open(File("/etc/passwd"), "r").fd > 0

type BasenameArgumentFail(InvalidArgument)

doc Get basename of the file.
F basename(p:Path) p.path.basename()

doc Get basename of the file.
F basename(s:Str) {
	s.split('/')[-1] or throw BasenameArgumentFail("'${s}' is not a valid input to basename()").set('s', s)
}

TEST basename("/abc") == "abc"
TEST basename("abc") == "abc"
TEST basename("abc/def") == "def"
TEST { basename("abc/def/") }.assert(BasenameArgumentFail)


# TODO: something more efficient than reading all of it. Some kind of streaming.
doc Iterate over lines of the file
doc f - Closed File
doc cb - function to call with successive lines from the file
F lines(f:File, cb:Fun) {
	f.open('r')
	finally(
		body = {
			f.fd.read().lines(cb)
		}
		cleanup = {
			f.close()
		}
	)
}

# XXX: might not be correct on all platforms
TEST ok = false; File("/etc/passwd").lines({if ":" in A ok = true}); ok

doc Get all lines of the file
doc %RET - Arr of Str
F lines(f:File) collector f.lines(collect)

doc Write given lines to the file. Overwrites the file.
doc %RET - Arr of Str
F lines(f:File, lines_:Arr) {
	finally(
		body = {
			f.open('w')
			(lines_ + STDLIB_EOL).each(write(f.fd, X))
			f
		}
		cleanup = {
			f.close()
		}
	)
}

# Note: EINTR should not be handled
doc Close a file and sets the "fd" field to null. Uses CLOSE(2).
doc Throws InvalidArgument if file is not open.
doc Throws FileIOFail if an underlying error occurs.
doc %RET - f
F close(f:File) {
	f.fd is Null throws InvalidArgument("File is not open. close() expects an open file").set('file', f)
	ret = c_close(f.fd)
	ret < 0 throws FileIOFail("Failed to close the file $f").set('file', f)
	f.fd = null
	f
}

# Note: EINTR should not be handled
doc Close a file. Uses CLOSE(2).
doc Throws FileIOFail if an underlying error occurs.
doc %RET - fd
F close(fd:Int) {
	ret = c_close(fd)
	ret < 0 throws FileIOFail("Failed to close file descriptor $fd").set('fd', fd)
	fd
}

doc read() and decode() the given file
doc %EX - fetch("1.json")  # Data structure, the parsed JSON
F fetch(filename:Str, decode_hints:Hash={}) {
	data = read(filename)
	decode(data, {'filename': filename} + decode_hints)
}

# TODO: think about protocols support, programs support (wget, curl, ...) and refactor
doc Fetch HTTP(S) file and decode() it
doc %EX - fetch('https://api.myip.com')  # Data structure, the parsed JSON
F fetch(url:Str, decode_hints:Hash={}) {
	guard url ~ /^(https?):\/\//
	decode(`curl -s $url`, {'url': url})
}

doc Read standard input and decode() it, passing "source" equals "stdin" hint.
doc %EX - fetch()  # Data structure, parsed stdin
F fetch(decode_hints:Hash={}) read(0).decode({'source': 'stdin'} + decode_hints)

doc read() and decode() the given file
doc %EX - fetch(File("1.json"))  # Data structure, the parsed JSON
F fetch(p:Path, decode_hints:Hash={}) p.path.fetch(decode_hints)

doc encode() and write() the data to the file
doc %RET - null (but subject to change)
F store(filename:Str, data, encode_hints:Hash={}) {
	write(filename, encode(data, {'filename': filename} + encode_hints))
	null
}

doc encode() and write() the data to the file
F store(file:File, data, encode_hints:Hash={}) store(file.path, data, encode_hints)

# --- CommandRedir ---

doc Initialize CommandRedir object. Used internally for commands syntax.
doc %AUTO - $(my_prog >my_file)
F init(r:CommandRedir, fd, marker, datum) {
	guard marker =~ AnyOf(Str, Null)
	guard datum =~ AnyOf(Str, Pipe, Int, File, true)
	init(args())
}

doc Throw exception whend redirecting to/from null
F init(r:CommandRedir, fd, marker, datum:Null) {
	if marker == '<' {
			throw InvalidArgument('Command redirection from <${null} is not supported.')
	}
	throw InvalidArgument('Command redirection to >${null} is not supported. Use >${false} to disable capturing.')
}

doc Convert CommandRedir to human-readable string.
doc %RET - Str
F Str(r:CommandRedir) "<${r.Type().name} ${r.fd} ${r.marker} ${r.datum}>"

# --- Process ---

doc Running or finished process
type Process

doc Occurs when executable was not found in path or when executable was absolute or relative and was not found.
type ProgramNotFound(Exception)

block _ {

	global finished_ok

	_finished_ok_exit_codes = {}

	doc Decide whether process finished normally: exit code must be 0.
	doc Note that processes terminated by a signal will have .exit_code null.
	doc p - any process
	doc %RET - bool
	F finished_ok(p:Process) {
		debug("finished_ok", "finished_ok() - default method")
		p.exit_code == 0
	}

	doc %STATUS - internal
	doc Decide whether a process finished normally.
	doc %EX - $(ok:0..10 ls no-such-file)
	F finished_ok(p:Process, field_name:Str, ok:NumRange) p.(field_name) in ok

	doc %STATUS - internal
	doc Decide whether a process finished normally.
	doc %EX - $(ok:[0,1,2] ls no-such-file)
	F finished_ok(p:Process, field_name:Str, ok:Arr) {
		ok =~ [NumRange] throws InvalidArgument("finished_ok() got [some..range] but should be some..range")
		p.(field_name) in ok
	}

	doc %STATUS - internal
	doc Decide whether a process finished normally.
	doc %EX - $(ok:1 ls no-such-file)  # No exception
	doc %EX - $(ok:10 ls no-such-file) # ProcessFail exception
	F finished_ok(p:Process, field_name:Str, ok:Int) p.(field_name) == ok

	doc %STATUS - internal
	doc Decide whether a process finished normally.
	doc %EX - # 'ok' option is set to true when the value is missing after ':'
	doc %EX - $(ok: ls no-such-file)
	F finished_ok(p:Process, field_name:Str, ok:Bool) ok

	doc %STATUS - internal
	doc Decide whether a process with 'ok' option finished normally.
	doc %EX - $(ok:0..10 ls no-such-file)
	doc %EX - $(ok:[0,1,2] ls no-such-file)
	doc %EX - $(ok:1 ls no-such-file)  # No exception
	doc %EX - $(ok:10 ls no-such-file) # ProcessFail exception
	doc %EX - $(ok: ls no-such-file)
	F finished_ok(p:Process) {
		ok = p.command.options.get('ok')
		guard ok is not Null
		debug("finished_ok", "finished_ok(Process) method, 'ok:' option")
		finished_ok(p, 'exit_code', ok)
	}

	TEST { $(ok:2 cat NO_SUCH_FILE 2>/dev/null) }.assert(ProcessFail)
	TEST $(ok:1 cat NO_SUCH_FILE 2>/dev/null); true
	TEST $(ok:[1,10] cat NO_SUCH_FILE 2>/dev/null); true
	TEST $(ok:1..2 cat NO_SUCH_FILE 2>/dev/null); true

	doc Decide whether a process with 'ok_sig' option finished normally.
	doc %EX - p=$(sleep 10 &); p.kill(); p.wait()  # ProcessFail exception in wait()
	doc %EX - p=$(ok_sig:SIGNALS.TERM sleep 10 &); p.kill(); p.wait()  # No exception
	F finished_ok(p:Process) {
		ok = p.command.options.get('ok_sig')
		guard ok is not Null
		debug("finished_ok", "finished_ok(Process) method, 'ok_sig:' option")
		finished_ok(p, 'exit_signal', ok)
	}

	TEST p=$(sleep 10 &); p.kill(); try p.wait() catch(pf:ProcessFail) true
	TEST p=$(ok_sig:SIGNALS.TERM sleep 10 &); p.kill(); p.wait(); true

	doc Decide whether a process finished normally for known programs
	doc that return also non-zero exit codes which do not signal a failure.
	doc %EX - $(test -f my_file_that_might_be_present)
	doc %EX - $(fuser my_file)  # On Linux, exit code 1 means file is not used
	F finished_ok(p:Process) {
		ok = _finished_ok_exit_codes.get(p.executable.path.basename())
		guard ok is not Null
		debug("finished_ok", "finished_ok(Process) method, _finished_ok checker method")
		finished_ok(p, 'exit_code', ok)
	}

	doc %STATUS - experimental
	F finished_ok(program_name:Str, ok) {
		_finished_ok_exit_codes[program_name] = ok
	}

	_known_programs = %{
		%[false] 1
		%[expr grep pgrep ping test which] %[0 1]
	}
	if OS.linux {
		_known_programs[%[fuser]] = %[0 1]
	}
	_known_programs.each(F(progs, ok) {
		debug("finished_ok", "known programs: ${progs} -> ${ok}")
		progs.each(finished_ok(X, ok))
	})
}

doc Process constructor. Initializes fields.
F init(p:Process, c:Command) p.set(
	command = c
	executable = null
	pid = null
	exit_code = null
	exit_signal = null
	outputs = {1:null, 2:null}
	stdout = null
	stderr = null
	reading_threads = Threads()
	writing_threads = Threads()
)

# Maybe it should be pp.processes.all(Bool)? And implement Bool(p:Process)
doc Wait for all process to finish and see whether all exit codes are 0
doc %RET - Bool
doc %EX - if $(test -f myfile) ... # if runs Bool() on any non-Bool condition expression
F Bool(pp:ProcessesPipeline) pp.wait().processes.all({A.exit_code == 0})

F finished(p:Process) [p.exit_code, p.exit_signal].any(Int)

doc Wait for a process. Waits for reading and writing threads to finish.
doc Waits for the process to finish. Checks whether to throw ProcessFail using finished_ok().
doc %RET - p
F wait(p:Process) {

	finished(p) returns p

	# TODO: reading/writing threads failure - throw at the end (allowing resources cleanup in this function)
	p.pid is Null throws InvalidArgument("Can not wait() on Process without PID")

	F join_threads(which:Str) {
		threads = p.(which)
		debug("process", {"[wait] joining ${which}: ${threads}"})
		results = threads.join()
		debug("process", {"[wait] joined threads"})
		p.(which) = []
		first_failure = results.first(Failure, null)
		first_failure throws ProcessFail('Error in reading/writing thread').set(process=p, cause=first_failure)
	}

	%[reading_threads writing_threads].each(join_threads)


	debug("process", "[wait] will waitpid(${p.pid})")
	w = c_waitpid(p.pid)
	debug("process", "[wait] waitpid(${p.pid}) -> ${w}")
	p.exit_code = C_WEXITSTATUS(w[1])
	p.exit_signal = C_WTERMSIG(w[1])
	finished_ok(p) returns p
	message = collector/Lines() {
		argv0 = ("'" + try p.command.argv[0] + "'") tor '(with unknown name)'
		collect("Executing external process ${argv0} failed")
		collect("Executable was found at ${p.executable}")
		collect("Command: ${p.command.argv.map(escape_bash).join(' ') tor '(unavailable)'}")
		if p.exit_code is not Null {
			collect("Command exited with code: ${p.exit_code}")
		}
		if p.exit_signal is not Null {
			collect("Command exited with signal: ${p.exit_signal}")
		}
	}
	throw ProcessFail(p).set('message', message)
}

doc Wait for all processes to finish.
doc %RET - pp
F wait(pp:ProcessesPipeline) {
	pp.processes.each(wait)
	last_process = pp.processes[-1]
	pp.stdout = last_process.stdout
	pp.stderr = last_process.stderr
	pp
}

doc Convert Process to exit code. Waits for the process to finish and uses its exit code.
doc To be used for NGS process exit such as in "ngs -e 'my_code(); $(ls)'".
F ExitCode(p:Process) {
	ec = p.wait().exit_code
	ec is Int returns ec

	# http://tldp.org/LDP/abs/html/exitcodes.html
	es = p.exit_signal
	# echo("ES $es")
	es is Int returns 128 + es

	# Don't know what to do
	# error("Failed to convert process to exit code")
	240
}

doc Convert ProcessesPipeline to exit code. Waits for the processes to finish.
doc Returns first non-zero exit code. Returns zero if all exit codes are zero.
F ExitCode(pp:ProcessesPipeline) pp.wait().processes.map(ExitCode).first(X != 0, 0)

doc Wait for the process to finish and return its standard output.
doc %RET - Str
F Str(p:Process) p.wait().stdout or ''

doc Wait for the processes to finish and return standard output of the last process in pipeline.
doc %RET - Str
F Str(pp:ProcessesPipeline) {
	pp.wait()
	assert(pp.processes)
	Str(pp.processes[-1])
}

# TODO: type Arg(Str) -- currently, inheriting built in types is not supported

doc Convert to string, appropriate for using as argument to external process.
doc %AUTO - $(mycommand $num) # num is Real
F Arg(x:Real) Str(x)

doc Convert to string, appropriate for using as argument to external process.
doc %AUTO - $(mycommand $num) # num is Int
F Arg(x:Int) Str(x)

doc Convert to string, appropriate for using as argument to external process. No-op for Str: return the same string.
doc %AUTO - $(mycommand $str) # str is Str
F Arg(x:Str) x

# TODO: Consider storing original h in one of the meta() of the result
doc Convert a Hash, describing command line arguments, to array of strings, appropriate for using as argument to external process.
doc Key-value pairs with values of type NoData (null, EmptyBox) are discarded.
doc Key-value pairs with empty array values are discarded.
doc Values of type Box are unboxed.
doc For keys which are arrays of two elements, Bool value selects first (for true) or second (for false) element.
doc For keys which are arrays of a single element, Bool value selects whether the key is present or absent in the output.
doc For keys which are Repeat, Eachable1 value causes the switch to be repeated for each element, building switch name and switch value pairs.
doc %EX - # Typical usage:
doc %EX - argv = Argv({'name1': value1, 'name2': value2, ...})
doc %EX - $(my_command $*argv)
doc %EX - # Handling of key-value pairs
doc %EX - Argv({"--a": 1, "-b": null})                         # ['--a', 1]
doc %EX - Argv({["-y1", "-n1"]: true, ["-y2", "-n2"]: false})  # ['-y1', '-n2']
doc %EX - Argv({["-y3"]: true, ["-y4"]: false})                # ["-y3"]
doc %EX - Argv({Repeat("--repeat"): ["a", "b"]})               # ["--repeat", "a", "--repeat", "b"]
doc %EX - Argv({"-a1": [], "-a2": [1,2,3]})                    # ["-a2", 1, 2, 3]
F Argv(h:Hash) {
	collector
		h.rejectv(NoData).mapv(only(Box, get)).each(F(k, v) {
			if k is Arr {
				ematch v {
					Bool {
						# ['--might-be-flag']: my_bool_expr
						# ['--flag-if-yes', '--flag-if-no']: my_bool_expr
						k.len() not in 1...2 throws InvalidArgument("Argv key which is array must be of length 1 or 2").set('value', k)
						# v == true -> use index 0, v == false -> use index 1
						k.Box(Int(not(v))).map(collect)
						return
					}
					Eachable1 {
						warn("Argv: use {Repeat('--repeat'): my_eachable1} instead of deprecated ['--repeat']: my_eachable1")
						k = Repeat(k.the_one())
					}
				}
			}

			if k is Repeat {
				assert(k, {'pattern': Str, 'count': NumRange }, 'Argv: Repeat() must repeat a string and count must be NumRange')
				assert(v.len(), k.count, "Switch ${k.pattern} has ${v.len()} values, out of specified range ${k.count}")
				v.each(F(elt) {
					collect(k.pattern)
					collect(elt)
				})
				return
			}

			# If you have nothing to give to the switch, skip the switch
			v == [] returns

			collect(k)
			v.ensure(Arr).each(collect)
		})
}

TEST Argv({"--a": 1, "-b": null, ["-y1", "-n1"]: true, ["-y2", "-n2"]: false, ["-y3"]: true, ["-y4"]: false}) == ["--a", 1, "-y1", "-n2", "-y3"]
TEST Argv({"-a1": [], "-a2": [1,2,3]}) == ["-a2", 1, 2, 3]
TEST Argv({Repeat("--repeat"): ["a", "b"]}) == ["--repeat", "a", "--repeat", "b"]

doc Deprecated. Do not use!
doc %STATUS - deprecated
F Argv(a:Arr) {
	warn("Using deprecated Argv(Arr)")
	a.reject(NoData).map(only(Box, get)).map(X.ensure(Arr)).flatten()
}


section "exec()" {
	doc Call EXECVE(2)
	F exec(argv:Arr, env:Hash=ENV) {
		p = find_in_path(argv[0])
		result = c_execve(p.path, argv, env.Strs())
		throw CError("Failed to execve()").set(argv=argv)
	}

	doc Call EXECVE(2)
	doc argv - argv, without the program
	F exec(prog:Str, argv:Arr=[], env:Hash=ENV) exec([prog] + argv, env)

	doc Call EXECVE(2)
	F exec(prog:Str, env:Hash=ENV) exec([prog], env)
}

# --- $() ---

F fork() {
	global exit_hook
	child_exit_hook = exit_hook.filter({ B.meta() =~ {'keep_after_fork': true} })
	pid = c_fork()
	pid == -1 throws ProcessFail("Could not spawn a process").set('cause', CError("Failed to fork()"))
	debug("process", "PID after fork: $pid")
	if pid == 0 section "child" {
		# #618 - filter() in child was causing out-of-memory, hence, filter() is now before c_fork()
		exit_hook = child_exit_hook
	}
	pid
}

doc Run a process
F '$()'(p:Process) {

	# There are situations (not sure how to reproduce) when
	# there is a problem to require() this later so loading now:
	ProcessFail

	F safe_escape_bash(s) escape_bash(s) tor "failed-to-bash-escape"

	argv = p.command.argv.map(Arg)

	debug("process", "Parsed command: ${argv}")

	if log_opt = p.command.options.get('log') {
		assert(log_opt, AnyOf(true, Str), 'log: option must be either true or a string')
		F redir_str(r:CommandRedir) {
			(r.fd or '').Str() + r.marker + safe_escape_bash(r.datum)
		}
		o = ' (' +? p.command.options.without('log').without('env').map("$X:$Y").join(' ') +? ')'
		pfx = ematch log_opt {
			Str log_opt +? '. '
			true ''
		}
		log("${pfx}Running command${o}: ${argv.map(safe_escape_bash).join(' ')}${' ' +? p.command.redirects.map(redir_str).join(' ')}")
	}

	try {
		p.executable = find_in_path(argv[0])
	} catch(nf:ProgramNotFound) {
		throw ProcessFail(p).set('cause', nf).set('message', 'Executable not found')
	}

	pid = fork()

	pipes = p.redirects.filter({'datum': Pipe})
	debug("process2", "PIPES FROM REDIRECTS $pipes REDIRECTS ${p.redirects} COMMAND ${p.Hash()}")
	child_fds = pipes.datum.map(child_fd)

	if pid == 0 section "child" {
		# TODO: See https://stackoverflow.com/questions/13101690/c-get-all-open-file-descriptors
		child_fds_to_keep_open = child_fds + p.redirects.datum.filter(Int)
		debug("process2", "CHILD CLOSING FDS 3 TO 100 EXCEPT FOR ${child_fds_to_keep_open}")
		for(i=3;i<100;i+=1) {
			if i not in child_fds_to_keep_open {
				# XXX child to parent also closed here
				# close() throws exception on invalid descriptors, hence c_close()
				i.c_close()
			}
		}

		marker_to_open_flags = {'<': 'r', '>': 'w', '>>': 'a'}
		marker_to_default_fd = {'<': 0, '>': 1, '>>': 1}

		p.redirects.each(F(r:ProcessRedir) {
			target_fd = if r.fd is Int then r.fd else marker_to_default_fd[r.marker]
			ematch r.datum {
				Str {
					debug("process2", "CHILD FILE REDIRECT ${target_fd} -> ${r.datum}")
					f = File(r.datum).open(marker_to_open_flags[r.marker])
					dup2(f.fd, target_fd)
				}
				Pipe {
					debug("process2", "CHILD REDIRECT PIPE ${r.fd} -> ${child_fd(r.datum)}")
					dup2(child_fd(r.datum), target_fd)
					close(child_fd(r.datum)) # Is this needed?
				}
				Int {
					debug("process2", "CHILD DESCRIPTOR REDIRECT ${r.fd} -> ${r.datum}")
					dup2(r.datum, target_fd)
				}
				false {
					debug("process2", "CHILD DOES *NOT* REDIRECT ${r.fd} -> ${false}")
				}
			}
		})

		p.command.options.Box('cd').each(chdir)

		debug("process", "will execve()")
		result = c_execve(p.executable.path, argv, p.command.options.get('env', ENV).assert(Hash, 'Environment variables must be a Hash').Strs())
		# TODO: propagate this error to parent, don't know how yet
		throw CError("Process ${c_getpid()} (fork child) failed to execve()")
	}

	if pid > 0 section "parent" {
		p.pid = pid
		child_fds.each(close)
		debug("process", "Reading all output of the child process")
		# XXX: maybe make it chunk based with c_poll() and single thread
		# TODO: some error handling inside these threads and after joining them
		p.reading_threads = p.redirects.filter({'datum': CollectingPipeFromChildToParentProcess}).map(F(r:ProcessRedir) {
			Thread("process-${p.pid}-output-fd-${r.fd}-reader", {
				Result({
					debug("process2", "READING ${r.datum}")
					p.outputs[r.fd] = r.datum.read()
					dst_fields = %{
						1 stdout
						2 stderr
					}
					if r.fd in dst_fields {
						p.(dst_fields[r.fd]) = p.outputs[r.fd]

					}
					debug("process2", "READ <<${p.outputs[r.fd].limit(100, '...').SafeStr()}>>")
					debug("process2", "DATUM *** ${r.datum}")
					r.datum.close_reading_end()
					debug("process2", "CLOSED READING END OF PIPE, REDIRECT ${r}")
					debug("process", "Read all output of the child process for descriptor ${r.fd}, closing reading/parent end")
					null
				})
			})
		}).Threads()
	}

	debug("process2", "\$() returns process ${p.Hash()}")
	p
}

# TODO: Free (close) fds on failure
# TODO: better exceptions (use correct type, not string)
# TODO: c_waitpid() - handle signals
# TODO: split to methods for easy behaviour modification
# TODO: capture stderr
# TODO: provide additional communication channel on additional fd?
# TODO: handle built-in commands: do not execve,
# INFO: bash - redir.c
doc Run external processes described by the commands pipeline.
doc Waits for the commands to finish unless "&" is specified.
doc c - CommandsPipeline object, typically constructed by NGS when parsing the contents of $(...) .
doc %EX - if $(test -f /myfile) { ... }
doc %EX - # or
doc %EX - p = $(node main.js serve &)
doc %EX - YOUR_TESTS_OF_NODE_SERVER_HERE
doc %EX - p.kill()
doc %RET - Process
doc %AUTO - $(my_prog) , $(some | programs)
F '$()'(cp:CommandsPipeline) {

	if cp.commands.len() == 1 {

		# Special case: $($cmd)
		c = cp.commands[0]
		if (c.argv.len() == 1) and (c.argv[0] is CommandsPipeline) {
			cp = c.argv[0]
		}

		# Deprecate "top_level: cmd", should be "top_level::"
		if cp.commands[0].options.get('top_level') {
			warn("Use 'top_level::' instead of 'top_level:' in ${cp.commands[0].Str()}")
			cp.options.top_level = cp.commands[0].options.top_level
		}

	}

	section "validate redirects" {
		for cmd in cp.commands {
			for r in cmd.redirects {
				if r.datum == true {
					r.marker != '>' throws InvalidArgument("Redirection to 'true' for collecting output can only be done with '>' redirection syntax, not '${r.marker}'").set('cp', cp)
				}
			}
		}
	}

	pp = ProcessesPipeline(cp)
	pp.processes = cp.commands.map(F(cmd) {
		p = Process(cmd)
		p.redirects = cmd.redirects.map(ProcessRedir).each(F(r) {
			if r.datum == true {
				r.datum = CollectingPipeFromChildToParentProcess()
			}
		})
		p
	})

	# Commands:    C0    C1    C2
	# Pipes:    P0    P1    P2    P3
	# $(| ...) - uses P0
	# $(... |) - uses P3
	debug("process2", "cp.pipes.len()=${cp.pipes.len()}")
	for(i;cp.pipes.len()) {
		cp.pipes[i] is Null continues
		debug("process2", "cp.pipes[$i]")
		econd {
			i == 0 {
				debug("process2", "PIPE IN")
				pp.pipe_in = PipeToChildProcess()
				pp.processes[i].redirects.unshift(ProcessRedir(0, null, pp.pipe_in))
			}
			i == pp.processes.len() {
				debug("process2", "PIPE OUT")
				pp.pipe_out = PipeFromChildToParentProcess()
				pp.processes[i-1].redirects.unshift(ProcessRedir(1, null, pp.pipe_out))
			}
			true {
				p = Pipe()
				pp.processes[i-1].redirects.unshift(ProcessRedir(1, null, WritingPipeBetweenChildren(p)))
				pp.processes[i].redirects.unshift(ProcessRedir(0, null, ReadingPipeBetweenChildren(p)))
			}
		}
	}

	if not(cp.options.get('top_level')) and pp.pipe_out is Null {
		do_collect_output = pp.processes[-1].redirects.none(F(r) {
			# >${false} OR 1>${false}
			# 1>? OR 1<?
			(r.datum != true and r.marker == '>' and r.fd in [null, 1]) or
			r.fd == 1
		})
		if do_collect_output {
			pp.processes[-1].redirects.unshift(ProcessRedir(1, null, CollectingPipeFromChildToParentProcess()))
		}
	}

	pp.processes = pp.processes.map(('$()'))

	if not(cp.options.get('&')) and pp.pipe_in is Null and pp.pipe_out is Null {
		pp.wait()
	}

	pp
}

TEST $(true).Bool()
TEST $(false).Bool() == false
TEST "$(/bin/echo -n abc)" == 'abc'
TEST $(cd:"/" pwd).lines()[0] == '/'
TEST t=TmpFile(); $(echo -n abc >$t); t.read() == "abc"

doc Write to first process of ProcessesPipeline
doc %EX - p = (|cat -n | tac >/tmp/1)
doc %EX - p.write("one\n")
doc %EX - p.write("two\n")
doc %EX - p.close()
F write(pp:ProcessesPipeline, s:Str) {
	pp.pipe_in is Null throws InvalidArgument("ProcessesPipeline has no input pipe").set('pp', pp)
	pp.pipe_in.write(s)
	pp
}

doc Write s and newline character(s) to pp
F echo(pp:ProcessesPipeline, s:Str) {
	pp.write(s)
	pp.write(STDLIB_EOL)
	pp
}

doc Read from last process of ProcessesPipeline
doc %EX - p = $(seq 3 | tac |);
doc %EX - data = read(p);
doc %EX - p.close()
F read(pp:ProcessesPipeline, count=null) {
	guard count is Int or count is Null
	pp.pipe_out is Null throws InvalidArgument("ProcessesPipeline has no output pipe").set('pp', pp)
	pp.pipe_out.read(count)
}

# TODO: example
doc Close reading and writing pipes of ProcessesPipeline, if they exist
F close(pp:ProcessesPipeline) {
	pp.pipe_in.Box().map({A.parent_fd().close()})
	pp.pipe_out.Box().map({A.parent_fd().close()})
	pp
}

doc Get command standard output. Similar to bash. Does not strip trailing new line character(s)
doc `line:true my_command` will return the first line, stripping trailing new line character(s)
doc %AUTO - `my_command` , `my_command | my_other_command`
F ``(cp:CommandsPipeline) {
	processes = ('$()')(cp).processes
	assert(processes)
	ret = processes[-1].Str()
	if cp.commands[-1].options.get('line') == true {
		ret = ret.lines()[0]
	}
	if cp.commands[0..-1].options.get('line') {
		warn("Using 'line:' option on non-final command had no effect when running ${cp.commands.argv}")
	}
	ret
}

doc Get command standard output and decode() it.
doc %RET - structured data when the output can be parsed.
doc %EX - ``aws ec2 describe-instances`` is Arr  # true
doc %EX - ``aws ec2 describe-instances``.InstanceId.map(X[0..3]).join(",")  # i-3, i-9, i-8, i-a, i-7, ...
doc %AUTO - ``my_command`` , ``my_command | my_other_command``
F ````(cp:CommandsPipeline) {
	processes = ('$()')(cp).processes
	assert(processes)
	p = processes[-1]
	try {
		p.stdout.decode({'process': p, 'pipeline': cp})
	} catch(e) {
		throw ProcessFail("Failed to decode process output").set('process', p).set('cause', e)
	}
}

doc Send signal to a process. Uses KILL(2). Throws KillFail on error.
doc sig - Signal to send. Defaults to SIGNALS.TERM
doc %RET - unspecified at this time, do not count on it
F kill(pid:Int, sig:Int=SIGNALS.TERM) {
	c_kill(pid, sig)::{
		A == -1 throws KillFail("Failed to kill pid $pid with signal $sig")
		A != 0 throws Error("c_kill() did not return 0 or -1")
	}
}

# XXX: Must join reader/writer threads!
doc Send signal to a Process. Uses KILL(2).
doc Throws InvalidArgument if Process does not have "pid".
doc Throws KillFail on error.
doc sig - Signal to send. Defaults to SIGNALS.TERM
doc %RET - unspecified at this time, do not count on it
F kill(p:Process, sig:Int=SIGNALS.TERM) {
	p.pid is Null throws InvalidArgument("Can't kill() a process that does not have a pid")
	kill(p.pid, sig)
}

doc Kill all processes in the ProcessesPipeline. Throws InvalidArgument if ProcessesPipeline is not running (yet).
F kill(pp:ProcessesPipeline, sig:Int=SIGNALS.TERM) {
	pp.processes.map(kill(X, sig))
}

TEST counter = 0; p=$(sleep 5&); if p.processes[0].stdout == null counter +=1; p.kill(); try p.wait() catch(e:ProcessFail) true
TEST p=$(|cat); p.write("abc"); p.close(); p.Str() == "abc"
TEST p=$(|cat|); p.write("abc"); p.read(3) == "abc"
TEST $(echo abc | cat).Str().starts_with("abc")

doc Attempt to decode JSON. Uses decode_json().
F decode(s:Str, hints:Hash={}) {
	ret = Result({ decode_json(s) })
	guard ret
	ret.get()
}

# TODO: handle more than one occurrence of kvsep in each line
doc EXPERIMENTAL. KVS (key-value separator) hint for decode()
doc %EX - decode('a b\nc d', {'KVS': ' '}) == {'a': 'b', 'c': 'd'}
F decode(s:Str, hints:Hash) {
	guard 'KVS' in hints
	s.lines().map(split(X, hints.KVS)).Hash()
}

TEST decode('a b\nc d', {'KVS': ' '}) == {'a': 'b', 'c': 'd'}

doc EXPERIMENTAL. FS (field separator) hint for decode()
doc %EX - decode('a b\nc d', {'FS': ' '})  # [['a', 'b'], ['c', 'd']]
F decode(s:Str, hints:Hash) {
	guard 'FS' in hints
	s.lines().map(split(X, hints.FS))
}

TEST decode('a b\nc d', {'FS': ' '}) == [['a', 'b'], ['c', 'd']]

doc EXPERIMENTAL! Do not use!
doc Handle fields_names hint - run decode() and make Arr[Hash] from Arr[Arr] using provided fields_names
doc %EX - backup_list = fetch('backup.list', {'FS': ' ', 'fields_names': %[env role]})
F decode(s:Str, hints:Hash) {
	guard 'fields_names' in hints
	decode(s, hints.without('fields_names')).map(F(row) {
		zip(hints.fields_names, row).Hash()
	})
}

doc Decode "curl -i" to {"code": Int, "message": Str, "headers": Hash, "headers_arr": Hash, "body": Str}
doc .body is not recursively decoded
doc %RET - Hash
F decode(s:Str, hints:Hash) {
	guard try {a=hints.process.command.argv; a[0] == 'curl' and a.has('-i')}
	sep = "\r\n\r\n"
	p = s.pos(sep)
	headers_lines = s[0..p].lines()
	status_line = headers_lines.shift()
	status_line_parts = status_line.split(' ', 3)
	headers_kvs = headers_lines.map(split(X, ': '))
	{
		"code": status_line_parts[1].Int()
		"message": status_line_parts[2]
		"headers": headers_kvs.Hash()
		"headers_arr": headers_kvs.group(X[0], X[1])
		"body": s[(p+len(sep))..null]
	}
}

doc Encode data as JSON if hints say that "filename" ends with ".json"
doc %RET - Str
F encode(data, hints:Hash={}) {
	guard hints =~ {"filename": Sfx(".json")}
	encode_json(data, hints)
}

doc Returns cp, wihout any processing. Convenient way to pass ready-to-run Command as an argument
doc %EX - F run_when_needed(cp:CommandsPipeline) { ... $(cp) ... }
doc %EX - ...
doc %EX - run_when_needed(%(ls >/tmp/my_ls))
doc %AUTO - %(my_command) , %(my_command | my_other_command)
F '%()'(cp:CommandsPipeline) cp

doc Wait for the process and return lines of its stdout.
doc %RET - Arr of Str
doc %EX - $(seq 10 2 20).lines().map(Int)  # [10,12,14,16,18,20]
F lines(p:Process) p.wait().stdout.lines()

# TODO: ability to handle running process & its streaming stdout
doc Iterate lines of Process' stdout, calling cb with successive lines.
doc Warning: current implementation waits for the process to finish, accumulates all its stdout, and only then starts calling cb for each line.
F lines(p:Process, cb:Fun) {
	p.wait()
	p.stdout.lines(cb)
}

doc Wait for cp and return lines of stdout of the last process.
doc %RET - Arr of Str
doc %EX - $(seq 3 | tac).lines().map(Int)  # [3,2,1]
F lines(pp:ProcessesPipeline) {
	pp.wait()
	pp.processes[-1].stdout.lines()
}

doc Wait for pp and return call cb for each line of stdout of last process.
doc Warning: current implementation waits for the processes to finish, accumulates all stdout of the last process, and only then starts calling cb for each line.
doc %RET - Arr of Str
F lines(pp:ProcessesPipeline, cb:Fun) {
	pp.wait()
	pp.processes[-1].stdout.lines(cb)
}

# XXX: might not be correct on all platforms
TEST ok = false; $(cat /etc/passwd).lines({if ":" in A ok = true}); ok

# === Parse aws output ===========================
# TODO: move to separate auto-loaded file.

doc Do not use directly. Subject to change.
doc Convert "Tags" array in each element of AWS resources (typically returned by AWS CLI) into Hash.
doc Makes "Tags" much more usable.
F stdlib_aws_straighten_tags(a:Arr) a.each(stdlib_aws_straighten_tags)

doc Do not use directly. Subject to change.
doc Convert "Tags" array in the given AWS resource (typically returned by AWS CLI) into Hash.
doc %EX - t = {"Tags": [{"Key": "k", "Value": "v"},{"Key": "k2", "Value": "v2"}]}  # Not very convenient, is it?
doc %EX - t.stdlib_aws_straighten_tags()
doc %EX - t  # {Tags={k=v, k2=v2}}
F stdlib_aws_straighten_tags(h:Hash) {
	if 'Tags' in h {
		h.Tags = Hash(h.Tags.Key, h.Tags.Value)
	}
}

# For the case of { "SecurityGroups": [ "sg-XXXXXXXX" ] }
# Which is output of aws elb apply-security-groups-to-load-balancer --load-balancer-name SOMETHING -beame-servers-authz --security-groups sg-XXXXXXXX
doc Do not use directly. Subject to change.
doc A no-op
F stdlib_aws_straighten_tags(s:Str) null

TEST instances = [{"Tags": [{"Key": "k", "Value": "v"},{"Key": "k2", "Value": "v2"}]}]; stdlib_aws_straighten_tags(instances); instances.Tags == [{"k": "v", "k2": "v2"}]
TEST instances = ["something"]; stdlib_aws_straighten_tags(instances); instances == ["something"]

doc Parse the output of "aws" command. Extracts the array (see "s" below"). For "describe-instances", flattens the instance list.
doc s - Str containing JSON with a Hash at top level with exactly one Arr as value
doc hints - hints.process.command.argv[0] must be 'aws'
doc %RET - data structure, typically an Arr at top level. If s is empty string - null.
F decode(s:Str, hints:Hash) {
	guard (try hints.process.command.argv[0] == 'aws') or (try hints.process.command.options.decode == 'aws')

	if s == '' {
		# cloudfront empty list
		if hints.process.command.argv.get(1, null) == 'cloudfront' and hints.process.command.argv.get(2, null) ~ /^list/ {
			return []
		}
		# aws ec2 create-tags/delete-tags
		return null
	}

	data = decode_json(s)
	guard data is Hash

	# try - because argv might be shorter than 3 elements
	if try hints.process.command.argv[0..3] =~ %[aws resource-explorer-2 get-index] {
		return data
	}

	if hints.process.command.argv.get(1, null) == 'cloudfront' {
		# TODO: eliminate stupid 'Quantity' field.
		# Can not convert {'Quantity': ..., 'Items': [ iii ]} to just [ iii ]
		# because _some_ (of course, AWS) Hashes contain additional keys:
		# TrustedSigners: [Enabled]
		# AllowedMethods: [CachedMethods]
		# GeoRestriction: [RestrictionType]
	}

	# CloudFront
	# aws cloudfront list-invalidations --distribution-id --> { "InvalidationList": { "Items": [ ... ] } }

	if (len(data) == 1) and (data.values()[0] is Hash) and (data.values()[0].len() == 1) {
		candidate = data.values()[0].values().the_one()
		candidate is Arr returns candidate
	}

	if 'DistributionList' in data {
		guard data.DistributionList.len() == 1
		return data.DistributionList.Items
	}

	# Use the only top-level key that has array as it's value
	# Thanks goes to Elastic Beanstalk which complicates this,
	# all other APIs seem to return only one top-level key.
	# ( aws elasticbeanstalk describe-configuration-options )

	top_level_vals = data.values().filter(Arr)

	guard top_level_vals.len() == 1

	data = top_level_vals[0]

	# Anyone cares about Reservations? Certainly it's not the common case so...
	if data.all('ReservationId' in X) {
		# Put reservation data into ._Reservation field of each instance, just in case
		data.each(F(reservation) {
			reservation.Instances._Reservation = [ reservation.without('Instances') ] * len(reservation.Instances)
		})
		data = data.Instances.flatten()
	}
	data.stdlib_aws_straighten_tags()
}

doc Parse the output of "find" command which does not use "-printf". Handles "-print0".
doc hints - hints.process.command.argv[0] must be 'find'
doc %RET - Arr of Str
F decode(s:Str, hints:Hash) {
	guard try hints['process'].command.argv[0] == 'find'
	argv = hints['process'].command.argv
	guard '-printf' not in argv
	zero_sep = '-print0' in argv
	if zero_sep then s.split(chr(0))[0..-1] else s.lines()
}

doc Parse the output of "locate" command.
doc hints - hints.process.command.argv[0] must be 'locate'
doc %RET - Arr of Str
F decode(s:Str, hints:Hash) {
	guard try hints['process'].command.argv[0] == 'locate'
	# .map(Path) ?
	s.lines()
}

# === config =====================================

STDLIB_CONFIG = {}

doc Get configuration for the given key. Lookup order / first wins: (1) Environment variable NGS_$k (2) previously set config(k, v)
doc k - Configuration key
doc %RET - Any. If data found in environment variable, it will be decode()d or returned as Str if decode() fails.
doc %EX - conf = config("table_${t.name}")
F config(k:Str) {
	# TODO: think, organize
	#       what about structured data? JSON?
	# TODO: read from config files
	# TODO: read from command line switches
	debug("config", "Getting key '$k'")
	v = try ENV["NGS_$k"]
	if v {
		debug("config", "'$k' found in the environment variable 'NGS_${k}': '$v'")
		return decode(v) tor v
	}
	v = try STDLIB_CONFIG[k]
	if v is not Null {
		debug("config", "'$k' found in STDLIB_CONFIG: $v")
		return v
	}
	debug("config", "'$k' was not found")
	v
}

doc Set configuration. To be used with config(k:Str).
doc %EX - config('table_Instances', %[InstanceId tag_Name tag_env tag_role IPs InstanceType State KeyName SecurityGroups AZ RestOfTags])
F config(k:Str, v) {
	debug("config", "Setting ${k}=${v}")
	STDLIB_CONFIG[k] = v
}

# === Pfx, Sfx, Ifx ============================


type SubSeq
	doc Prefix subsequence of a sequence
	type Pfx(SubSeq)
		doc Prefix that might or might not be present for (-) to succeed
		type MaybePfx(Pfx)
		doc Prefix that must be present for ~ matching to succeed
		type MustPfx(Pfx)
	doc Infix subsequence of a sequence
	type Ifx(SubSeq)
		doc Infix that might or might not be present for (-) to succeed
		type MaybeIfx(Ifx)
		doc Infix that must be present for ~ matching to succeed
		type MustIfx(Ifx)
	doc Suffix subsequence of a sequence
	type Sfx(SubSeq)
		doc Suffix that might or might not be present for (-) to succeed
		type MaybeSfx(Sfx)
		doc Suffix that must be present for ~ matching to succeed
		type MustSfx(Sfx)

doc Convert Success to FullBox
doc %RET - FullBox
doc %EX - Box("abcd" ~ /^(..)/).map({"First two letters: ${A[1]}"}).get("(too short)")  # First two letters: ab
F Box(s:Success) FullBox(ms)

doc Convert failure to EmptyBox
doc %RET - EmptyBox
doc %EX - Box("a" ~ /^(..)/).map({"First two letters: ${A[1]}"}).get("(too short)")  # (too short)
F Box(f:Failure) EmptyBox()

doc SubSec constructor
F init(s:SubSeq, val) s.val = val

# The common case
doc Convenience method for creating MustPfx
doc %RET - MustPfx
F Pfx(val) MustPfx(val)

doc Convenience method for creating MustIfx
doc %RET - MustIfx
F Ifx(val) MustIfx(val)

doc Convenience method for creating MustSfx
doc %RET - MustSfx
F Sfx(val) MustSfx(val)

F Str(s:SubSeq) "<${s.Type().name} ${s.val}>"

doc Return string without the prefix. Throws InvalidArgument if pfx is MustPfx but s does not start with it.
doc s - original string
doc pfx - prefix to get rid of
doc %RET - s without pfx
doc %EX - "abcde" - Pfx("ab")  # "cde"
doc %EX - "abcde" - Pfx("xy")  # InvalidArgument exception
doc %EX - "abcde" - MaybePfx("xy")  # "abcde"
F -(s:Str, pfx:Pfx) {
	s.starts_with(pfx.val) returns s[pfx.val.len()..null]
	pfx is MustPfx throws InvalidArgument("Given string '$s' does not start with prefix '${pfx.val}'").set('s', s).set('pfx', pfx)
	s
}

TEST "abc" - Pfx("a") == "bc"
TEST { "abc" - Pfx("wa") }.assert(InvalidArgument)
TEST "abc" - MaybePfx("wa") == "abc"


doc Return string without the suffix. Throws InvalidArgument if pfx is MustSfx but s does not end with it.
doc s - original string
doc sfx - suffix to get rid of
doc %RET - s without pfx
doc %EX - "abcde" - Sfx("de")  # "abc"
doc %EX - "abcde" - Sfx("xy")  # InvalidArgument exception
doc %EX - "abcde" - MaybeSfx("xy")  # "abcde"
F -(s:Str, sfx:Sfx) {
	s.ends_with(sfx.val) returns s[0 .. (s.len() - sfx.val.len())]
	sfx is MustSfx throws InvalidArgument("Given string '$s' does not end with suffix '${sfx.val}'").set('s', s).set('sfx', sfx)
	s
}

TEST "abc" - Sfx("c") == "ab"
TEST { "abc" - Sfx("cd") }.assert(InvalidArgument)
TEST "abc" - MaybeSfx("cd") == "abc"

doc Return string without the infix. Throws InvalidArgument if ifx is MustIfx but s does not contain it.
doc s - original string
doc ifx - infix to get rid of
doc %RET - s without ifx
doc %EX - "abcde" - Ifx("bc")  # "ade"
doc %EX - "abcde" - Ifx("xy")  # InvalidArgument exception
doc %EX - "abcde" - MaybeIfx("xy")  # "abcde"
F -(s:Str, ifx:Ifx) {
	p = s.pos(ifx.val)
	p is not Null returns s[0 .. p] + s[(p + ifx.val.len()) .. s.len()]
	ifx is MustIfx throws InvalidArgument("Given string '$s' does not contain infix '${ifx.val}'").set('s', s).set('ifx', ifx)
	s
}

TEST "abcde" - Ifx("bc") == "ade"
TEST { "abcde" - Ifx("xy") }.assert(InvalidArgument)
TEST "abcde" - MaybeIfx("xy") == "abcde"

doc Check whether s starts with pfx.
doc %EX - "abcde" ~ Pfx("ab")  # <MatchSuccess matches=[ab] pattern=<MustPfx ab> before= after=cde>
doc %EX - "abcde" ~ Pfx("xy")  # <MatchFailure >
doc %RET - MatchResult
F ~(s:Str, pfx:Pfx) {
	not(s.starts_with(pfx.val)) returns MatchFailure(s, pfx)
	ret = MatchSuccess([pfx.val], pfx)
	ret.before = ''
	ret.after = s[pfx.val.len()..null]
	ret
}

doc Check whether s contains i. Same as s ~ i.val
doc %RET - MatchResult
F ~(s:Str, i:Ifx) s ~ i.val

doc Check whether s ends with sfx.
doc %EX - "abcde" ~ Sfx("de")  # <MatchSuccess matches=[de] pattern=<MustSfx de> before=abc after=>
doc %EX - "abcde" ~ Pfx("xy")  # <MatchFailure >
doc %RET - MatchResult
F ~(s:Str, sfx:Sfx) {
	not(s.ends_with(sfx.val)) returns MatchFailure(s, sfx)
	ret = MatchSuccess([sfx.val], sfx)
	ret.before = s[0..(s.len() - sfx.val.len())]
	ret.after = ''
	ret
}

# TODO: make it a low priority method implementation
doc Convenience method to access matches in MatchSuccess
doc %EX - ("abc" ~ /a(.)c/)[1]  # "b"
F '[]'(ms:MatchSuccess, idx:Int) ms.matches[idx]

doc Get indexed match, returning dflt is the match is not found
F get(ms:MatchSuccess, idx:Int, dflt=null) ms.matches.get(idx, dflt)

TEST ("abc" ~ /a(.)c/)[1] == "b"

doc Checks subsequence presence.
doc %RET - Bool
F =~(x, s:SubSeq, _mc:MatchContext) {
	s.val is not Str throws NotImplemented("Matching non-Str SubSeq is not implemented yet").set(val=s)
	x is not Str returns false
	Bool(x ~ s)
}

TEST 1 !~ Pfx("a")

# === RegExp =====================================

# TODO: better exceptions
doc Find PCRE regular expression in s. Empty string without options returns MatchFailure. Throws Error if more than 20 captures are used or if there is an error during matching.
doc offset - search start offset
doc options - options to pass to underlying PCRE_EXEC(3).
doc %RET - MatchResult
doc %EX - globals().keys().filter(/^C_PCRE/)  # lists possible options
doc %EX - "xabcy" ~ /a(.)c/  # <MatchSuccess matches=[abc,b] pattern=<RegExp> named={} positions=[<NumRange 1..4 include_start=true include_end=false step=1>,<NumRange 2..3 include_start=true include_end=false step=1>] whole=abc before=x after=y>
doc %EX - m = ("xabcy" ~ /a(?P<mychar>.)c/)
doc %EX - echo(m.named.mychar)  # Outputs: b
doc %AUTO - my_str ~ my_regexp
F ~(s:Str, r:RegExp, offset:Int=0, options:Int=0) {
	result = c_pcre_exec(r, s, offset, options)
	if result is Int {
		result == C_PCRE_ERROR_NOMATCH returns MatchFailure(s, r)
		result == 0 throws Error("Too many captures. Max 20")
		result < 0 throws Error("RegExp matching error in c_pcre_exec").set('code', result)
		assert(false, "Unexpected integer result from c_pcre_exec")
	}
	assert(result is Arr, "c_pcre_exec must return either integer or an array")
	ret = MatchSuccess(
		result.map(2, F(start_pos, end_pos) {
			if start_pos >= 0
				s[start_pos..end_pos]
			else
				null
		})
		r
	)
	ret.named = r.names.mapv(F(capture_num) try ret.matches[capture_num])
	ret.positions = result.map(2, NumRange)
	ret.whole = ret.matches[0]
	ret.before = s[0..result[0]]
	ret.after = s[result[1]..null]
	ret
}

TEST m = "xabcy" ~ /a(.)c/; m.matches == ["abc", "b"] and m.before == 'x' and m.after == 'y' and m.whole == 'abc'
TEST m = "xAbcy" ~ /a(.)c/; m is MatchFailure

PCRE_NEWLINE_TO_OPTIONS = {
	         13: C_PCRE_NEWLINE_CR,
	         10: C_PCRE_NEWLINE_LF,
	13*256 + 10: C_PCRE_NEWLINE_CRLF,
	         -2: C_PCRE_NEWLINE_ANYCRLF,
	         -1: C_PCRE_NEWLINE_ANY,
}

doc Find all non-overlapping matches of regular expression in a string.
doc %RET - if collect_unmatched - Arr with each element being MatchSuccess or Str, if not collect_unmatched - Arr of MatchSuccess
doc %EX - ("x10ab20c30y" ~~ /[0-9]+/).whole.map(Int).sum()  # 60
doc %EX -
doc %EX - arr = (~~)("x10ab20c30y", /[0-9]+/, true)
doc %EX - arr .= map(F(elt) if elt is MatchSuccess "[${elt.whole}]" else elt)
doc %EX - arr.join("")  # "x[10]ab[20]c[30]y"
F ~~(s:Str, r:RegExp, collect_unmatched:Bool=false) {
	collector {
		m = (~)(s, r, 0)
		if not(m) {
			if collect_unmatched collect(s)
			return
		}
		start_offset = m.positions[0].start
		next_offset = m.positions[0].end
		if collect_unmatched and start_offset then collect(s[0..start_offset])
		collect(m)
		option_bits = r.options
		utf8 = option_bits.band(C_PCRE_UTF8).Bool()
		option_bits = option_bits.band([C_PCRE_NEWLINE_CR, C_PCRE_NEWLINE_LF, C_PCRE_NEWLINE_CRLF, C_PCRE_NEWLINE_ANY, C_PCRE_NEWLINE_ANYCRLF].reduce(0, bor))
		option_bits = option_bits or PCRE_NEWLINE_TO_OPTIONS.get(PCRE_NEWLINE, 0)
		crlf_is_newline = option_bits in [C_PCRE_NEWLINE_ANY, C_PCRE_NEWLINE_CRLF, C_PCRE_NEWLINE_ANYCRLF]
		while true {
			options = 0
			if start_offset == next_offset {
				next_offset == len(s) breaks
				options = bor(C_PCRE_NOTEMPTY_ATSTART, C_PCRE_ANCHORED)
			}
			m = (~)(s, r, next_offset, options)
			if m {
				if collect_unmatched {
					if next_offset != m.positions[0].start {
						collect(s[next_offset..m.positions[0].start])
					}
				}
				start_offset = m.positions[0].start
				next_offset = m.positions[0].end
				collect(m)
				continue
			}
			options == 0 breaks
			next_offset += 1
			if (crlf_is_newline) and (try s[next_offset-1..next_offset+1] == '\r\n') {
				next_offset += 1
				continue
			}
			if utf8 {
				while (next_offset < len(s)) and (s[next_offset].ord().band(0xC0) == 0x80) {
					next_offset += 1
				}
				continue
			}
		}
		if collect_unmatched and (next_offset < len(s)) {
			collect(s[next_offset..null])
		}
	}
}

# TODO: test ~~() \r\n skipping
TEST ("ab\r\ncd" ~~ /(*CRLF)|./m).whole.filter(len) == ['a', 'b', 'c', 'd']
TEST ("ab\r\ncd" ~~ /|./m).whole.filter(len) == ['a', 'b', '\r', 'c', 'd']
# UTF-8 of "" is 209(D1), 143(8F)
# Skip for older library using try ... catch
TEST try ("ab" ~~ /(*UTF)|\\x8F|b/).whole.filter(len) == ['b'] catch(e:RegExpCompileFail) 'not recognized' in e.message

# Last two are for repeated searches
STDLIB_REGEXP_FLAGS = {
	'i': C_PCRE_CASELESS
	'm': C_PCRE_MULTILINE
	's': C_PCRE_DOTALL
	'x': C_PCRE_EXTENDED

	'a': C_PCRE_ANCHORED
	'n': C_PCRE_NOTEMPTY_ATSTART
}

doc Regular expression constructor.
doc %AUTO - /myregex/
doc %RET - RegExp
doc %EX - my_re = /blah/
F //(regexp:Str, flags:Str) {
	# Maybe add each(Str,Fun) ?
	# TOOD: bitwise or instead of sum()
	options = flags.map(F(flag) {
		STDLIB_REGEXP_FLAGS[flag] tor throw RegExpCompileFail("Unknown flag $flag").set('regexp', regexp).set('flags', flags)
	}).sum()

	c_pcre_compile(regexp, options)
}

TEST Bool("A" ~ /a/i)

doc Returns the string with one occurrence of regexp cut out of it. Throws InvalidArgument if s does not contain r.
doc %EX - "abc01def23" - /[0-9]+/  # "abcdef23"
doc %RET - Str
F -(s:Str, r:RegExp) {
	m = s ~ r
	not(m) throws InvalidArgument('String does not contain the RegExp').set('string', s).set('regexp', r)
	s[0..m.positions[0].start] + s[m.positions[0].end..null]
}

TEST "abc01def23" - /[0-9]+/ == "abcdef23"

doc Split string by regexp
doc %RET - Arr of Str
doc %EX - "x10ab20c30y".split(/[0-9]+/).join(" :: ")  # "x :: ab :: c :: y"
F split(s:Str, r:RegExp) (~~)(s, r, true).filter(Str)

TEST "ab01de12f".split(/[0-9]+/) == ['ab', 'de', 'f']

doc Get string with all occurrences of r removed
doc %RET - Str
doc %EX - "x10ab20c30y".without(/[0-9]+/)  # "xabcy"
F without(s:Str, r:RegExp) s.split(r).join('')

TEST "ab01de12f".without(/[0-9]+/) == 'abdef'

# TODO: make it a low priority method implementation
doc Get substring of a string that corresponds to first match of given regular expression
doc %EX - "x10ab20c30y"[/[0-9]+/]  # "10"
F '[]'(s:Str, r:RegExp) {
	not((m = s ~ r)) throws InvalidArgument("String does not contain the given RegExp").set('container', s).set('regexp', r)
	m.whole
}

TEST "ab01de12f"[/[0-9]+/] == '01'

doc %RET - Checks whether the only argument is of type Str and matches (~) r
doc %EX - %[w1 w2].filter(/1/)  # %[w1]
F =~(x, r:RegExp, _mc:MatchContext) {
	# TODO: Maybe merge named matches into MatchContext
	x is not Str returns false
	Bool(x ~ r)
}

TEST %[w1 w2].filter(/1/) == %[w1]
TEST %[1 w2].filter(/1/) == []

doc Replace all occurrences of r
doc mapper - Function that will be called with one matching string at a time that provides the replacement
doc %RET - Str
doc %EX - "x10ab20c30y".replace(/[0-9]+/, F(match_text) "[$match_text]")  # "x[10]ab[20]c[30]y"
F replace(s:Str, r:RegExp, mapper:Fun) {
	(~~)(s, r, true).map(F(x) {
		ematch x {
			MatchSuccess mapper(x.whole)
			Str x
		}
	}).join('')
}

TEST "x10ab20c30y".replace(/[0-9]+/, F(match_text) "[$match_text]") == "x[10]ab[20]c[30]y"

F replace(s:Str, r:RegExp, replacement:Str) s.replace(r, {replacement})

TEST "x10ab20c30y".replace(/[0-9]+/, "@") == "x@ab@c@y"

# === Fun ========================================

doc Call cb n times without any parameters and accumulate the results.
doc %EX - a = Box * 2; a[0] is Box and a[1] is Box and a[0] !== a[1]  # true
F *(cb:Fun, n:Int) n.map({ cb() })

TEST a = Box * 2; a[0] is Box and a[1] is Box and a[0] !== a[1]

# === Null =======================================

doc Convert null to NGS code that would produce null when executed.
doc %RET - Str
F code(n:Null) "null"

doc Convert Null into JSON compatible data structure - null
F JsonData(n:Null) n

section "Lines" {
	doc Array of strings which comprise a text which is treated as a
	doc unit for purposes of output (and maybe for other purposes later).
	type Lines(ArrLike)

	doc Split s to strings using end-of-line separators.
	doc UNIX and Windows line endings supported (Windows - not tested yet).
	doc Warning: Max OS <= 9 line separation of CR (\r) is not supported
	doc %EX - "xx\nyy".lines()  # %[xx yy]
	F init(lines:Lines, s:Str) {
		_lines = if s {
			s -= MaybeSfx('\n')
			s.split('\n').map(X - MaybeSfx('\r'))
		} else {
			[]
		}
		lines.init(_lines)
	}

	doc Echo all lines using echo(Str)
	F echo(lines:Lines) lines.each(echo)

	doc Echo all lines to dst
	F echo(dst, lines:Lines) {
		lines.each(echo(dst, X))
		dst
	}

	doc Write all lines to standard error using warn(Str)
	F warn(lines:Lines) lines.each(warn)

	doc Write all lines to standard error using error(Str)
	F error(lines:Lines) lines.each(error)

	# Later this should be a widget which can be displayed
	# with ASCII art in console or as a box in a browser.
	# WARNING: only works when one byte is one character.
	doc %STATUS - experimental
	F framed(lines:Lines) {
		not(lines) returns lines
		m = lines.map(len).max()
		border = '+' + ('-' * (m+2)) + '+'
		collector/Lines() {
			collect(border)
			lines.each(F(x) collect("| ${x.Str(m)} |"))
			collect(border)
		}
	}
}

# === exit_hook - Print uncaught exception =======

doc Convert an array to a possibly shorter version, for displaying to human.
doc chunk_size - number of elements to retain at the beginning and at the end.
doc marker - how to mark the cut elements in the middle.
doc %RET - Arr
doc %EX - my_array = Arr(1...100)
doc %EX - digest(my_array, 2).each(echo)
doc %EX - # 1
doc %EX - # 2
doc %EX - # (...)
doc %EX - # 99
doc %EX - # 100
F digest(a:Arr, chunk_size:Int, marker:Str='(...)') {
	l = a.len()
	l < chunk_size*2 returns a
	a[0..chunk_size] + [marker] + a[(l-chunk_size)..l]
}

doc Catch-all for exception_specific_message().
doc %RET - default message
F exception_specific_message(e:Exception) {
	Lines(["Unfortunately the exception had no message.", "Exception type might give a hint: ${e.Type().name}"])
}

doc Format exception message for any exception that has .message
F exception_specific_message(e:Exception) {
	guard e.has('message')
	e.message.ensure(Lines)
}

doc Format CompileFail exception message
F exception_specific_message(cf:CompileFail) {
	# Lines(["xx"])
	collector/Lines() {
		collect("Syntax error in file ${cf.position.file}, line ${cf.position.line}, column ${cf.position.column}")
		l = cf.given.lines().map(F(line) line.replace('\t', ' '))
		min_line = max(cf.position.line - 4, 0)
		max_line = min(cf.position.line + 3, len(l))
		num_width = max_line.Str().len()

		F pfx(i:Int) "${Str(i, num_width)}: "

		for i in min_line..max_line {
			collect(pfx(i+1) + l[i])
			if i+1 == cf.position.line {
				collect(' ' * (len(pfx(i+1)) + cf.position.column - 1) + "^")
			}
		}
	}
}

doc Format GlobalNotFound exception message.
doc %RET - Lines
F exception_specific_message(gnf:GlobalNotFound) {
	Lines(["Global variable '${gnf.name}' not found"])
}

doc Format UndefinedLocalVar exception message.
doc %RET - Lines
F exception_specific_message(ulv:UndefinedLocalVar) {
	Lines(["Local variable '${ulv.name}' not found"])
}

doc Format MethodNotFound exception message.
doc %STATUS - WIP
doc %RET - Lines
F exception_specific_message(mnf:MethodNotFound) {

	F name(callable:Fun) {
		methods_names = callable.Arr().map(meta).get('name')
		if methods_names and methods_names.all(X == methods_names[0]) {
			methods_names[0]
		}
	}

	F name(callable:UserDefinedMethod) {
		callable.meta().get('name')
	}

	mn = name(mnf.callable) or '(method name unavailable, maybe anonymous)'
	Lines([
		"The arguments did not match any of the methods' parameters."
		"Method or MultiMethod name: ${mn}"
		"Called with arguments' types: ${mnf.args.map(Type).name.join(', ')}"
		"Please check that you pass the right number of arguments."
		"Please check that arguments' types are matching methods' parameters."
	])
}

# TODO: show relevant value part
doc Format JsonDecodeFail exception message.
doc %RET - Lines
F exception_specific_message(jdf:JsonDecodeFail) {
	Lines([
		"Failed to parse JSON"
		"Error message: ${jdf.error}"
		"Error position in given JSON: ${jdf.position}"
		"(TODO: show relevant value part)"
	])
}

doc Format KeyNotFound exception message for ENV global variable.
doc %RET - Str
F exception_specific_message(knf:KeyNotFound) {
	guard knf.container === ENV
	Lines(["Environment variable '${knf.key}' is not set."])
}

F exception_specific_message(re:ResultsException) {
	Lines([
		"Some of the computations failed: ${re.message}"
		"Total computations: ${re.results.len()}"
		"Succeeded: ${re.results.count(Success)}"
		"Failed: ${re.results.count(Failure)}"
	])
}

F exception_specific_message(re:FailuresException) {
	Lines([
		"Some of the computations failed: ${re.message}"
		"Total computations: ${re.succeeded + re.failed}"
		"Succeeded: ${re.succeeded}"
		"Failed: ${re.failed}"
	])
}

doc Don't use, subject to change, including name
doc %STATUS - experimental
F SafeStr(val) {
	v = "$val" tor "(Failed to inspect <${val.Type().name tor '(unknown type)'}>)"
	assert(v, Str, "Str(${val.Type().name}) must return an Str, not ${v.Type().name}")
	v.limit(128*1024, '...').map(F(ch) {
		o = ord(ch)
		o >= 32 and ch != '\\' returns ch
		'\\x' + encode_hex(ch)
	}).join('')
}

doc Convert Backtrace to human-readable format
doc %EX - Lines(bt).echo()
F init(lines:Lines, backtrace:Backtrace, parent_backtrace=null) {
	# guard parent_backtrace =~ AnyOf(Null, Backtrace)
	# TODO ^
	guard parent_backtrace is Null or parent_backtrace is Backtrace
	super(lines)
	parent_frames = parent_backtrace.frames tor []
	backtrace.frames.each_idx_val(F(idx, frame) {
		# Don't print frames that overlap with parent exception
		frame.ip == (try parent_frames[idx].ip) returns
		l = resolve_instruction_pointer(frame.ip)
		closure = " [in ${frame.closure.meta().name}]" tor ''
		push(lines, "Frame $idx: ${l.file}:${l.first_line}:${l.first_column} - ${l.last_line}:${l.last_column}$closure")
	})
}

doc Print exception to stderr. Uses inspect().
doc level - indentation level to use (two spaces for each level)
doc parent - parent exception if print_exception() was called for .cause exception
F print_exception(e:Exception, level:Int = 0, parent:Exception = null, echo=echo(stdlib_error_fd, X)) {

	F err(message) echo(pfx + message)

	pfx = "[ERROR ${Time()}] " + "  " * level
	h = Hash(e)

	m = try {
		exception_specific_message(e)
	} catch(e) {
		guard not(ENV.get('NGS_THROW_ESM'))
		Lines(['(failed to get friendly exception message)'])
	}

	m.framed().err()

	err("Exception of type ${e.Type().name} occurred")

	info_keys = h.keys() - %[backtrace cause]

	info_keys.each(F (k) {
		out = inspect(h[k]) tor Lines(["Info: $k - (Failed to inspect)"])
		if (out is not Lines) or not(out) {
			out = Lines(["Info: $k - (Failed to inspect, no inspection info)"])
		}
		out .= mapo(limit(X, 128, '...'))
		if out.len() == 1 {
			err("Info: $k = ${out[0]}")
		} else {
			err("Info: $k:")
			err("  " + out)
		}
	})

	if 'backtrace' in h {
		err(Lines(h.backtrace, try parent.backtrace))
	}

	if 'cause' in h {
		err("Cause:")
		if e.cause is Exception {
			print_exception(e.cause, level+1, e, echo)
		} else {
			err("  (WARNING: cause is not Exception)")
			err("  " + inspect(e.cause))
		}
	}

	if ('results' in h) and (h.results is Results) {
		h.results.filter(Failure).Arr().each_idx_val(F(i:Int, f:Failure) {
			err("  ${h.results.Type().name} exception #${i+1}")
			print_exception(f.val, level+2, e, echo)
		})
	}

	if level == 0 {
		echo(m.framed())
	}

}

exit_hook = Hook()

block _ {

	global print_exception

	do_exit_backtrace = ENV.get('NGS_EXIT_BACKTRACE', '0').decode(Bool)

	if not(do_exit_backtrace) {
		F print_exception(e:NormalExit) {
			if 'message' in e {
				echo(stdlib_error_fd, e.message)
			}
		}
	}

	# TODO: consider running this hook item last.
	#       If it has exception, it could prevent
	#       user-defined cleanups.
	exit_hook.print_exception = F(exit:Exit) {
		try {
			exit.exceptions.each(print_exception)
		} catch(e) {
			error("Exit hook 'print_exception' failed to print exception. Following exception is the cause.")
			try {
				print_exception(e)
			} catch(e) {
				error("Failed to print the cause.")
			}
		}
	}
	exit_hook.print_exception.meta().keep_after_fork = true

}

# === Time =======================================

type Time
type TimeFail(CError)

TIME_FORMAT = ENV.get('NGS_TIME_FORMAT', '%F %T %Z')

doc Get epoch time
doc %RET - Int
F time() {
	ret = c_time()
	ret == -1 throws TimeFail("Failed to get time")
	ret
}

# TODO: handle errors
doc Low-level function. Do not use directly. Use Time type.
F gmtime(t:Int) {
	ret = c_gmtime(t)
	ret
}

# TODO: handle errors
doc Low-level function. Do not use directly. Use Time type.
F localtime(t:Int) {
	ret = c_localtime(t)
	ret
}

doc Low-level function. Do not use directly. Use Time type.
F strftime(tm:c_tm, format:Str) {
	ret = c_strftime(tm, format)
	ret is Null throws TimeFail("Failed to c_strftime()").set('tm', tm).set('format', format)
	ret
}

doc Initialize Time object with current time.
F init(t:Time) {
	t.epoch = time()
}

doc Initialize Time object with the given epoch time.
F init(t:Time, epoch:Int) {
	t.epoch = epoch
}

F init(t:Time, s:Str, format:Str) {
	result = c_strptime(s, format)
	if result[0] != len(s) or result[1] is Null {
		throw InvalidArgument("Failed to parse time").set(s=s,format=format)
	}
	t.epoch = c_mktime(result[1])
}

doc Parse known date/time formats
F init(t:Time, s:Str) block b {
	# AWS API returns (different formats of course)
	#  * %Y-%m-%dT%H:%M:%S.000%Z
	#  * 2022-11-03T09:14:25.219000+04:00
	orig_s = s
	s .= replace(/\.\d+/, '')  # Can't handle fractions of a second (yet?)
	s .= replace(/Z$/, {'+0000'})  # On MacOS "%Z" nor "%z" match 'Z' so working around - start
	s .= replace(/(?<=\+\d\d):(?=\d\d)/, '')  # +04:00 --> +0400 (arbitrary -> %z)
	# On MacOS "%Z" nor "%z" match 'Z' so working around - end
	formats = [
		'%Y-%m-%dT%H:%M:%S%z'
		'%F %T'
		'%F'
	]
	formats.each(F(fmt) {
		try {
			init(t, s, fmt)
			b.return(t)
		} catch(e:InvalidArgument) {
			"OK"
		}
	})
	throw InvalidArgument("Failed to parse time").set(s=orig_s, s_transformed=s, formats=formats)
}

# TODO: dedup. Time only should say that Int() should be used for comparing.
F '=='(a:Time, b:Time) a.Int() == b.Int()
F '<='(a:Time, b:Time) a.Int() <= b.Int()
F '<'(a:Time, b:Time) a.Int() < b.Int()
F '>='(a:Time, b:Time) a.Int() >= b.Int()
F '>'(a:Time, b:Time) a.Int() > b.Int()

doc String representation of Time
doc format - strftime(3) format
doc gmt - Use GMT time zone (defaults to local time zone)
F Str(t:Time, format:Str=TIME_FORMAT, gmt:Bool=false) strftime([localtime, gmtime][Int(gmt)](t.epoch), format)

F Int(t:Time) t.epoch


doc Mesure running time of cb in microseconds
doc %RET - Int
F time(cb:Fun) {
	start = c_gettimeofday()
	cb()
	finish = c_gettimeofday()
	(finish[0]* 1000000 + finish[1]) - (start[0] * 1000000 + start[1])
}

F Bool(t:Time) true

doc Convert Time into JSON compatible data structure - number (epoch seconds)
F JsonData(t:Time) t.epoch

# === Random =====================================
# This is _not_ crypto safe random!

srand(time())

doc Pick n random unique elements from something
doc something - Something that has len(something) and something[idx]
doc %RET - Arr or Str, depending on something
F rand_uniq(something, n:Int) {
	l = len(something)
	n > l throws InvalidArgument("rand_uniq() - choosing more elements than something has").set(something = something, n=n)
	indexes = Arr(0..l)
	indexes_len = l
	result = []
	for(i;n) {
		idx = rand(indexes_len)
		result.push(something[indexes[idx]])
		indexes[idx] = indexes[indexes_len-1]
		indexes_len -= 1
	}
	something is Str returns result.join('')
	result
}

TEST s=''; for(i;20) s+=chr(ord('A')+i); out=s.rand_uniq(20).Stats(); len(out) == 20 and out.values().all(1)

doc Pick n elements from something. Uniqueness of picked elements is not guaranteed.
doc %RET - Any
F rand(something, n:Int) n.map({ rand(something) })

doc Pick random number from 0 up to but not including n
doc %RET - Int
F rand(n:Int) {
	n <= 0 throws InvalidArgument("rand(n:Int) - n must be 1 or greater")
	r = rand()
	(RAND_MAX+1) % n == 0 returns r % n
	scale = Real(n) / STDLIB_MAX_RAND_REAL
	Real(r) * scale \ floor \ Int
}

# TODO: Sequence super-type?

doc Pick one random element from array
doc %RET - Any
F rand(a:Arr) a[rand(a.len())]

doc Pick random character from a string
doc %RET - Str of length 1
F rand(a:Str) a[rand(a.len())]

F rand(a:Str, n:Int) super(a, n).join('')

doc Pick one random element from a range
doc %RET - Any
F rand(r:NumRange) {
	guard r.step == 1
	points = r.end - r.start - 1 + Int(r.include_start) + Int(r.include_end)
	rand(points) + r.start + if r.include_start then 0 else r.step
}

# === retry facility =============================

doc Represents failure on all retries
type RetryFail(Error)
type RetryBodyMissing(InvalidArgument)

# TODO: Handle NoNext that could occur in sleep iterator
doc Retry. Executes given "body" "times" times. Throws RetryFail if all calls fail and fail_cb is not provided.
doc times - Limit of times to run "body"
doc sleep - Either sleep in seconds between tries or Iter that returns successive sleep times in seconds
doc logger - Function to use to log attempts, caught body exceptions and sleep times. Defaults to stdlib's debug.
doc success_predicate - CANDIDATE FOR REMOVAL. Run against body results to. Says whether the attempt succeeded. Defaults to Bool.
doc title - Prefix strings sent to logger with this string. Defaults to "<retry>".
doc progress_cb - Called before each attempt with (1) current attempt number and (2) limit of attempts ("times"). Defaults to do nothing.
doc success_cb - Called when body succeeds with the result that comes from body. Defaults to identity function.
doc fail_cb - If passed, called if all attempts fail. Defaults to null.
doc %RET - Any. Result of success_cb or result of fail_cb.
doc %EX - page = retry(times=10, sleep=ExpBackIter(), body={ try `curl "http://flaky-site.com"` })
F retry(
	times:Int=60,
	sleep=1,
	logger:Fun=debug("retry", X),
	success_predicate=Bool,
	title="<retry>",
	progress_cb:Fun={null},
	success_cb:Fun=identity,
	fail_cb={throw RetryFail()},
	body:Fun={throw RetryBodyMissing("'body' argument missing in retry()")}
) {
	guard sleep =~ AnyOf(Int, Iter)
	sleep_iter = if sleep is Int then ConstIter(sleep) else sleep
	result = null  # otherwise it will be local to try { ... }
	for(i;times) {
		n = i + 1
		progress_cb(n, times)
		logger("$title Attempt $n out of ${times}")
		try {
			result = body()
		} catch(e:Exception) {
			logger("$title Exception $e")
			throw e
		}
		if success_predicate(result) {
			logger("$title Success")
			return success_cb(result)
		}
		if(i < times - 1) {
			s = sleep_iter.next()
			logger("$title Sleeping ${s} seconds")
			$(sleep "$s")
		}
	}
	logger("$title Failure")
	fail_cb()
}

TEST t = 0; retry(body={t+=1; false}, fail_cb={"OK"}, times=5, sleep=0) == "OK" and t == 5
TEST t = 0; retry(body={t+=1; "OK"}, fail_cb={"NOTOK"}, sleep=0) == "OK" and t == 1

# === Misc =======================================

doc Get process ID
F pid() c_getpid()

doc Get parent process ID
F ppid() c_getppid()

doc Encodes each character in a string as two uppercase hexadecimal digits
doc %RET - Str
doc %EX - encode_hex("ab")  # "6162"
F encode_hex(s:Str) {
	s.map(F(char) {
		n = ord(char)
		CHARS::hexdigits_uppercase[n / 16] + CHARS::hexdigits_uppercase[n % 16]
	}).join('')
}

TEST encode_hex('ab') == '6162'

doc Decodes each two hex digits into a character (byte). Reverse of encode_hex()
doc %RET - Str
F decode_hex(s:Str) {
	len(s) % 2 != 0 throws InvalidArgument("decode_hex() input string must contain even number of bytes")
	l = len(s) / 2
	l.map(F(i) chr(Int(s[i*2..(i*2+2)], 16))).join('')
}

TEST decode_hex("010203") == chr(1) + chr(2) + chr(3)
TEST { decode_hex("0102034") }.assert(InvalidArgument)

STDLIB_INVALID_URI_CHAR_RE = /[^-a-zA-Z0-9_.!~*'()]/
#'

doc Encodes URI component, escaping with %XX hexadecimal codes.
doc %RET - Str
doc %EX - encode_uri_component("ab+c%")  # "ab%2Bc%25"
F encode_uri_component(s:Str) s.replace(STDLIB_INVALID_URI_CHAR_RE, F(char) '%' + encode_hex(char))

TEST encode_uri_component("ab+c%") == "ab%2Bc%25"

# TODO: more efficient
doc Decodes URI component, unsecaping %XX hexadecimals
doc %EX - decode_uri_component("ab%2Bc%25")  # "ab+c%"
F decode_uri_component(s:Str) {
	l = s.len()
	ret = ''
	for(i;l) {
		ret += if s[i] == '%' {
			i += 2
			decode_hex(s[i-1..i+1])
		} else {
			s[i]
		}
	}
	ret
}

TEST decode_uri_component("ab%2Bc%25") == "ab+c%"


doc Encodes HTML. Escapes &, < and > .
doc %RET - Str
doc %EX - "ab>+c%&'".encode_html()  # "ab&gt;+c%&amp;'"
F encode_html(s:Str) s.mapo(CHARS::html_escape.get(X, X))

TEST "ab>+c%&'".encode_html() == "ab&gt;+c%&amp;'"


doc Encodes HTML attribute. Escapes &, <, >, " and ' .
doc %RET - Str
doc %EX - "ab>+c%&'".encode_html_attr()  # "ab&gt;+c%&amp;&#39;"
F encode_html_attr(s:Str) s.mapo(CHARS::html_attr_escape.get(X, X))

TEST "ab>+c%&'".encode_html_attr() == "ab&gt;+c%&amp;&#39;"

doc Used by match EXPR { ... } construct to check whether the expression matches the case.
doc %AUTO match EXPR { ... }
doc %RET - a =~ b
doc %EX - r = match x {
doc %EX -   Int  "Got integer"
doc %EX -   /^a/ "Got special string"
doc %EX -   Str  "Got regular string"
doc %EX - }
F match(a,b) a =~ b

# === File =======================================

doc Check whether current process has the specified access to the file. Wrapper around ACCESS(2). Throws CError.
doc mode - One of the file ACCESS::* modes, defaults to ACCESS::F_OK (test file existance only).
doc %RET - Bool
doc %EX - access(File("mydata"), ACCESS::R_OK).not() throws Error("No access to data file").set("file", "mydata")
F access(f:File, mode:Int=ACCESS::F_OK) {
	ret = c_access(f.path, mode)
	ret == 0 returns true
	assert(ret < 0)
	e = c_errno()
	e == C_EACCES returns false
	# TODO: Better exception
	throw CError(e, "access() failed")
}

# Hope this is correct for all platforms
TEST access(File("/"), bor(ACCESS::R_OK, ACCESS::X_OK))

doc Read whole file
F read(fname:Str) {
	f = File(fname)
	open(f, 'r')
	finally(body = {read(f.fd)}, cleanup = {f.close()})
}

doc Read whole file
F read(f:File) read(f.path)

doc Write whole file
F write(fname:Str, s:Str) {
	'\n' in s and '\n' in fname throws InvalidArgument("Both data and file name contain newline characters").set('s', s).set('fname', fname)
	if '\n' in fname {
		warn("Using deprecated write() arguments order")
		return write(s, fname)
	}
	f = File(fname)
	open(f, 'w')
	finally(body = {write(f, s)}, cleanup = {f.close()})
}

doc Write whole file if it's closed, write to file descriptor if it's open
F write(s:Str, f:File) {
	write(f, s)
}

doc Write whole file if it's closed, write to file descriptor if it's open
F write(f:File, s:Str) {
	write(if f.fd is Null then f.path else f.fd, s)
	f
}

doc Write a string followed by newline character to a File.
doc Throws WriteFail on failure.
doc %RET - null
doc %EX - echo(File("1.txt"), "blah")
F echo(f:File, s:Str) {
	write(f, "${s}${STDLIB_EOL}")
	null
}

doc Write a lines followed by newline character to a File.
doc Throws WriteFail on failure.
doc %RET - null
doc %EX - echo(File("1.txt"), Lines(["aaa", "bbb"]))
F echo(f:File, l:Lines) {
	t = l.map("${X}${STDLIB_EOL}").join('')
	f.write(t)
	null
}

# TODO: better exception
F realpath(path:Str) {
	c_realpath(path) or throw CError("Failed to realpath()").set(path=path)
}

doc %RET - Same type as p but using absolute path
F realpath(p:Path) {
	t = Type(p)
	t(realpath(p.path))
}

section "JSON" {
	doc Convert data structure into JSON compatible data using JsonData and call built-in encode_json().
	doc Implement JsonData() for your own types to customize converting to JSON.
	doc hints - Hash, set 'pretty' to true to pretty-print the JSON
	doc %RET - Str
	F encode_json(x, hints:Hash = {}) {
		ret = super(JsonData(x))
		if hints =~ {'pretty': true} {
			assert(Program('jq'), "encode_json() failed to do 'pretty' formatting - jq program is missing")
			ret = $(| jq .).write(ret).close().wait().stdout
		}
		ret
	}
}

section "base64" {
	doc %STATUS - experimental
	F encode_base64(s:Str, wrap:Int=0) {
		guard OS.posix
		`echo -n $s | base64 -w $wrap`
	}

	doc %STATUS - experimental
	F encode_base64(s:Str, wrap:Int=0) {
		guard OS.darwin
		`echo -n $s | base64 -b $wrap`
	}

	doc %STATUS - experimental
	F decode_base64(s:Str) {
		t = (4 - len(s) % 4) % 4
		fill = "=" * t
		`echo "$s$fill" | base64 --decode 2>${true}`
	}
}

section "Networking" {
	F myip() {
		fetch('https://api.myip.com').ip.IPAddr()
	}
}

section "Caching" {
	# TODO: *args and per-args combination wrapping
	doc Cache cb results. Runs cb only once. TODO: Support arguments.
	doc %RET - New function which wraps cb.
	doc %EX - my_func = cached( { expensive(); calculation(); steps(); result } )
	doc %EX - use_result_of(my_func())
	doc %EX - ...
	doc %EX - use_result_of(my_func())
	F cached(cb:Fun) {
		result = EmptyBox()
		F cached_function_wrapper() {
			if not(result) {
				result = FullBox(cb())
			}
			result.get()
		}
	}
}

section "Doc" {
	doc %STATUS - experimental
	doc %AUTO - \name attr1=val1 attr2=val2 ... [ ... ]
	F \(name:Str, attributes:Hash, children:Arr) {
		Doc::Node(name, children.reject(NoData).map(only(FullBox, get)), **attributes)
	}
}


section "Loading code" {

	NGS_PATH = if (_p = ENV.get('NGS_PATH')) {
		debug('autoload', "Using environment variable NGS_PATH: ${_p}")
		 _p.split(':')
	} else {
		# TODO: XDG
		%[
			${ try ENV.HOME / '.ngs' }
			/usr/local/etc/ngs
			/usr/local/lib/ngs
			/etc/ngs
			/usr/lib/ngs
		].filter()
	}

	F bootstrap_print_compilation_warnings(program_bytecode, fname) {
		program_bytecode.meta().warnings.each(F(w) {
			wl = w.location
			warn("${fname}:${wl.first_line}:${wl.first_column} warning: ${w.message}")
		})
	}

	doc Runs the given file
	doc %RET - Typically whatever the last expression in the file evaluates to
	F require(fname:Str) {
		candidates = NGS_PATH.map(X / fname)
		debug('require', "Candidate files: ${candidates.join(',')}")
		f = candidates.first(File(X), null)
		not(f) throws RequireFail("Failed to require() $fname. It was not found in path").set(fname=fname, path=NGS_PATH, candidates=candidates)
		require(f)
	}

	F require(fname:Str) {
		guard fname =~ AnyOf(Pfx('/'), Pfx('./'))
		try {
			program_text = read(fname)
			program_bytecode = compile(program_text, fname)
			debug('require', "require(): bytecode for ${fname} has length of ${program_bytecode.len()} bytes")
			bootstrap_print_compilation_warnings(program_bytecode, fname)
			program_func = load(program_bytecode, "require()d file: $fname")
			ret = program_func()
			debug('require', "require(): done requiring ${fname}")
			ret
		} catch(e) {
			guard e !~ AnyOf(RequireFail, NormalExit)
			throw RequireFail(e)
		}		
	}

	F require(p:Path) require(p.path)

	doc %STATUS - experimental
	F require(d:Dir) {
		debug('require', "Requiring directory ${d}")
		for path_dir in NGS_PATH.reverse() {
			if _d = Dir(path_dir / d.path) {
				dir(_d).map(require)
			}
		}
	}

	AUTOLOAD = ns {
		global global_not_found_handler

		_lock = ReentrantLock()

		# Sorted by: file, global variable name
		# Not exposing _global_name_to_autoload_file as use cases are not clear yet.
		# Also, it's probably better to expose an API and not the data.
		_global_name_to_autoload_file = %{
			InMemoryCache       Cache
			OnDiskCache         Cache

			IPAddr              IP
			IPNet               IP

			ArrIter             Iter
			ConstIter           Iter
			HashIter            Iter
			NoNext              Iter
			RangeIter           Iter

			ResDef              Res

			InvalidCommandLineArguments bootstrap_invoke

			socket              net
			bind                net

		}

		invocation = 0

		doc Called when reading undefined global.
		doc Implements autoloading.
		doc Searches for autoload/globals/GLOBAL_NAME.ngs in NGS_PATH
		doc WARNING: May have security implications when looking up a name from untrusted source.
		doc %EX - test("My web server runs") do { .... }  # autoload/globals/test.ngs is automatically loaded.
		F global_not_found_handler(name:Str) {
			_lock.acquire({

				F _debug(s:Str) debug("autoload", "global_not_found_handler() [invocation $i] ${s}")

				i = invocation
				invocation += 1
				_debug("name=${name}")
				idx = ll_resolve_global_variable(name)
				ll_is_global_variable_defined(idx) returns
				if name in _global_name_to_autoload_file {
					_debug("loading autoload/globals/${_global_name_to_autoload_file[name]}.ngs")
					require("autoload/globals/${_global_name_to_autoload_file[name]}.ngs")
					return
				}
				_debug("loading autoload/globals/${name}.ngs")

				val = require("autoload/globals/${name}.ngs")
				if not(ll_is_global_variable_defined(idx)) {
					_debug("global variable ${name} still not set; setting")
					ll_set_global_variable(idx, val)
				}

			})
		}
	}

}

section "math" {

	doc %RET - base to the power of exponent
	doc %EX - pow(2, 10) == 1024
	F pow(base:Real, exponent:Real) {
		t = c_pow(base, exponent)
		if t[0] and (e = c_errno()) {
			throw InvalidArgument("pow() failed", CError(e, "c_pow() failed")).set(sign=t[0], result=t[1])
		}
		t[1]
	}

	doc Calls pow(Real, Real) converting parameters and results to and from Real
	F pow(base:Int, exponent:Int) Int(pow(Real(base), Real(exponent)))

	TEST pow(2, 10) == 1024
	TEST { pow(0, -1) }.assert(InvalidArgument)
}

section "JWT" {
	type JWT

	doc Decodes JSON Web Token (JWT)
	F decode(s:Str, hints:Hash={}) {

		F _decode(s) try s.decode_base64().decode_json()

		o = s.trim()
		parts = o.split('.')
		guard len(parts) == 3
		guard all(parts)
		ret = JWT().set(
			original = o
			header = parts[0]._decode()
			payload = parts[1]._decode()
			signature = parts[2]
		)
		guard ret.header and ret.payload
		ret
	}

	doc Convert to JSON compatible data structure - Hash
	F JsonData(j:JWT) j.Hash()

}

TEST t = decode("eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"); t =~ AllOf(JWT, {"header": {"alg": "HS256", "typ": "JWT"}, "payload": {"sub": "1234567890", "name": "John Doe", "iat": 1516239022}})

F sysconf(name:Int) {
	ret = c_sysconf(name)
	e = c_errno()
	if ret == -1 {
		c_errno() throws CError(e, "sysconf() failed")
		null
	}
	ret
}

section "Bootstrap" {

	doc Echo the value before exiting the program, when the value is a result of evaluating the whole program
	doc %STATUS - experimental
	F echo_cli(x) echo(x)

	doc Echo the value as JSON before exiting the program, when the value is a result of evaluating the whole program
	doc %STATUS - experimental
	F echo_cli(x) {
		j = { x.encode_json() }.Result()
		guard j
		echo(j.get())
	}

	doc Do nothing, when the value, which is a Null, is a result of evaluating the whole program
	doc %STATUS - experimental
	F echo_cli(n:Null) nop

	doc Echo the value as a table before exiting the program, when the value is a result of evaluating the whole program.
	doc Only works with TTY and when each element of the array is a Hash and all elements have the same keys.
	doc %STATUS - experimental
	F echo_cli(a:Arr) {
		guard a
		guard isatty(1)
		guard a[0] is Hash
		pattern = a[0].keys().Hash({Any})
		guard all(a, pattern)
		Table2::Table(a).echo()
	}

	doc Echo the value before exiting the program, when the value is a result of evaluating the whole program.
	doc Only works with TTY. Prints each key-value pair as "K: V" on its own line.
	doc %STATUS - experimental
	F echo_cli(h:Hash) {
		guard isatty(1)
		h.map("${X}: ${Y}").each(echo)
	}

	doc Echo the value before exiting the program, when the value is a result of evaluating the whole program.
	doc Only works with TTY.
	doc %STATUS - experimental
	F echo_cli(t:Time) {
		guard isatty(1)
		t.Str().echo_cli()
	}

	doc Echo the value before exiting the program, when the value is a result of evaluating the whole program.
	doc %STATUS - experimental
	F echo_cli(s:Str) echo(s)

	main = MultiMethod()

	doc Internal method. Please do not use.
	doc Main entry point. Executed on NGS boot.
	doc %STATUS - internal
	F bootstrap() {
		global ARGV0
		global ORIG_ARGV = copy(ARGV)

		if 'NGS_BOOTSTRAP_DEBUG' in ENV {
			warn("Using deprecated NGS_BOOTSTRAP_DEBUG environment variable. It has no effect. Use DEBUG=bootstrap instead.")
		}

		code_to_run = null

		debug('bootstrap', 'start')

		ARGV0 = ARGV.shift(null)

		# *** Parse switches ***
		sw = null
		if ARGV {
			a = ARGV[0]
			if a == '--version' {
				echo(VERSION)
				return 0
			}

			if (a == '--help') or (a == '-h') {
				require("cli.ngs")::help()
				return 0
			}

			if a in %[-e -p -pj -ppj -pi -pl -pil -pjl -pc -pt] {
				sw = ARGV.shift()
				# Newline at the end is for avoiding # commenting out the closing }
				# Newline at the beginning is for symmetry
				default_code = 'F default_argv_code() { fetch() }()'
				code_to_run = "{\n${ARGV.shift(default_code)}\n}"
				debug('bootstrap', "Got $sw switch, using command line provided code")
				fname = "<command line ${sw} switch>"

				global global_not_found_handler
				F global_not_found_handler(name:Str) {
					guard name == '_'
					global _ = fetch()
				}
			}
		}

		if not(code_to_run) {
			debug('bootstrap', 'No -e switch was passed, will load the program from a file')
			fname = ARGV.shift(null)
			if fname {
				if fname == '.' {
					fname = './ngsfile'
				}
				ARGV0 = fname
				code_to_run = read(fname)
			} else {
				fname = '<builtin-cli-loader>'
				code_to_run = 'require("cli.ngs")'
			}
		}

		program_bytecode = compile(code_to_run, fname)
		debug('bootstrap', "bootstrap(): bytecode for ${fname} has length of ${program_bytecode.len()} bytes")
		bootstrap_print_compilation_warnings(program_bytecode, fname)
		program_func = load(program_bytecode, "bootstrap()ped file: $fname")

		result = program_func()

		section "Handle NGS program invocation" {

			result = econd {
				result is Namespace {

					F run_subcommand(namespace:Namespace, argv:Arr) {
						F list_subcommands() namespace.filterv(AnyOf(Fun, Namespace)).keys().sort()
						not(argv) throws InvalidCommandLineArguments("Subcommand not specified").set(subcommands=list_subcommands())
						a = argv.copy()
						subcommand = a.shift()
						debug('bootstrap', "bootstrap(): subcommand ${subcommand} argv ${argv}")
						not(subcommand in namespace) throws InvalidCommandLineArguments("Subcommand ${subcommand} not found").set(subcommand=subcommand, subcommands=list_subcommands())
						target = namespace[subcommand]
						target is Namespace returns run_subcommand(target, a)
						target is not Fun throws InvalidCommandLineArguments("${subcommand} is not a method").set(subcommand=subcommand)
						ret = bootstrap_invoke(target, a)
						echo_cli(ret)
					}

					if 'main' in result {
						try {
							bootstrap_invoke(result::main, ARGV)
						} catch(e:InvalidCommandLineArguments) {
							guard ARGV
							run_subcommand(result, ARGV)
						}
					} else {
						if ARGV {
							run_subcommand(result, ARGV)
						} else {
							result
						}
					}
				}
				main is MultiMethod {
					F in_main_file(m) m.ip().resolve_instruction_pointer().file == fname

					m = main.filtero(in_main_file)
					if len(main) != len(m) {
						warn("'main' method was defined in non-main file. That is probably a bug. Continuing anyway.")
					}
					if m {
						bootstrap_invoke(m, ARGV)
					} else {
						result
					}
				}
				main is Fun {
					bootstrap_invoke(main, ARGV)
				}
				true {
					throw MainFail("'main' must be a Namespace, MultiMethod or a Fun, not ${main.Type().name}").set('value', main)
				}
			}
		}

		transformation = {
			'-pl': identity
			'-pil': inspect
			'-pjl': encode_json
		}
		if sw in transformation {
			for r in result {
				transformation[sw](r).echo()
			}
			return 0
		}

		transformation = {
			'-p': identity
			'-pi': inspect
			'-pj': encode_json
			'-ppj': encode_json(X, {'pretty': true})
			'-pc': code
			'-pt': { Table2::Table(A) } # Lazy loading of Table2
		}
		if sw in transformation {
			echo(transformation[sw](result))
			return 0
		}

		result.ExitCode()
	}

	doc Internal method. Please do not use.
	doc Runs bootstrap() and handles exceptions.
	doc %STATUS - internal
	F bootstrap_exception_catch_wrapper() {
		exit = Exit().set(exit_code=0, exceptions=[])
		try {
			exit.exit_code = bootstrap()
		} catch(e:Exception) {
			exit.exceptions.push(e)
			exit.exit_code = 240
			try {
				exit.exit_code = e.ExitCode()
			} catch(e:Exception) {
				exit.exceptions.push(ExitCodeFail("Failed to convert exception to exit code", e))
				exit.exit_code = exit.exit_code + 1
			}
		}

		try {
			exit_hook(exit)
		} catch(e:Exception) {
			exit.exceptions.push(e)
			exit.exit_code = exit.exit_code + 2
			exit.exceptions.each(F(e) {
				error("[bootstrap_exception_catch_wrapper] --- Uncaught exception ---")
				dump(e)
			})
		}

		c_exit(exit.exit_code)
	}

	bootstrap_exception_catch_wrapper()

}
